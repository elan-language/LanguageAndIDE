<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">
<head>
<link href="../ide/styles/colourScheme.css" rel="stylesheet" />
<link href="../ide/styles/documentation.css" rel="stylesheet" />
<link href="../ide/styles/elanStyle.css" rel="stylesheet" />
<title>Elan Language Reference</title>
<script type="text/javascript" src="generated_toc.js"></script>
</head>
<body>
<div class="docTitle">Elan Language Reference</div>
<div id="docTOC">
<div id="generated-toc" class="generate_from_h1 generate_for_page"></div></div>

<div id="Methods"></div>
<h1 id="GlobalInstructions">Global Instructions</h1>
<p>
 <a href="#main">main</a>,
 <a href="#procedure">procedure</a>,
 <a href="#function">function</a>,
 <a href="#test">test</a>,
 <a href="#constant">constant</a>,
 <a href="#enum">enum</a>,
 <a href="#record">record</a>,
 <a href="#class">class</a>,
 <a href="#abstractclass">abstract</a>,
 <a href="#interface">interface</a>
</p>
<p>Global instructions (also referred to simply as 'globals') are located <em>directly</em> within a code file.
  They are never indented from the left-hand edge, nor may they be located <em>within</em> other instructions.
  Three of the globals &ndash; <el-code>main</el-code>, <el-code>function</el-code>, and <el-code>procedure</el-code> &ndash; are described as 'methods' and these are defined by one or more <a href="#statement">statements</a> within them.
  Four of the globals &ndash; <el-code>record</el-code>, <el-code>class</el-code>, <el-code>abstract</el-code> (class), and <el-code>interface</el-code> &ndash; define data structures and these always contain <a href="#Member">members</a>.
  The two remaining globals &ndash; <el-code>constant</el-code>, and <el-code>enum</el-code> &ndash; do not contain any further instructions.</p>

<h2 id="main">Main</h2>
<p>A program file must have a <el-code>main</el-code> method, sometimes called its main routine, if it is intended to be run as a program. You may, however, develop and test code that does not have a <el-code>main</el-code> method, either as a coding exercise or for subsequent use within another program.</p>
<p>The <el-code>main</el-code> defines the start point when a program is run.</p>
<p>The <el-code>main</el-code> does not have to be at the top of the file, but this is a good convention to follow.</p>
<p>The <el-code>main</el-code> may delegate work to one or more <a href="#procedure"><el-code>procedure</el-code></a> or <a href="#function"><el-code>function</el-code></a>.</p>
<p>There may not be more than one <el-code>main</el-code> in a file &ndash; and the Global prompt will not show the <el-code>main</el-code> option when one already exists in the file.</p>
Example of a <el-code>main</el-code> method:

<el-code-block source="main.elan">
<main class="multiline" id="main1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw> <el-msg class="warning"></el-msg></el-top>
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="warning" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end main</el-kw></main>
</el-code-block>

<h2 id="procedure">Procedure</h2>
<p id="Argument">A procedure is a named piece of code that can define <b>parameters</b> which are given inputs via <b>arguments</b> in a <el-code>call</el-code> statement.
Unlike a function, a procedure does not return a value.
  Also unlike a function, a procedure can have 'side effects': indeed it <em>should</em> have side effects, otherwise there would be no point in calling it!
  For this reason the statements within a procedure can:</p>
<ul>
<li>Include <el-code>print</el-code> statements and methods.</li>
<li>include <el-code>input</el-code> methods or other 'system' methods (such as a random number generation).</li>
<li><el-code>call</el-code> other procedures (or itself if <a href="#recursion">'recursion'</a> is required).</li>
<li>Assign a value to a parameter, provided that the parameter definition is preceded by the keyword <el-code>out</el-code>, as in this example:</li>
</ul>
<el-code-block source="inPlaceRippleSort.elan">
  <el-proc class="ok multiline" id="proc11" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident13" class="ok" tabindex="0"><el-txt>inPlaceRippleSort</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params14" class="optional ok" tabindex="0"><el-txt><el-kw>out</el-kw> <el-id>arr</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
  <el-statement class="ok" id="var15" tabindex="0"><el-kw>variable </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="var18" tabindex="0"><el-kw>variable </el-kw><el-field id="var19" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="repeat21" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
  <el-statement class="ok" id="set24" tabindex="0"><el-kw>set </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="for27" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
  <el-statement class="ok multiline" id="if33" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>] &gt; <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
  <el-statement class="ok" id="let36" tabindex="0"><el-kw>let </el-kw><el-field id="var37" class="ok" tabindex="0"><el-txt><el-id>temp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call39" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>put</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args41" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id>, <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="call42" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident43" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>put</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args44" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id> + <el-lit>1</el-lit>, <el-id>temp</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="set45" tabindex="0"><el-kw>set </el-kw><el-field id="ident46" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr47" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end if</el-kw>
  </el-statement>
  <el-kw>end for</el-kw>
  </el-statement>
  <el-statement class="ok" id="set48" tabindex="0"><el-kw>set </el-kw><el-field id="ident49" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr50" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id> - <el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end repeat when </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>changes</el-id></el-txt><el-place><i>condition</i></el-place></el-field>
  </el-statement>
  <el-kw>end procedure</el-kw>
  </el-proc>
</el-code-block>
<p>Procedures are executed by means of a <a href="#call">call</a> statement, for example:</p>
<el-code-block source="sort.elan">
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<div id="return"></div>
<div id="returns"></div>
<h2 id="function">Function</h2>
<p>A <el-code>function</el-code> is a named piece of code that can define <b>parameters</b> which are given inputs via <b>arguments</b> when reference to the function occurs in a statement or expression.</p>
<p>Unlike a <a href="#procedure">procedure</a>, a function returns a value. Also unlike a procedure, a function can have no 'side effects' and cannot depend on any <a href="LibRef.html#SystemMethods">System methods</a>.</p>
<p>The <el-kw>return</el-kw> statement is followed by the value returned by the function.</p>
<p>Example of a function:</p>
<el-code-block source="score.elan">
<el-func class="ok multiline" id="func91" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident93" class="ok" tabindex="0"><el-txt>score</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params94" class="optional ok" tabindex="0"><el-txt><el-id>g</el-id> <el-kw>as</el-kw> <el-type>Game</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type95" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return96" tabindex="0"><el-kw>return </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>g</el-id>.<el-id>body</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<div id="as"></div>
<h2 id="Parameters">Parameters</h2>
Parameters for both <el-code>procedures</el-code> and <el-code>functions</el-code> are defined in exactly the same way: each parameter definition takes the form:
<br>&nbsp;&nbsp;&lt;name&gt; <el-code>as</el-code> &lt;Type&gt;
<br> for example:
<el-code-block source="ageAsInt.elan">
<el-field id="params50" class="optional ok" tabindex="0"><el-txt><el-id>age</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>
</el-code-block>

<h2 id="recursion">Recursion</h2>
Procedures and functions may be called or referenced recursively. For example, a simple factorial calculation:
<el-code-block source="factorial.elan">
<el-func class="ok multiline" id="func1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident3" class="ok" tabindex="0"><el-txt>factorial</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params4" class="optional ok" tabindex="0"><el-txt><el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type5" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return6" tabindex="0"><el-kw>return </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt>(<el-kw>if </el-kw><el-id>n</el-id> &gt; <el-lit>1</el-lit><el-kw> then </el-kw><el-id>n</el-id>*<el-method>factorial</el-method>(<el-id>n</el-id> - <el-lit>1</el-lit>)<el-kw><br>else </el-kw><el-lit>1</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h2 id="test">Tests</h2>
<p>A <el-code>test</el-code> is a set of assertions, at the global level, about the output of functions. Example of a <el-code>test</el-code>:</p>

<el-code-block source="test_search.elan">
<el-test class="ok multiline" id="test74" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment76" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>li1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>lime</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert80" tabindex="0"><el-kw>assert </el-kw><el-field id="text81" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert83" tabindex="0"><el-kw>assert </el-kw><el-field id="text84" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let92" tabindex="0"><el-kw>let </el-kw><el-field id="var93" class="ok" tabindex="0"><el-txt><el-id>li2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr94" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert95" tabindex="0"><el-kw>assert </el-kw><el-field id="text96" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert98" tabindex="0"><el-kw>assert </el-kw><el-field id="text99" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr100" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert101" tabindex="0"><el-kw>assert </el-kw><el-field id="text102" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr103" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let104" tabindex="0"><el-kw>let </el-kw><el-field id="var105" class="ok" tabindex="0"><el-txt><el-id>li3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr106" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert107" tabindex="0"><el-kw>assert </el-kw><el-field id="text108" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr109" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert110" tabindex="0"><el-kw>assert </el-kw><el-field id="text111" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr112" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let113" tabindex="0"><el-kw>let </el-kw><el-field id="var114" class="ok" tabindex="0"><el-txt><el-id>li4</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr115" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert116" tabindex="0"><el-kw>assert </el-kw><el-field id="text117" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li4</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr118" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>Elan tests are designed to test functions only. It is not possible to call a <el-code>procedure</el-code> or <el-code>main</el-code> routine within a test. Nor is it possible to use any <a href="LibRef.html#SystemMethods">System method</a> (the same rule as for a function).</li>
 <li>A test may optionally be given a name or description in free-form text, just like a comment, which plays no role in the execution of the test. You might give the test the same name as a function that it is testing, or you might describe a particular scenario that is being tested.</li>
 <li><el-code>test</el-code> methods may be written anywhere in the code, provided they are at the global level. </li>
 <li>A <el-code>test</el-code> method may contain any number of <el-code>assert</el-code> statements. When tests are run, the test runner (which is part of the IDE), will attempt to run all <el-code>assert</el-code> statements and show each one's pass or fail outcome alongside. However, if the test hits a runtime error (as distinct from an <el-code>assert</el-code> failure) then execution of the test will stop and remaining <el-code>assert</el-code>s will be shown as 'not run'.</li>
 <li>In addition to <el-code>assert</el-code> statements, a <el-code>test</el-code> may contain any other statements that may be added into a <el-code>function</el-code> (except <el-code>return</el-code>).</li>
 <li>All <el-code>assert</el-code> statements should be at the top level within the <el-code>test</el-code> frame; none may be put into a loop structure.</li>
</ul>

<h4 class="no-TOC">Testing Float values</h4>
<p>When testing <el-code>Float</el-code> values it is recommend that you always use the <el-code>round</el-code> function to round the computed result to a fixed number of decimal places. This avoids rounding errors and is easier to read. For example:</p>

<el-code-block source="test_round.elan">
<el-test class="ok multiline" id="test3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment5" class="optional ok" tabindex="0"><el-txt>round()</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="assert14" tabindex="0"><el-kw>assert </el-kw><el-field id="text15" class="ok" tabindex="0"><el-txt><el-method>sqrt</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.414</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h4 class="no-TOC">Testing for runtime errors</h4>
<p>If the expression you are testing causes a runtime error then the error will be displayed in the red fail message:</p>
<el-code-block source="test_runtime.elan">
<el-test class="error multiline" id="test1" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="-1"><el-txt>&nbsp;</el-txt></el-field></el-top>
<el-statement class="ok" id="let4" tabindex="-1"><el-kw>let </el-kw><el-field id="var5" class="ok" tabindex="-1"><el-txt><el-id>a</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr6" class="ok" tabindex="-1"><el-txt>[<el-lit>5</el-lit>, <el-lit>1</el-lit>, <el-lit>7</el-lit>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="assert7" tabindex="-1"><el-kw>assert </el-kw><el-field id="text8" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>0</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr9" class="ok" tabindex="-1"><el-txt><el-lit>5</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert10" tabindex="-1"><el-kw>assert </el-kw><el-field id="text11" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>2</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr12" class="ok" tabindex="-1"><el-txt><el-lit>7</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert13" tabindex="-1"><el-kw>assert </el-kw><el-field id="text14" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>4</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr15" class="ok" tabindex="-1"><el-txt><el-lit>0</el-lit></el-txt></el-field> <el-msg class="error">actual (computed): Out of range index: 4 size: 3</el-msg></el-statement>
<el-statement class="ok" id="assert17" tabindex="-1"><el-kw>assert </el-kw><el-field id="text18" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>4</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr19" class="ok" tabindex="-1"><el-txt>"<el-lit>Out of range index: 4 size: 3</el-lit>"</el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test></el-code-block>

<p>If this occurs, mark the tests that you added since the last successful test run with <el-code>ignore</el-code> (see below), and then remove their ignore status one by one until the cause is identified and fixed.</p>
<p>In the last <el-kw>assert</el-kw>, note how testing can also be done agains an expected error message.</p>

<h4 class="no-TOC" id="ignore">Marking a test with <el-kw>ignore</el-kw></h4>
<p>It is possible to mark a <el-code>test</el-code> with the <el-code>ignore</el-code> keyword, by selecting the <el-code>test</el-code> frame and then hitting Ctrl-i, as in this example:</p>

<el-code-block source="test_ignore.elan">
<el-test class="warning multiline" id="test213" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>ignore test </el-kw><el-field id="comment215" class="optional ok" tabindex="0"><el-txt>clockTick</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let216" tabindex="0"><el-kw>let </el-kw><el-field id="var217" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr218" class="ok" tabindex="0"><el-txt><el-method>newGame</el-method>(<el-kw>new</el-kw> <el-type>Random</el-type>())</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let219" tabindex="0"><el-kw>let </el-kw><el-field id="var220" class="ok" tabindex="0"><el-txt><el-id>g2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr221" class="ok" tabindex="0"><el-txt><el-method>newApple</el-method>(<el-id>g1</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let222" tabindex="0"><el-kw>let </el-kw><el-field id="var223" class="ok" tabindex="0"><el-txt><el-id>g3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr224" class="ok" tabindex="0"><el-txt><el-method>clockTick</el-method>(<el-id>g2</el-id>, "<el-lit>s</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert225" tabindex="0"><el-kw>assert </el-kw><el-field id="text226" class="ok" tabindex="0"><el-txt><el-id>g3</el-id>.<el-id>head</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr227" class="ok" tabindex="0"><el-txt><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>16</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="warning">not run</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<div id="TestIgnore"></div>
<p>When a test is marked with <el-code>ignore</el-code>, that test will not be executed when the tests are run, and its result will be shown as 'not run'. The overall test status will also show in the 'warning' status (amber colour), even if all the tests that did run passed. This is to discourage you from leaving a test marked <el-code>ignore</el-code> for long.</p>
<p>The principal reason for marking a test <el-code>ignore</el-code> is when either the test code, or code in any function being called, does not terminate. This typically means that there is a loop (or a recursive call) with no exit condition, or where the exit condition is never met.</p>
<p>If you do create such code without realising it, then when the tests are executed the test runner will 'time out' after a few seconds (most tests will pass in milliseconds), and an error message will be shown in the Info pane. The test that caused the timeout will automatically then be marked <el-code>ignore</el-code>. Your priority should then be to identify the cause of the timeout and attempt to fix it before then restoring the <el-code>test</el-code> by selecting its frame and hitting <el-code>Ctrl-i</el-code> (which is a toggle for setting and unsetting an <el-code>ignore</el-code> status).</p>

<h2 id="constant">Constant</h2>
<p>A <el-code>constant</el-code> defines a named value that cannot change, is always defined at global level (directly within a file), and is global in scope.</p>
<p>A constant is created at compile time, so cannot be defined with reference to any function, nor use any operators.</p>
<p>A constant can be defined as a literal <el-type>Int</el-type>, <el-type>Float</el-type>, <el-type>Boolean</el-type>,
 <el-type>String</el-type>, <el-type>ListImmutable</el-type> or <el-type>DictionaryImmutable</el-type>.</p>
<p>A constant may not be defined within any method, but see the description of the <a href="#let"><el-kw>let</el-kw></a> statement.</p>
<p>The name of a <el-code>constant</el-code> follows the rules for an <a href="#Identifier">Identifier</a>.</p>

<p>Some examples:</p>
<el-code-block source="constants_enum.elan">
<el-const class="ok multiline" id="const5" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-id>phi</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text7" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.618</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const16" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>maxHits</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text18" class="ok" tabindex="0"><el-txt><el-lit>10</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const23" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident24" class="ok" tabindex="0"><el-txt><el-id>warningMsg</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text25" class="ok" tabindex="0"><el-txt>"<el-lit>Limit reached</el-lit>"</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const30" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident31" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text32" class="ok" tabindex="0"><el-txt>{"<el-lit>apple</el-lit>", "<el-lit>orange</el-lit>", "<el-lit>banana</el-lit>"}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const39" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>black</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text41" class="ok" tabindex="0"><el-txt><el-lit>0x000000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const46" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident47" class="ok" tabindex="0"><el-txt><el-id>red</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text48" class="ok" tabindex="0"><el-txt><el-lit>0xff0000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const75" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident76" class="ok" tabindex="0"><el-txt><el-id>colours</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text77" class="ok" tabindex="0"><el-txt>{<el-type>Suit</el-type>.<el-id>spades</el-id>:<el-id>black</el-id>, <el-type>Suit</el-type>.<el-id>hearts</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>diamonds</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>clubs</el-id>:<el-id>black</el-id>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const65" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident66" class="ok" tabindex="0"><el-txt><el-id>scrabbleValues</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text67" class="ok" tabindex="0"><el-txt>{"<el-lit>A</el-lit>":<el-lit>1</el-lit>, "<el-lit>B</el-lit>":<el-lit>3</el-lit>, "<el-lit>C</el-lit>":<el-lit>3</el-lit>, "<el-lit>D</el-lit>":<el-lit>2</el-lit>, "<el-lit>E</el-lit>":<el-lit>1</el-lit>, "<el-lit>F</el-lit>":<el-lit>4</el-lit>, "<el-lit>G</el-lit>":<el-lit>2</el-lit>, "<el-lit>H</el-lit>":<el-lit>4</el-lit>, "<el-lit>I</el-lit>":<el-lit>1</el-lit>, "<el-lit>J</el-lit>":<el-lit>8</el-lit>, "<el-lit>K</el-lit>":<el-lit>5</el-lit>, "<el-lit>L</el-lit>":<el-lit>1</el-lit>, "<el-lit>M</el-lit>":<el-lit>3</el-lit>, "<el-lit>N</el-lit>":<el-lit>1</el-lit>, "<el-lit>O</el-lit>":<el-lit>1</el-lit>, "<el-lit>P</el-lit>":<el-lit>3</el-lit>, "<el-lit>Q</el-lit>":<el-lit>10</el-lit>, "<el-lit>R</el-lit>":<el-lit>1</el-lit>, "<el-lit>S</el-lit>":<el-lit>1</el-lit>, "<el-lit>T</el-lit>":<el-lit>1</el-lit>, "<el-lit>U</el-lit>":<el-lit>1</el-lit>, "<el-lit>V</el-lit>":<el-lit>4</el-lit>, "<el-lit>W</el-lit>":<el-lit>4</el-lit>, "<el-lit>X</el-lit>":<el-lit>8</el-lit>, "<el-lit>Y</el-lit>":<el-lit>4</el-lit>, "<el-lit>Z</el-lit>":<el-lit>10</el-lit>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
</el-code-block>
<p>In the <el-id>colours</el-id> example, <el-code>Suit</el-code> is an <a href="#enum">Enum</a>.</p>

<h2 id="enum">Enum</h2>
<p>An <el-code>enum</el-code> &ndash; short for 'enumeration' &ndash; is the simplest form of 'user-defined Type'.
It specifies a set of values, each of which is defined as a name, such that a named value of Type <el-code>enum</el-code> necessarily always holds one of those values.</p>
<p><el-code>enum</el-code>s are read-only: once they have been defined it is not possible to add, remove, or update their values.</p>

<p>Some examples:</p>
<el-code-block source="constants_enum.elan">
<el-enum class="ok multiline" id="enum120" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type121" class="ok" tabindex="0"><el-txt><el-type>Suit</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals122" class="ok" tabindex="0"><el-txt><el-id>spades</el-id>, <el-id>hearts</el-id>, <el-id>diamonds</el-id>, <el-id>clubs</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum137" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type138" class="ok" tabindex="0"><el-txt><el-type>Action</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals139" class="ok" tabindex="0"><el-txt><el-id>stand</el-id>, <el-id>draw</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum140" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type141" class="ok" tabindex="0"><el-txt><el-type>Outcome</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals142" class="ok" tabindex="0"><el-txt><el-id>undecided</el-id>, <el-id>win</el-id>, <el-id>lose</el-id>, <el-id>draw</el-id>, <el-id>winDouble</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type144" class="ok" tabindex="0"><el-txt><el-type>Status</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals145" class="ok" tabindex="0"><el-txt><el-id>pending</el-id>, <el-id>playing</el-id>, <el-id>standing</el-id>, <el-id>blackjack</el-id>, <el-id>bust</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
</el-code-block>

<h3 class="no-TOC">Type name</h3>
<p>The name given to an <el-code>enum</el-code> (see below), which must begin with an upper case letter, is used as the Type name when passing a value to or from a procedure or function. </p>

<h3 class="no-TOC">Using an enum</h3>
The value is specified by the Type name for the specified <el-code>enum</el-code>, followed by a dot and the value name, for example:

<el-code-block source="enum_status.elan">
<el-statement class="ok" id="var69" tabindex="0"><el-kw>variable </el-kw><el-field id="var70" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr71" class="ok" tabindex="0"><el-txt><el-type>Status</el-type>.<el-id>pending</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h2 id="record">Record</h2>

<p>A <el-code>record</el-code> is a user-defined data structure that is given a Type name (which must begin with an upper case letter).
  The <el-code>record</el-code> defines one or more properties, each of which has a name (starting with a lower case letter) and a Type.
  The Type of a property may be any simple value Type, or a <el-code>ListImmutable</el-code>, or another Type of <el-code>record</el-code> ( or even the same Type of <el-code>record</el-code>).</p>
  <p>Note that a <el-code>record</el-code> has some similarity to a <a href="#class"><el-code>class</el-code></a> in that:</p>
<ul>
  <li>Both are user-defined data structures</li>
  <li>Both are given a 'Type name'</li>
  <li>Both may define one or more properties, each with a name and Type</li>
  <li>Both may be created or copied using a <el-kw>with</el-kw> clause</li>
  <li>Both may define encapsulated methods</li>
</ul>
<p>However a <el-code>record</el-code> differs  from a <el-code>class</el-code> in that:</p>
 <ul>
  <li>A <el-code>record</el-code> is immutable (like a <el-code>ListImmutable</el-code> or a <el-code>String</el-code>). You can create a copy with specified differences but you cannot modify a <el-code>property</el-code> on a given instance.</li>
  <li>A <el-code>record</el-code> does not define a constructor</li>
  <li>A <el-code>record</el-code> may define only <i>function</i> methods, since <i>procedure</i> methods would imply the ability to <i>mutate</i> the record.</li>
</ul>
Examples:
<el-code-block source="record_Square.elan">
<el-class class="ok multiline" id="class203" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type204" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop207" tabindex="0"><el-kw>property </el-kw><el-field id="ident208" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type209" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop210" tabindex="0"><el-kw>property </el-kw><el-field id="ident211" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type212" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
<el-code-block source="record_Game.elan">
<el-class class="ok multiline" id="class168" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type169" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop172" tabindex="0"><el-kw>property </el-kw><el-field id="ident173" class="ok" tabindex="0"><el-txt><el-id>head</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type174" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop175" tabindex="0"><el-kw>property </el-kw><el-field id="ident176" class="ok" tabindex="0"><el-txt><el-id>body</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type177" class="ok" tabindex="0"><el-txt><el-type>ListImmutable</el-type>&lt;<el-kw>of</el-kw> <el-type>Square</el-type>&gt;</el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop178" tabindex="0"><el-kw>property </el-kw><el-field id="ident179" class="ok" tabindex="0"><el-txt><el-id>priorTail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type180" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop181" tabindex="0"><el-kw>property </el-kw><el-field id="ident182" class="ok" tabindex="0"><el-txt><el-id>apple</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type183" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop184" tabindex="0"><el-kw>property </el-kw><el-field id="ident185" class="ok" tabindex="0"><el-txt><el-id>isOn</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type186" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop187" tabindex="0"><el-kw>property </el-kw><el-field id="ident188" class="ok" tabindex="0"><el-txt><el-id>rnd</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type189" class="ok" tabindex="0"><el-txt><el-type>Random</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop190" tabindex="0"><el-kw>property </el-kw><el-field id="ident191" class="ok" tabindex="0"><el-txt><el-id>graphics</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type192" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop193" tabindex="0"><el-kw>property </el-kw><el-field id="ident194" class="ok" tabindex="0"><el-txt><el-id>key</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type195" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
Having defined a record's Type, such as <el-code>Game</el-code> above, you can create as many instances as you wish using the following syntax to specify the values:
<el-code-block source="newGame from snake_FP.elan">
<el-statement class="ok" id="let603" tabindex="0"><el-kw>let </el-kw><el-field id="var604" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr605" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Game</el-type>()<el-kw> with </el-kw><br><el-id>head</el-id><el-kw> set to </el-kw><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>15</el-lit>), <br><el-id>key</el-id><el-kw> set to </el-kw>"<el-lit>d</el-lit>", <br><el-id>isOn</el-id><el-kw> set to </el-kw><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<p>Note that you are not <em>required</em> to provide a value for each property because, where a property is not specified in the <el-kw>with</el-kw> clause (as above), that property will be given the empty (default) value of the correct Type.</p>
<p>You can then read the values from the properties using 'dot syntax' for example:</p>
<el-code-block source=""><el-statement class="" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional" tabindex="0"><el-txt><el-id>sq</el-id>.<el-id>size</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p><el-code>record</el-code> Types are immutable: the properties on an instance may not be changed, directly.
  However, you can easily create another instance that is a copy of the original,
  with all the same property values except for any specific changes made in another <el-kw>with</el-kw> clause.
  The newly-minted copy (with changes) must be assigned to a new named value. For example:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>sq1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit>, <br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>1</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="error"></el-msg></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>2</el-lit>.0</el-lit>, <br><el-id>colour</el-id><el-kw> set to </el-kw><el-id>red</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p>Or even to the same name if that name is a <el-kw>variable</el-kw>:</p>
<el-code-block>
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="ok" id="set6" tabindex="0"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>a</el-id><el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>This last example shows how you enter the comma-separated <el-kw>with</el-kw> clauses. The earlier examples show how the Editor displays a set of <el-kw>with</el-kw> clauses.</p>

<p>If you want to use one or more existing property values in order to determine a new value, the property names must be prefixed with the name of the instance being copied, for example:</p>
<el-code-block>
  <el-statement class="" id="let9" tabindex="0"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr11" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-id>sq1</el-id>.<el-id>size</el-id> + <el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class=""></el-msg></el-statement>
</el-code-block>

<h4 class="no-TOC" id="record_deconstruction">Record deconstruction</h4>
<p>A record may be 'deconstructed', meaning that its properties are read into separate <el-kw>variable</el-kw>s using the same syntax as for deconstructing a <span class="Link">Tuple</span>. For example, assuming that Square is a record defined as in the example above, then this code:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>y</el-id>, <el-id>size</el-id>, <el-id>colour</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-id>mySquare</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p>will read the <el-code>properties</el-code> into the four names defined.</p>
When deconstructing, the names of the values must match the names of the <el-code>properties</el-code> of the <el-code>record</el-code>. However, the ordering of the names does not have to match the order in which the <el-code>properties</el-code> are defined in the <el-kw>record</el-kw>.

<h2 id="class">Class</h2>
<!-- TODO Subclass and Superclass -->
<div id="Subclass"></div>
<div id="Superclass"></div>
<p>See also: <a href="#Inheritance">Inheritance</a></p>

<p>A <el-code>class</el-code> is a user-defined Type offering far richer capability than an <el-code>enum</el-code>. </p>
<p>Note that a <el-code>record</el-code> is in some ways similar to a <el-code>class</el-code> but simpler: it defines properties, but has no constructor and no methods. See <a href="#record">Working with records</a>.</p>

<h4 class="no-TOC">Definition</h4>
<p>Here is an example of <el-code>class</el-code> definition, taken from demo program <el-code>snake_OOP.elan</el-code>:</p>
<el-code-block source="class_Apple.elan">
<el-class class="ok multiline" id="class177" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>class </el-kw><el-field id="type178" class="ok" tabindex="0"><el-txt><el-type>Apple</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text179" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>inherits ClassName(s)</i></el-place></el-field></el-top>
<el-prop class="ok" id="prop181" tabindex="0"><el-kw>property </el-kw><el-field id="ident182" class="ok" tabindex="0"><el-txt><el-id>location</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type183" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-proc class="ok multiline" id="proc184" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident186" class="ok" tabindex="0"><el-txt>newRandomPosition</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params187" class="optional ok" tabindex="0"><el-txt><el-id>snake</el-id> <el-kw>as</el-kw> <el-type>Snake</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
<el-statement class="ok multiline" id="repeat188" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
<el-statement class="ok" id="let191" tabindex="0"><el-kw>let </el-kw><el-field id="var192" class="ok" tabindex="0"><el-txt><el-id>ranX</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr193" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let194" tabindex="0"><el-kw>let </el-kw><el-field id="var195" class="ok" tabindex="0"><el-txt><el-id>ranY</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr196" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set197" tabindex="0"><el-kw>set </el-kw><el-field id="ident198" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr199" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-id>ranX</el-id>, <el-id>ranY</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end repeat when </el-kw><el-field id="expr190" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>snake</el-id>.<el-method>bodyCovers</el-method>(<el-kw>property</el-kw>.<el-id>location</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field>
</el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-func class="ok multiline" id="func200" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident202" class="ok" tabindex="0"><el-txt>updateGraphics</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params203" class="optional ok" tabindex="0"><el-txt><el-id>gr</el-id> <el-kw>as</el-kw> <el-type>BlockGraphics</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type204" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return205" tabindex="0"><el-kw>return </el-kw><el-field id="expr206" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id>.<el-method>updateGraphics</el-method>(<el-id>gr</el-id>, <el-id>red</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
<el-kw>end class</el-kw>
</el-class>
</el-code-block>
<p>A <el-code>class</el-code> must have a name that, like any other Type, begins with an upper case letter.</p>
<p>A class may define:</p>
<ul>
<li>One or more properties &ndash; see <a href="#property">Property</a></li>
<li><el-code>function</el-code> methods &ndash; see <span class="Link">Function method</span></li>
<li><el-code>procedure</el-code> methods &ndash; see <span class="Link">Procedure method</span></li>
<li>a <el-code>constructor</el-code> which may be used for setting up the values of properties. The <el-code>constructor</el-code> may optionally define parameters to force the calling code to provide initial values. However, it is not necessary to add a <el-code>constructor</el-code> if you have no need to initialise properties. Code in the constructor may make use of any functions, and follows the same constraints as a <el-code>function</el-code> (i.e. it may not call any <el-code>procedure</el-code>, whether defined on the <el-code>class</el-code> or outside).</li>
</ul>

<h3 class="no-TOC">Using a class</h3>
<p>A <el-code>class</el-code> is instantiated using the keyword <el-code>new</el-code> followed by the class name and brackets, which should enclose the comma-separated arguments required to match the parameters (if any) defined on the constructor for that <el-code>class</el-code>. For example (also from demo program <el-code>snake_OOP.elan</el-code>):</p>

<el-code-block source="constructor.elan">
<el-constructor class="ok multiline" id="constructor41" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params43" class="empty optional ok" tabindex="0"><el-compl><i>parameter definitions</i></el-compl></el-field>)</el-top>
<el-statement class="ok" id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="set47" tabindex="0"><el-kw>set </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>currentDir</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-type>Direction</el-type>.<el-id>right</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="set50" tabindex="0"><el-kw>set </el-kw><el-field id="ident51" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>body</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr52" class="ok" tabindex="0"><el-txt>[<el-id>tail</el-id>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="set53" tabindex="0"><el-kw>set </el-kw><el-field id="ident54" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>head</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-id>tail</el-id>.<el-method>getAdjacentSquare</el-method>(<el-kw>property</el-kw>.<el-id>currentDir</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="set56" tabindex="0"><el-kw>set </el-kw><el-field id="ident57" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>priorTail</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr58" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt></el-field></el-statement>
<el-kw>end constructor</el-kw></el-constructor>
</el-code-block>
<p>The created instance may then be used within expressions, like any other named value.</p>

<h3 class="no-TOC" id="this">Using keyword <el-kw>this</el-kw></h3>
If in the code of class <el-type>A</el-type> you want to invoke a method in class <el-type>S</el-type> <i>and</i> pass to it the current instance of <el-type>A</el-type>,
you can refer to this instance with the keyword <el-kw>this</el-kw>, as shown by this line in demo program <el-code>snake_OOP.elan</el-code>:</p>

<el-code=block source="snake_OOP.elan">
<el-top><el-kw>call </el-kw><el-field id="ident91" class="ok" tabindex="-1"><el-txt><el-id>apple</el-id>.<el-method><el-method>newRandomPosition</el-method></el-method></el-txt></el-field>(<el-field id="args92" class="optional ok" tabindex="-1"><el-txt><el-kw>this</el-kw></el-txt></el-field>)</el-top>
</el-code-block>

<p>Here, method <el-method>newRandomPosition</el-method> is defined on class <el-type>Apple</el-type> which needs to be passed an instance of class <el-type>Snake</el-type>.
(<el-id>apple</el-id> is an instance of class <el-type>Apple</el-type>).</p>

<h3 class="no-TOC" id="Inheritance">Inheritance</h3>
  <p>An ordinary <a href="#class">class</a> (also known as a 'concrete class') may optionally inherit from just one <a href="#abstractclass"><el-code>abstract class</el-code></a>
    but may additionally inherit from any number of <a href="#interface">interfaces</a>.
    The concrete class must define for itself a concrete implementation of every <em>abstract</em> member defined in the <el-code>abstract class</el-code> or any <el-code>interface</el-code>s that it inherits from, directly or indirectly.</p>

<h4 class="no-TOC">Notes</h4>
<ul>
  <li>An <el-code>abstract class</el-code> must be declared in the code above any class that inherits from it. This is the only case where the order of definition (of global constructs) matters.</li>
  <li>The <el-code>abstract class</el-code> (if any) and the interfaces (if any) that a concrete <el-code>class</el-code> inherits from may not contain duplicates of any <el-code>abstract</el-code> member. Any duplicated definitions in the hierarchy will result in a compile error. If such duplications arise, you should factor out the common member definitions, and move them up the hierarchy or into new <el-code>interface</el-code>s inherited by the<el-code> interface</el-code>s and/or classes that need them.</li>
  <li>Inheritance hierarchies must form a tree, that is you must avoid creating a 'circular' dependency where, for example, Type <el-code>A</el-code> inherits from Type <el-code>B</el-code>, which inherits from Type <el-code> C</el-code>, which inherits from Type <el-code>A</el-code>.</li>
  <li>The various 'super-Types' (abstract classes and <el-code>interface</el-code>s) that a concrete <el-code>class</el-code> inherits from must not define conflicting members, e.g. members with the same name but having different Type signatures.</li>
</ul>

<h2 id="abstractclass">Abstract class</h2>
<p>See also: <a href="#Inheritance">Inheritance</a></p>
<p>An <el-code>abstract class</el-code> may not be instantiated (and hence may not define a constructor). It may define concrete members i.e.:</p>
<ul>
<li>a <el-kw>property</el-kw> </li>
<li>a <el-code>function</el-code></li>
<li>a <el-code>procedure</el-code></li>
</ul>
<p>As with a concrete class, any of these members may be made <el-code>private</el-code>, after the corresponding frame has been added, by selecting that member frame and pressing Ctrl-p.</p>
<p>These concrete members are automatically inherited by any subclass, but they may not be overridden (re-defined) by the subclass. Therefore you should define concrete members only if they are intended to work identically on every subclass.</p>

<p id="abstractfunction">
<span id="abstractprocedure"></span>
You may also define abstract methods on an <el-code>abstract class</el-code>, i.e. <el-code>abstract property</el-code>, <el-code>abstract function</el-code>, <el-code>abstract procedure</el-code>. Such methods define only the signature of the method, not the implementation (body), therefore they have no <el-code>end</el-code> statement. For example:</p>
<p><el-code>abstract function calculateDiscount() as Float</el-code></p>
<p>
If you wish to have several subclasses of an <el-code>abstract class</el-code> that share a common implementation for a method, but require that some of the subclasses can define a different implementation, then you should:</p>
<ul>
<li>Define the method as <el-code>abstract</el-code> on the superclass.</li>
<li>Define a concrete implementation on the superclass with a similar, but slightly different, name e.g. by adding a prefix such as: <el-code>default</el-code>.</li>
<li>Each subclass must then define its implementation of the abstract method, but the ones needing a common implementation can be just one line, delegating responsibility up to the 'default' method on the superclass. </li>
</ul>

<h2 id="interface">Interface</h2>
<p>See also: <a href="#Inheritance">Inheritance</a></p>
<p>An <el-code>interface</el-code> is similar to an <el-code>abstract class</el-code>, with the difference that it may define only abstract members. The advantage of using an <el-code>interface</el-code> instead of an <el-code>abstract class</el-code> is that a concrete<el-code> class</el-code> can inherit from multiple <el-code>interface</el-code>s.</p>
<p>An <el-code>interface</el-code> may inherit only from other <el-code>interface</el-code>s.</p>
<p>Important: An <el-code>interface</el-code> must not re-declare abstract interfaces that are defined in any <el-code>interface</el-code> it inherits from, directly or indirectly.</p>

<div id="Member"></div>
<h1 id="MemberInstructions">Member instructions</h1>
<p>
 <a href="#constructor">constructor</a>,
 <a href="#property">property</a>,
 <a href="#procedure_method">procedure</a>,
 <a href="#function_method">function</a>,
 <a href="#abstractproperty">abstract property</a>,
 <a href="#abstractprocedure">abstract procedure</a>,
 <a href="#abstractfunction">abstract function</a>,
 <a href="#property">private property</a>,
 <a href="#procedure_method">private procedure</a>,
 <a href="#function_method">private function</a>
</p>
<p>Member instructions (also sometimes referred to simply as 'members')
  are located within a <el-kw>class</el-kw>, <el-kw>abstract class</el-kw>, <el-kw>interface</el-kw>, or <el-code>record</el-code>.
  A different subset of the total list above will be offered in the four different contexts.</p>

<h2 id="constructor">Constructor</h2>
<p>A concrete class <em>may</em> define a single <el-code>constructor</el-code>, which may:</p>
<ul>
<li>initialise any properties with fixed values</li>
<li>define one or more parameters, which are then used to initialise properties</li>
</ul>
<p>If a class does define a constructor, and the constructor defines any parameters, then when the class is instantiated (using <el-code>new</el-code>) then values of
the correct types must be provided, for example, if the class <el-type>Square</el-type> defines this constructor:</p>

<el-code-block>
  <el-constructor class="ok multiline" id="constructor211" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params213" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
    <el-statement class="ok" id="set214" tabindex="0"><el-kw>set </el-kw><el-field id="ident215" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>x</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr216" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="set217" tabindex="0"><el-kw>set </el-kw><el-field id="ident218" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>y</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr219" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-kw>end constructor</el-kw>
  </el-constructor>
</el-code-block>

<p>then it may be instantiated like this:</p>

<el-code>
<el-statement id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>

<h2 id="property">Property</h2>
<p>Examples:</p>
<el-code>property height as Int</el-code><br>
<el-code>property board as Board</el-code><br>
<el-code>property head as Square</el-code><br>
<el-code>property body as [Square]</el-code><br>
<ul>
<li>A <el-kw>property</el-kw> is defined on a <span class="Link">Class</span> and must <el-code>specify</el-code> a name (conforming to the rules for an <a href="#Identifier">Identifier</a>) and a Type.</li>
<li>A <el-kw>property</el-kw> may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>If not marked <el-code>private</el-code>, a property may be read but not be written to. Properties may only be modified from outside the class by means of a <span class="Link">Procedure method</span>.</li>
<li>A property may be given an initial value in the <el-code>constructor</el-code>.</li>
</ul>
<p>
If the <el-kw>property</el-kw> is not initialised within the constructor then it will automatically be given the <el-code>empty</el-code> value for that Type. You may test whether a property contains this default value by writing e.g.:<br>
<el-code>if head is empty Square</el-code></p>
<ul>
<li>Whenever you wish to access a property from within a method (or from within the constructor) on the same class, then the name of the property must be prefixed with the 'qualifier': <el-code>property. </el-code>('property-dot'). This applies whether you are reading or setting the property. By this means you can have a method parameter with the same name as a property, but they are unambiguous, because the property must be prefixed. A common pattern is to use the same name in a 'setter' method, for example:</li>
</ul>
<el-code>constructor(board as Board)</el-code><br>
<el-code>  set property.board to board</el-code><br>
<el-code>end constructor</el-code><br>
<br>
<el-code>procedure setHeight(height as Int)</el-code><br>
<el-code>  set property.height to height</el-code><br>
<el-code>end procedure</el-code><br>

<h2 id="procedure_method">Procedure Method</h2>
<p>A 'procedure method' follows the same syntax and rules as a global <a href="#procedure">procedure</a>. The differences are:</p>
<ul>
<li>A procedure method, like a function method, is always referenced (used) by code outside the class using 'dot syntax' on an instance.</li>
<li>A procedure method may read, or write to, any <el-kw>property</el-kw> defined on the class.</li>
<li>A procedure method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
</ul>

<div id="FunctionMethod"></div>
<h2 id="function_method">Function Method</h2>
<p>A function method follows the same syntax and rules as a global <a href="#function">function</a>. The differences are:</p>
<ul>
<li>A <el-code>function</el-code> method is always referenced (used) by code outside the class using 'dot syntax' on an instance.</li>
<li>A <el-code>function</el-code> method may directly reference (read only) any <el-kw>property</el-kw> defined on the class as though it were a variable or parameter.</li>
<li>A <el-code>function</el-code> method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>asString() method</li>
<li>asString method. This is just a regular function method with a specific name, no parameters and returning a String. If defined for a class, then if an instance of the class is printed, the <el-code>asString</el-code> function method will automatically be used. Typically <el-code>asString</el-code> will return a string made up of one or more of the property values, perhaps with additional text, or the results of function calls.</li>
</ul>

<h2 id="abstractproperty">Abstract Property</h2>
<p>An abstract property may be defined only on an <a href="#abstractclass"><el-code>abstract class</el-code></a>. Any concrete subclass must then implement a concrete (regular) property to match.</p>

<h2 id="AbstractProcedureMethod">Abstract Procedure Method</h2>
<p>An abstract procedure method may be defined only on an <a href="#abstractclass"><el-code>abstract class</el-code></a>. Any concrete subclass must then implement a concrete (regular) procedure to match.</p>

<h2 id="abstractFunctionMethod">Abstract Function Method</h2>
<p>An abstract function method may be defined only on an <a href="#abstractclass"><el-code>abstract class</el-code></a>. Any concrete subclass must then implement a concrete (regular) function to match.</p>

<div id="statement"></div>
<h1 id="StatementInstructions">Statement instructions</h1>
<p>
 <a href="#assert">assert</a>,
 <a href="#call">call</a>,
 <a href="#each">each</a>,
 <a href="#else">else</a>,
 <a href="#for">for</a>,
 <a href="#if">if</a>,
 <a href="#let">let</a>,
 <a href="#print">print</a>,
 <a href="#repeat">repeat</a>,
 <a href="#set">set</a>,
 <a href="#throw">throw</a>,
 <a href="#try">try</a>,
 <a href="#variable">variable</a>,
 <a href="#while">while</a>
</p>
<p>Statement instructions (also sometimes referred to simply as 'statements')
  are located within 'methods'. Some of these statements may contain other statements.</p>

<h2 id="assert">Assert statement</h2>
<p>See <a href="#test">Tests</a> for the use of the <el-kw>assert</el-kw> statement.</p>
<p>Some other programming languages have a feature for making assertions
while your program is running. In Elan, you can get equivalent functionality
by <a href="#throw">throwing an exception</a> like this:</p>
<el-statement class="ok multiline" id="if601" tabindex="0">
<el-top><el-kw>if </el-kw><el-field id="expr603" class="ok" tabindex="0"><el-txt><el-id>yp</el-id><el-kw> is </el-kw><el-lit>0</el-lit></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="throw604" tabindex="0"><el-kw>throw exception </el-kw><el-field id="msg605" class="ok" tabindex="0"><el-txt>"<el-lit>yp is zero: </el-lit>{<el-id>xp</el-id>}<el-lit>,</el-lit>{<el-id>yp</el-id>}<el-lit> + </el-lit>{<el-id>xq</el-id>}<el-lit>,</el-lit>{<el-id>yq</el-id>}<el-lit></el-lit>"</el-txt><el-place><i>message</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
<p>which will stop the program and print the message in the Debug window (unless caught by a <a href="#try"><el-kw>try</el-kw></a> statement).</p>

<div id="Parameter_passing_1"></div>
<div id="parameter"></div>
<h2 id="call">Procedure call</h2>
<p>A <el-kw>call</el-kw> statement is used when you want to run a <a href="#procedure">procedure</a>.</p>
<p>The procedure may be:</p>
<ul>
<li>a procedure that you have defined at the global level</li>
  <el-statement><el-kw>call</el-kw> <el-method>fillRandom</el-method>(<el-id>grid</el-id>)</el-statement>
<li>a procedure method on an object of a class that you have defined</li>
  <el-statement><el-kw>call</el-kw> <el-id>apple</el-id>.<el-method>newRandomPosition</el-method>(<el-id>snake</el-id>)</el-statement>
  <el-statement><el-kw>call</el-kw> <el-kw>property</el-kw>.<el-id>hand</el-id>.<el-method>draw</el-method>()</el-statement>
<li>a procedure method that belongs to the same class as the procedure that you are calling from</li>
  <el-statement><el-kw>call</el-kw> <el-method>updateNeighbours</el-method>()</el-statement>
<li>a procedure provided by the standard library</li>
  <el-statement><el-kw>call</el-kw> <el-method>pause</el-method>(<el-lit>2000</el-lit>)</el-statement>
<li>a procedure method on an object of a Type provided by the standard library</li>
  <el-statement><el-kw>call</el-kw> <el-id>vg</el-id>.<el-method>append</el-method>(<el-id>rect</el-id>)</el-statement>
  <el-statement><el-kw>call</el-kw> <el-kw>property</el-kw>.<el-id>cards</el-id>.<el-method>append</el-method>(<el-id>card</el-id>)</el-statement>
</ul>
<p>The arguments provided must match the number and Type of the parameters specified in the definition of the procedure. If there are no parameters, leave the brackets empty.</p>
<p>For procedures that you define yourself, <el-kw>out</el-kw> parameters are allowed.  In this case the corresponding argument must be the name of a <el-kw>variable</el-kw> whose value gets updated by the procedure.</p>
<p>If the parameter is not an <el-kw>out</el-kw> parameter, any expression of the correct Type can be used as an argument.</p>
<p>Procedures may have side-effects, for example input/output or changing a data value in an object. They can change the contents of any mutable object passed in as an argument.  For this reason, procedures cannot be called from functions, which are not allowed to have side-effects.  <el-kw>call</el-kw> statements are simply not allowed in functions, to enforce this.</p>
<p>There is a limit to the complexity of a <el-kw>call</el-kw> statement.  Only one dot is allowed in the <el-code>procedure name</el-code> field, or two dots if the first word is <el-kw>property</el-kw>.  If you need anything more complicated, use a <el-kw>let</el-kw> statement on the line above.  See the error message explanation for <a href="#ProcRefField">'procedureName' in a call statement</a>.</p>

<h2 id="each">Each loop</h2>
<p>The <el-code>each..in..</el-code> construct specifies looping sequentially over the items in a <el-type>List</el-type> or an <el-type>Array</el-type>, or over the characters in a <el-type>String</el-type>.</p>
<p>The <el-code>each</el-code> loop counter <el-kw>variable</el-kw> is of the same Type as the items in the List or Array, or is of Type <el-type>String</el-type> if looping over the characters in a String. The variable does not have to have been previously defined in a <el-code>variable</el-code> statement.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-code>each</el-code></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To print a <el-type>List</el-type> and then each item in it</p>
<el-code-block source="each.elan">
<el-statement class="ok" id="var16" tabindex="0"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt>["<el-lit>Tom</el-lit>", "<el-lit>Dick</el-lit>", "<el-lit>Harriet</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print30" tabindex="0"><el-kw>print </el-kw><el-field id="expr31" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-lit>0</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="each19" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>each </el-kw><el-field id="ident21" class="ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> in </el-kw><el-field id="expr22" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>source</i></el-place></el-field></el-top>
<el-statement class="ok" id="print23" tabindex="0"><el-kw>print </el-kw><el-field id="expr24" class="optional ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end each</el-kw>
</el-statement>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Function to reverse a <el-type>String</el-type></p>
<el-code-block source="each.elan">
<el-func class="ok multiline" id="func15" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident17" class="ok" tabindex="-1"><el-txt>reverse</el-txt></el-field></el-method>(<el-field id="params18" class="optional ok" tabindex="-1"><el-txt><el-id>s</el-id> <el-kw>as</el-kw> <el-type>String</el-type></el-txt></el-field>)<el-kw> returns </el-kw><el-field id="type19" class="ok" tabindex="-1"><el-txt><el-type>String</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="var36" tabindex="-1"><el-kw>variable </el-kw><el-field id="var37" class="ok" tabindex="-1"><el-txt><el-id>sReturn</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr38" class="ok" tabindex="-1"><el-txt><el-kw>empty</el-kw> <el-type>String</el-type></el-txt></el-field></el-statement>
<el-statement class="ok multiline" id="each28" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>each </el-kw><el-field id="ident30" class="ok" tabindex="-1"><el-txt><el-id>ch</el-id></el-txt></el-field><el-kw> in </el-kw><el-field id="expr31" class="ok" tabindex="-1"><el-txt><el-id>s</el-id></el-txt></el-field></el-top>
<el-statement class="ok" id="set32" tabindex="-1"><el-kw>set </el-kw><el-field id="ident33" class="ok" tabindex="-1"><el-txt><el-id>sReturn</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr34" class="ok" tabindex="-1"><el-txt><el-id>ch</el-id> + <el-id>sReturn</el-id></el-txt></el-field></el-statement>
<el-kw>end each</el-kw>
</el-statement>
<el-statement class="ok" id="return20" tabindex="-1"><el-kw>return </el-kw><el-field id="expr21" class="ok" tabindex="-1"><el-txt><el-id>sReturn</el-id></el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>
</div></div>
<hr>
<h2 id="for">For loop</h2>
<div id="step"></div>
<p>The <el-code>for..from..to..step..</el-code> construct specifies looping through a sequence of integer values with a given increment.</p>
<p>The <el-code>for</el-code> loop counter <el-kw>variable</el-kw> (which counts from 0) is of Type <el-type>Int</el-type> and does not have to have been defined in a <el-code>variable</el-code> statement.</p>
<p>The three defining values, <el-code>from</el-code>, <el-code>to</el-code>, and <el-code>step</el-code>, must all be of Type <el-type>Int</el-type>, positive or negative.
and may be defined by literals, <el-kw>variable</el-kw>s or expressions that evaluate to integers.</p>
<p>Note that, if you require a negative step value, then the literal, <el-kw>variable</el-kw>, or expression must start with a negative sign.
This is needed at compile time to determine the nature of the exit condition.
So if you have a <el-kw>variable</el-kw> <el-code>s</el-code> that holds a negative value to be used to step in reverse order, then you would write:</p>
<el-code-block source="forStepNeg.elan">
<el-statement class="ok" id="var16" tabindex="0"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt>["<el-lit>Tom</el-lit>", "<el-lit>Dick</el-lit>", "<el-lit>Harriet</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var40" tabindex="0"><el-kw>variable </el-kw><el-field id="var41" class="ok" tabindex="0"><el-txt><el-id>s</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr42" class="ok" tabindex="0"><el-txt>-<el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="for34" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident36" class="ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr37" class="ok" tabindex="0"><el-txt><el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr39" class="ok" tabindex="0"><el-txt>-(-<el-id>s</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="print43" tabindex="0"><el-kw>print </el-kw><el-field id="expr44" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-id>n</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<div id="else"></div>
<div id="if"></div>
<h2 id="if_statement">If statement</h2>
<p>See also <a href="#if_expression">if expression</a></p>
<p>The <el-kw>if..then..else..</el-kw> and <el-kw>if..then..else if..else..</el-kw> constructs specify which of several code sequences is to be executed next.</p>
<p>The <el-kw>else</el-kw> clause is optional.</p>
<p>You can add as many <el-kw>else if</el-kw> clauses as you wish, but only one unconditional <el-kw>else</el-kw> (which, if present, must be the last clause).</p>

Example 1:
<el-code-block source="if_else">
<el-statement class="ok multiline" id="if71" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr73" class="ok" tabindex="0"><el-txt><el-id>head</el-id><el-kw> is </el-kw><el-id>apple</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="call80" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident81" class="ok" tabindex="0"><el-txt><el-method>setAppleToRandomPosition</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args82" class="optional ok" tabindex="0"><el-txt><el-id>apple</el-id>, <el-id>body</el-id></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok outdent" id="else83" tabindex="0"><el-top>
<el-kw>else </el-kw><el-field id="elif85" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
<el-statement class="ok" id="call86" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident87" class="ok" tabindex="0"><el-txt><el-id>body</el-id>.<el-method>removeAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args88" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>

Example 2:
<el-code-block source="if_else">
<el-statement class="ok multiline" id="if135" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr137" class="ok" tabindex="0"><el-txt><el-id>item</el-id><el-kw> is </el-kw><el-id>value</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="set157" tabindex="0"><el-kw>set </el-kw><el-field id="ident158" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr159" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok outdent" id="else174" tabindex="0"><el-top>
<el-kw>else </el-kw><el-kw>if </el-kw><el-field id="expr175" class="ok" tabindex="0"><el-txt><el-id>item</el-id>.<el-method>isBefore</el-method>(<el-id>value</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top></el-statement>
<el-statement class="ok" id="set195" tabindex="0"><el-kw>set </el-kw><el-field id="ident196" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr197" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>lst</el-id>[..<el-id>mid</el-id>], <el-id>item</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok outdent" id="else198" tabindex="0"><el-top>
    <el-kw>else </el-kw><el-field id="elif200" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
<el-statement class="ok" id="set201" tabindex="0"><el-kw>set </el-kw><el-field id="ident202" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr203" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>lst</el-id>[<el-id>mid</el-id> + <el-lit>1</el-lit>..], <el-id>item</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>

<h2 id="let">Let statement</h2>
<p>The <el-kw>let</el-kw> statement may be thought of as being between a <el-kw>constant</el-kw> definition and a <el-kw>variable</el-kw>'s <el-kw>set</el-kw> statement..
Like a <el-kw>variable set</el-kw> a <el-kw>let</el-kw> may be used only within a routine, but unlike a variable its value may not be changed with a <el-kw>set</el-kw>.
It is recommended that you always use a <el-kw>let</el-kw> in preference to a <el-kw>variable</el-kw> unless you need to be able to assign a new value to it.
</p>
<p>You can put a <el-kw>let</el-kw> in a loop, so the variable gets a new value each time it is executed, but the value of the variable cannot be changed any other way.</p>

<h2 id="print">Print statement</h2>
<p>The <el-kw>print</el-kw> statement sends text strings to the Display pane. For example:</p>
<ul>
 <li><el-code>
    <el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt>"<el-lit>Hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
   &#x27f6; Hello</el-code></li>
<li><el-code>
    <el-statement class="ok" id="let7" tabindex="0"><el-kw>let </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-lit>4</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id>*<el-id>b</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    &#x27f6; 12</el-code></li>
<li><el-code>
    <el-statement class="ok" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional ok" tabindex="0"><el-txt>"<el-lit></el-lit>{<el-id>a</el-id>}<el-lit> times </el-lit>{<el-id>b</el-id>}<el-lit> equals </el-lit>{<el-id>a</el-id>*<el-id>b</el-id>}<el-lit></el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    &#x27f6; 3 times 4 equals 12</el-code></li>
</ul>

<p>The last example above uses <a href="LibRef.html#InterpolatedString">interpolated strings</a>. Arguments placed within curly braces are evaluated before printing, and these may be separated by literal text and punctuation as needed. This is one recommended way to print more than one value on a line. The other way is to use <a href="LibRef.html#printLine">print procedures</a>.</p>

<h2 id="repeat">Repeat loop</h2>
<p>The <el-kw>repeat..end repeat when</el-kw> <el-code>condition</el-code> loop is used when you want at least one execution of the enclosed statements followed by a test that chooses either to execute them again or to exit from the loop.</p>
<p><el-code>condition</el-code> is either a <el-type>Boolean</el-type> variable or an expression that evaluates to a Boolean value.</p>
<p>If <el-code>condition</el-code> is <el-code><el-id>true</el-id></el-code> then the loop ends, if <el-code><el-id>false</el-id></el-code> it resumes. For example:</p>

<el-code-block source="repeat.elan">
<el-statement class="ok multiline" id="repeat12" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
<el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>writeLine</el-method></el-txt></el-field>(<el-field id="args17" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-id>i</el-id>]</el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="set18" tabindex="0"><el-kw>set </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-id>i</el-id> + <el-lit>1</el-lit></el-txt></el-field></el-statement>
<el-kw>end repeat when </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-id>i</el-id><el-kw> is </el-kw><el-id>names</el-id>.<el-method>length</el-method>()</el-txt></el-field>
</el-statement>
</el-code-block>

<h2 id="set">Set statement</h2>
<p>
The <el-kw>set</el-kw> statement is used to assign a new value to an existing <el-kw>variable</el-kw>.
The new value must be of the same Type as (or a Type compatible with) that of the <el-kw>variable</el-kw>.
A <el-kw>set</el-kw> statement may not assign a new value to a parameter within a procedure unless it the parameter is preceded by <el-kw>out</el-kw> in the parameter list.</p>

<h2 id="throw">Throw statement</h2>
<p>You can deliberately generate, or 'throw', an exception when a specific circumstance is identified, using a <el-code>throw</el-code> statement, for example:</p>
<el-code>throw exception "something has happened"</el-code><br>

<div id="catch"></div>
<div id="exception"></div>
<h2 id="try">Try statement</h2>
<p>You can test whether another piece of code might throw an exception by wrapping it in a <el-code>try</el-code> statement. This might arise when calling a <a href="LibRef.html#SystemMethods">System method</a> that is dependent upon external conditions, for example:</p>

<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try18" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call38" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident39" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args40" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print47" tabindex="0"><el-kw>print </el-kw><el-field id="expr48" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch20" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok" id="print64" tabindex="0"><el-kw>print </el-kw><el-field id="expr65" class="optional ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>
The variable holding the exception (by default named <el-code>e</el-code>, but this may be changed by you) is of Type <el-type>String</el-type>. You can compare the exception message to one or more expected messages and, if the message does not match an expected exception, you may choose to throw the exception 'up', as in this example:
<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try141" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call158" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident159" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args160" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print177" tabindex="0"><el-kw>print </el-kw><el-field id="expr178" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident145" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok multiline" id="if211" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr213" class="ok" tabindex="0"><el-txt><el-id>e</el-id><el-kw> isnt </el-kw>"<el-lit>an expected message</el-lit>"</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="throw234" tabindex="0"><el-kw>throw exception </el-kw><el-field id="msg235" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>message</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>

<h2 id="variable">Variable statement</h2>
<p>The <el-kw>variable</el-kw> statement defines the name to be used to store mutable (i.e. changeable) data. The name defined must be a valid <a href="#Identifier">Identifier</a>,
and the initial value is given by a following expression. For example:</p>

<h2 id="while">While loop</h2>
<p>The <el-kw>while condition..end while</el-kw> loop is used when you want execution of the enclosed statements to begin
 only if <el-code>condition</el-code> is <el-code><el-id>true</el-id></el-code>.</p>
<p><el-code>condition</el-code> is either a <el-type>Boolean</el-type> <el-kw>variable</el-kw> or an expression that evaluates to a Boolean value.</p>
<p>When <el-code>condition</el-code> is <el-code><el-id>true</el-id></el-code> the enclosed code is executed;
 when <el-code><el-id>false</el-id></el-code> the loop is bypassed. For example:</p>

<el-code-block source="while.elan">
<el-statement id="while6" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>file</el-id>.<el-method>endOfFile</el-method>()</el-txt></el-field></el-top>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>readLine</el-method>()</el-txt></el-field></el-statement>
<el-kw>end while</el-kw>
</el-statement>
</el-code-block>


<h1 id="Expression">Expressions</h1>
<p>One of the most important constructs in programming is the 'expression'. An expression is evaluated to return a value. An expression is made up of the following possible elements:</p>
<ul>
<li>Literal value</li>
<li>Named value</li>
<li>Operator (including brackets)</li>
<li>Function call</li>
</ul>
<p>which this chapter describes.</p>

<div id="literal_value"></div>
<h2 id="LiteralValue">Literal value</h2>
<p>A literal value is where a value is written 'literally' in the code, such as <el-code>3.142</el-code> &ndash; in contrast to a value that is referred to by a name.</p>
<p>Here is a table showing some example literal values.  Follow the links for more information about each type.</p>
<table>
<tr><th>Type</th><th>Example of literal</th></tr>
<tr><td><a href="LibRef.html#Int">Int</a></td><td><el-code>3</el-code></td></tr>
<tr><td><a href="LibRef.html#Float">Float</a></td><td><el-code>2.0</el-code></td></tr>
<tr><td><a href="LibRef.html#Boolean">Boolean</a></td><td><el-code>true</el-code></td></tr>
<tr><td><a href="LibRef.html#String">String</a></td><td><el-code>"Hello"</el-code></td></tr>
<tr><td><a href="LibRef.html#Tuple">Tuple</a></td><td><el-code>tuple(3, "banana")</el-code></td></tr>
<tr><td><a href="LibRef.html#List">List</a></td><td><el-code>["lemon", "lime", "orange"]</el-code></td></tr>
<tr><td><a href="LibRef.html#Dictionary">Dictionary</a></td><td><el-code>["a":3, "b":5]</el-code></td></tr>
<tr><td><a href="LibRef.html#ListImmutable">ListImmutable</a></td><td><el-code>{"lemon", "lime", "orange"}</el-code></td></tr>
<tr><td><a href="LibRef.html#DictionaryImmutable">DictionaryImmutable</a></td><td><el-code>{"a":3, "b":5}</el-code></td></tr>
</table>
<p>For more about List and Dictionary literals see the <a href="LibRef.html#StandardDataStructures">Standard (mutable) data structures</a> table.<br>
For more about ListImmutable and DictionaryImmutable literals see the <a href="LibRef.html#ImmutableDataStructures">Immutable data structures</a> table.</p>

<h2 id="named_value">Named value</h2>
<p>A named value is a value that is associated with a name rather than being defined literally in code. There are various kinds of named value:</p>
<p><a href="#constant">Constants</a>, <span class="Hyperlink"><a href="#let">let</a></span> statement, <span class="Hyperlink"><a href="#variable">variable</a></span> statement, <a href="#Parameter_passing_1">Parameter passing</a>, <span class="Hyperlink"><a href="#enum">enum</a></span> statement.
  Once a named value has been defined, it can be referred to by the name.</p>

<div id="parse_name"></div>
<h2 id="Identifier">Identifier</h2>
<p>For all kinds of named values, the name must follow the rules for an 'identifier'.
  It must start with a lower case letter, followed by any combination of lower and upper case letters,
   numeric digits, and the _ (underscore) symbol. It may not contain spaces or other symbols.</p>
<p>If you happen to choose a language keyword, method name or other reserved word, an error message will tell you that you cannot use it for an identifier.</p>

<div id="global"></div>
<div id="library"></div>
<h2 id="scoping">Scoping and name qualification</h2>
<p>With the exception of a <el-code>constant</el-code> (below), which is global in scope, named values are always 'local': their scope is confined to the method in which they are defined. </p>
<p>Elan allows local named values to be defined with the same name as a constant, function, or procedure defined at global level or defined in the standard library. In such cases, when the name is used within the same method, then it will refer to the local definition. If you have done this, but then need to access the <el-code>constant</el-code>, <el-code>function</el-code>, or <el-code>procedure</el-code> with the same name, then you can simply prefix the use of the name with a 'qualifier' of either <el-code>global.</el-code> or <el-code>library.</el-code> as appropriate.</p>

<div id="range"></div>
<div id="IndexedValue"></div>
<h2 id="IndexedValues">Indexed values</h2>
If a variable is of an indexable Type, then an index or index range may be applied to the variable within an expression. For example:
<pre>
    <el-code>variable a set to "Hello World!"</el-code>
    <el-code>print a[4]</el-code>        &#x27f6; <el-code>o</el-code>
    <el-code>print a[4..]</el-code>    &#x27f6; <el-code>o World!</el-code>
    <el-code>print a[..7]</el-code>    &#x27f6; <el-code>Hello W</el-code>   (since the upper bound of a range is <em>exclusive</em>)
    <el-code>print a[0..4]</el-code>  &#x27f6; <el-code>Hell</el-code>         (for the same reason)
</pre>
<p>In the examples above, the result is of type String in all cases.
When using indexing on other types:</p>
<ul>
<li>with a single index, the result is the same type as the elements of the data structure being indexed</li>
<li>with an index range, the result is the same type as the data structure itself</li>
</ul>
<p>Indexable types are <a href="LibRef.html#String">String</a>, <a href="LibRef.html#StandardDataStructures">Array, Array2D, List, Dictionary</a>, <a href="LibRef.html#ImmutableDataStructures">ListImmutable and DictionaryImmutable</a>.</p>
<p>Index ranges cannot be applied to Dictionary or DictionaryImmutable.</p>
<p>If the index values in a range are equal, or the second is smaller than the first,
then an empty data structure of the correct type is generated.</p>
<p>Important: unlike in many languages, indexes in Elan (whether, single, multiple, or a range) are only ever used for <em>reading</em> values.
Writing a value to a specific index location is done through a method such as in these examples:</p>
<pre>
    <el-method>put</el-method>           on a   <el-type>List</el-type>
    <el-method>withPut</el-method>   on a    <el-type>ListImmutable</el-type>
    <el-method>put</el-method>           on a    <el-type>Dictionary</el-type>
    <el-method>withPut</el-method>   on a    <el-type>DictionaryImmutable</el-type>
</pre>

<div id="operator"></div>
<h2 id="Operators">Operators</h2>

<h4 class="no-TOC" id="ArithmeticOperators">Arithmetic operators</h4>
<p>Arithmetic operators can be applied to <el-code>Float</el-code> or <el-code>Int</el-code> arguments. The result may be a <el-code>Float</el-code> or an <el-code>Int</el-code> depending on the arguments.</p>
<p>For <el-code>^ + - *</el-code>, the result is a <el-code>Float</el-code> if either of the arguments is a <el-code>Float</el-code>, and an <el-code>Int</el-code> if both arguments are <el-code>Int</el-code>.</p>
<p>For <el-code>/</el-code>, the result is always a <el-code>Float</el-code>.  It can be converted to an <el-code>Int</el-code> using the <a href="LibRef.html#floor">floor()</a> function.</p>
<div id="div"></div>
<p id="mod"><el-code>mod</el-code> and <el-code>div</el-code> only operate on <el-code>Int</el-code> arguments, and the result is <el-code>Int</el-code>.</p>
<pre>
    <el-code>2^3</el-code>             &#x27f6;  <el-code>8</el-code>
    <el-code>2/3</el-code>             &#x27f6;  <el-code>0.666..</el-code>
    <el-code>2*3</el-code>             &#x27f6;  <el-code>6</el-code>
    <el-code>2 + 3</el-code>         &#x27f6;  <el-code>5</el-code>
    <el-code>2 - 3</el-code>         &#x27f6;  <el-code>-1</el-code>
    <el-code>11 mod 3</el-code>   &#x27f6;  <el-code>2</el-code> (integer remainder)
    <el-code>11 div 3</el-code>   &#x27f6;  <el-code>3</el-code> (integer division)
</pre>
<p>Arithmetic operators follow the conventional rules for precedence i.e. 'BIDMAS' (or 'BODMAS').</p>
<p>When combining <el-code>div</el-code> or <el-code>mod</el-code> with any other operators within an expression, insert brackets to avoid ambiguity e.g.:</p>
<pre>
    <el-code>(5 + 6) mod 3</el-code>
</pre>
<p>Note that <el-code>mod</el-code> is more of a remainder operator than a modulus operator -- the result takes the sign of the first argument.  If both arguments are positive, there is no difference.</p>
The minus sign may also be used as a unary operator, and this takes precedence over binary operators so:
<pre>
    <el-code>2*-3</el-code>           &#x27f6;  <el-code>-6</el-code>
</pre>
<p>Note that the Elan editor automatically puts spaces around the <el-code>+</el-code> and <el-code>&ndash;</el-code> binary operators, but not around <el-code>^</el-code>, <el-code>/</el-code> or <el-code>*</el-code>. This is just to visually reinforce the precedence.</p>
<p>The <el-code>div</el-code> operator rounds its result down, as if with the <el-method>floor</el-method> function.  This can give unexpected results with negative numbers, for example:</p>
<pre>
    <el-code>11 div -3</el-code>   &#x27f6;  <el-code>-4</el-code>
</pre>
<p>The <el-code>+</el-code> operator is also used for concatenating <el-type>String</el-type>s.  See <a href="LibRef.html#String">String</a>.</p>

<h4 class="no-TOC" id="LogicalOperators">Logical operators</h4>
<!-- TODO table of logical operators -->
<div id="and"></div>
<div id="not"></div>
<div id="or"></div>
<p>Logical operators are applied to <el-code>Boolean</el-code> arguments and return a <el-code>Boolean</el-code> result.</p>
<p><el-code>and</el-code> and <el-code>or</el-code> are binary operators<br>
<el-code>not</el-code> is a unary operator. </p>
<p>The operator precedence is <el-code>not</el-code> &rarr; <el-code>and</el-code> &rarr; <el-code>or</el-code>, so this
example, which implements an 'exclusive or', need not use brackets and can rely on the operator precedence:</p>

<el-code-block source="xor.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>xor</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type>, <el-id>b</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>a</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>b</el-id><el-kw> or </el-kw><el-id>b</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>a</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw></el-func>
</el-code-block>

<h4 class="no-TOC" id="EqualityTesting">Equality testing</h4>
<p>Equality testing uses the <el-code>is</el-code> and <el-code>isnt</el-code> keywords with two arguments. The arguments may be of any Type.</p>
<ul>
<li><el-code> a is b</el-code> returns <el-kw><el-id>true</el-id></el-kw>, if <el-code>a</el-code> and <el-code>b</el-code> are both of the same Type and their values are equal. The only exception is that if one argument is of Type <el-code>Float</el-code> and the other is of Type <el-code>Int</el-code>, then <el-code>is</el-code> will return <el-code>true</el-code> if their values are the same, i.e. are the same whole number.</li>
<li><el-code>isnt</el-code> returns the opposite of <el-code>is</el-code>.</li>
<li>Where a binary operator is expected, as soon as you type <el-code>is</el-code> the editor will automatically insert a space after it. To enter <el-code>isnt</el-code> you need to delete the space (using the Backspace key) and then type <el-code>nt</el-code>.</li>
</ul>
<p>Note that in Elan equality testing is always 'equality by value'; there is no such thing as 'equality by reference'.</p>
<p>If the items being compared are composite types, the elements within them are compared sequentially to see if the objects are equal.  For example two distinct instances of the same class compare equal if the values of all their properties compare equal.  And two Lists compare equal if they contain the same elements in the same order.</p>
<p>The compiler rejects any attempt to compare instances of different classes unless abstract classes and inheritance are involved.  Two instances which are subclasses of the same abstract class compare equal only if they are of the same class (and have the same property values).</p>

<h4 class="no-TOC">Numeric comparison</h4>
<p>The numeric comparison operators are:</p>
<pre>
    <el-code>&gt; </el-code>        for     greater than
    <el-code>&lt; </el-code>        for     less than
    <el-code>&gt;=</el-code>        for     greater than or equal to
    <el-code>&lt;=</el-code>        for     less than or equal to
</pre>
<p>Each is applied to two arguments of Type <el-code>Float</el-code>, but any named value or expression that evaluates to an <el-code>Int</el-code> may always be used where a <el-code>Float</el-code> is expected.</p>
<h4 class="no-TOC">Notes</h4>
<ul>
<li>These operators cannot be applied to strings. Use the dot methods <el-code>isBefore</el-code> and <el-code>isAfter</el-code> to compare strings alphabetically.
 See <a href="LibRef.html#isAfter">Dot methods on a String</a>.</li>
<li>Where a binary operator is expected, as soon as you type <el-code>&lt; </el-code>or <el-code>&gt;</el-code> the editor will automatically insert a space after it. To enter <el-code>&lt;=</el-code> or <el-code>&gt;=</el-code> you need to delete the space (using the Backspace key) and then type <el-code>=</el-code>.</li>
</ul>

<h4 class="no-TOC">Combining operators </h4>
<p>You can combine operators of different kinds, e.g. combining numeric comparison with logical operators in a single expression. However the rules of precedence between operators of different kinds are complex. It is strongly recommend that you always use brackets to disambiguate such expressions, for example:</p>

<el-code-block source="combiningOperators.elan">
<el-field id="expr19" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> &gt; <el-id>b</el-id>)<el-kw> and </el-kw>(<el-id>b</el-id> &lt; <el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
<br>
<el-field id="expr35" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> + <el-id>b</el-id>) &gt; (<el-id>c</el-id> - <el-id>d</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
</el-code-block>

<h2 id="function_call">Function call</h2>
An expression may simply be a function call, or it may include one or more function calls within it. Examples:
<el-code-block source="sinDeg.elan">
<el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var7" tabindex="0"><el-kw>variable </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit> + <el-method>cosDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var10" tabindex="0"><el-kw>variable </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>name</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>inputString</el-method>("<el-lit>Your name</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>name</el-id>.<el-method>upperCase</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
<li>The third example above is not strictly a function call, but is a 'system method' call.
System methods may be used only within the <el-code>main</el-code> routine or a <el-code>procedure</el-code>, because they have external dependencies or side effects.</li>
<li>In the fourth example, <el-code>upperCase</el-code> is a 'dot method' that may be applied to any instance (variable or literal) of Type <el-code>String</el-code>.
See <a href="LibRef.html#upperCase">Dot methods on a String</a>.</li>
</ul>

<h2 id="lambda">Lambda</h2>
<p>A <el-kw>lambda</el-kw> is a lightweight means to define a function 'in line'. You typically define a <el-code>lambda</el-code>:</p>
<ul>
<li>If the functionality it defines is needed in only one location: typically for a particular call to a <a href="LibRef.html#HoFs">Higher-order Function</a> (HoF).</li>
<li>If you need to capture a local variable in the implementation. This is called 'closing around a variable'.</li>
</ul>
<p>The syntax for a <el-kw>lambda</el-kw> is as follows:</p>
<ul>
<li>Start with the keyword <el-kw>lambda</el-kw>.</li>
<li>Parameter definitions, comma-separated, follow the same form as parameter definitions in a function or procedure, but without surrounding brackets.</li>
<li>The <el-code>=&gt;</el-code> symbol, which is usually articulated as 'returns',  'yields' or even 'fat arrow'.</li>
<li>An expression that makes use of the parameters, and may also make use of other variables that are in scope. </li>
</ul>
Example:
<el-code-block source="liveNeighbours.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>liveNeighbours</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>cells</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Boolean</el-type>&gt;, <el-id>c</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>neighbourCells</el-method>(<el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let13" tabindex="0"><el-kw>let </el-kw><el-field id="var14" class="ok" tabindex="0"><el-txt><el-id>live</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr15" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id>.<el-method>filter</el-method>(<el-kw>lambda</el-kw> <el-id>i</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>cells</el-id>[<el-id>i</el-id>])</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>live</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw> </el-func>
</el-code-block>

Notes:<ul>
<li>Although a <el-kw>lambda</el-kw> is commonly defined 'inline' (as shown above) it is possible to assign a lambda to a variable and hence to re-use it within the scope of that variable.</li>
</ul>

<h2 id="if_expression">If expression</h2>
The 'if expression' is in certain respects similar to an <span class="Link">If statement</span>, but with the following differences:
<ul>
<li>It is written entirely within a single expression. This is possible because the <el-kw>if</el-kw> expression always returns a value.</li>
<li>There is always a single <el-kw>then</el-kw> and a single <el-kw>else</el-kw> clause, and each clause contains just a single expression. The <el-kw>if</el-kw> expression returns the result of evaluating one of these two expressions, according to whether the condition evaluates to <el-id>true</el-id> or <el-id>false</el-id>.</li>
</ul>
<p>Here are three examples:</p>
<el-code-block source="if_expression.elan">
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>c</el-id> &lt; <el-lit>1160</el-lit><el-kw> then </el-kw><el-id>c</el-id> + <el-lit>40</el-lit><el-kw><br>else </el-kw><el-id>c</el-id> - <el-lit>1160</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<br>
<el-statement class="ok" id="return25" tabindex="0"><el-kw>return </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-method>isGreen</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw> then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>*</el-lit>")<el-kw><br>else </el-kw><el-id>attempt</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<br>
<el-statement class="ok" id="return104" tabindex="0"><el-kw>return </el-kw><el-field id="expr105" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>attempt</el-id>[<el-id>n</el-id>]<el-kw> is </el-kw>"<el-lit>*</el-lit>"<el-kw> then </el-kw><el-id>attempt</el-id><el-kw><br>else </el-kw><el-kw>if </el-kw><el-method>isYellow</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw> then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>+</el-lit>")<el-kw><br>else </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>_</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h2 id="new">New instance</h2>
<p>A 'new instance' expression is used to create a new instance of a <a href="LibRef.html#StandardDataStructures">library data structure</a>,
   or a <a href="#class"> user-defined class</a> or <a href="#record">record</a> &ndash; either to assign to a named value, or as part
  of a more complex expression. Example of use from demo program <el-code>snake_PP.elan</el-code>:</p>

<el-code-block>
<el-statement id="var5" tabindex="0"><el-kw>let </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>blocks</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Array2D</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;(<el-lit>40</el-lit>, <el-lit>30</el-lit>, <el-id>white</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>Where the new instance is of a <a href="#class"> user-defined class</a> or <a href="#record">record</a> the expression may optionally
be followed by a <el-kw>with</el-kw> clause in order to specify any property values. Example of this use:</p>

<el-code-block source="dealCard.elan">
<el-func id="func302" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident304" class="ok" tabindex="0"><el-txt>dealCard</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params305" class="optional ok" tabindex="0"><el-txt><el-id>random</el-id> <el-kw>as</el-kw> <el-type>Float</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type306" class="ok" tabindex="0"><el-txt><el-type>Card</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
  <el-statement class="ok" id="let309" tabindex="0"><el-kw>let </el-kw><el-field id="var310" class="ok" tabindex="0"><el-txt><el-id>number</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr311" class="ok" tabindex="0"><el-txt>(<el-id>random</el-id>*<el-lit>52</el-lit>).<el-method>floor</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let312" tabindex="0"><el-kw>let </el-kw><el-field id="var313" class="ok" tabindex="0"><el-txt><el-id>rank</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr314" class="ok" tabindex="0"><el-txt><el-id>rankValue</el-id>.<el-method>keys</el-method>()[<el-id>number</el-id><el-kw> div </el-kw><el-lit>4</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let315" tabindex="0"><el-kw>let </el-kw><el-field id="var316" class="ok" tabindex="0"><el-txt><el-id>suit</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr317" class="ok" tabindex="0"><el-txt><el-id>number</el-id><el-kw> mod </el-kw><el-lit>4</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="return307" tabindex="0"><el-kw>return </el-kw><el-field id="expr308" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Card</el-type>()<el-kw> with </el-kw><br><el-id>rank</el-id><el-kw> set to </el-kw><el-id>rank</el-id>, <br><el-id>suit</el-id><el-kw> set to </el-kw><el-id>suit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end function</el-kw>
  </el-func>
</el-code-block>

<div id="copy"></div>
<div id="with"></div>
<div id="copyWith"></div>
<h2 id="copy_with">Copy..with</h2>
<p>A <el-kw>copy..with</el-kw> expression is used to make a copy of an existing instance, but with a different value for one or more of the properties
  &ndash; either to assign to a named value, or as part of a more complex expression.</p>
<p>It is used extensively within functional programming where you are dealing with <a href="#record">record</a>s or other <i>immutable</i> Types.
Example of use in this manner, taken from demo program <el-code>snake_FP.elan</el-code>:</p>

<el-code-block>
<el-func class="ok multiline" id="func72" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident74" class="ok" tabindex="0"><el-txt>newApple</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params75" class="optional ok" tabindex="0"><el-txt><el-id>g</el-id> <el-kw>as</el-kw> <el-type>Game</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type76" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
  <el-statement class="ok" id="let79" tabindex="0"><el-kw>let </el-kw><el-field id="var80" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>rnd2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr81" class="ok" tabindex="0"><el-txt><el-id>g</el-id>.<el-id>rnd</el-id>.<el-method>nextInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let82" tabindex="0"><el-kw>let </el-kw><el-field id="var83" class="ok" tabindex="0"><el-txt><el-id>y</el-id>, <el-id>rnd3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr84" class="ok" tabindex="0"><el-txt><el-id>rnd2</el-id>.<el-method>nextInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let85" tabindex="0"><el-kw>let </el-kw><el-field id="var86" class="ok" tabindex="0"><el-txt><el-id>apple2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr87" class="ok" tabindex="0"><el-txt><el-method>newSquare</el-method>(<el-id>x</el-id>, <el-id>y</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let88" tabindex="0"><el-kw>let </el-kw><el-field id="var89" class="ok" tabindex="0"><el-txt><el-id>g2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr90" class="ok" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>g</el-id><el-kw> with </el-kw><br><el-id>apple</el-id><el-kw> set to </el-kw><el-id>apple2</el-id>, <br><el-id>rnd</el-id><el-kw> set to </el-kw><el-id>rnd3</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="return77" tabindex="0"><el-kw>return </el-kw><el-field id="expr78" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-method>bodyOverlaps</el-method>(<el-id>g2</el-id>, <el-id>apple2</el-id>)<el-kw> then </el-kw><el-method>newApple</el-method>(<el-id>g2</el-id>)<el-kw><br>else </el-kw><el-id>g2</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end function</el-kw>
</el-func>
</el-code-block>

<p><el-kw>copy..with</el-kw> may also be used in object-oriented programming with instances of regular (<i>mutable</i>) classes. Also,
  note that a <el-kw>with</el-kw> clause (following the same syntax as in a <el-kw>copy..with</el-kw> expression), may be used
  within a new instance expression to set up properties for the object not specified in the constructor.</p>

<h2 id="empty">Empty of Type</h2>
<p>An 'empty of Type' expression is used to make the default (empty) instance of any Type
  &ndash; usually only created for comparing to another instance to test whether that other instance is also empty or default.
  This may arise, for example, if a <a href="#class">class</a> or <a href="#record">record</a> is defined with a property that has never had a value assigned to it.
  The following example is taken from demo program <el-code>pathfinder.elan</el-code>:</p>

<el-code-block>
  <el-proc class="ok multiline" id="proc267" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident269" class="ok" tabindex="0"><el-txt>visitNextPoint</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params270" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place><el-compl><i>parameter definitions</i></el-compl></el-field>)</el-top>
    <el-statement class="ok" id="call271" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident272" class="ok" tabindex="0"><el-txt><el-method>updateNeighbours</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args273" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
    <el-statement class="ok" id="set274" tabindex="0"><el-kw>set </el-kw><el-field id="ident275" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>current</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr276" class="ok" tabindex="0"><el-txt><el-method>nextNodeToVisit</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok multiline" id="if277" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr279" class="ok" tabindex="0"><el-txt>(<el-kw>property</el-kw>.<el-id>current</el-id><el-kw> is </el-kw><el-kw>empty</el-kw> <el-type>Node</el-type>)<el-kw> or </el-kw>(<el-kw>property</el-kw>.<el-id>current</el-id>.<el-id>point</el-id><el-kw> is </el-kw><el-kw>property</el-kw>.<el-id>destination</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
    <el-statement class="ok" id="set280" tabindex="0"><el-kw>set </el-kw><el-field id="ident281" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>running</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr282" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok outdent" id="else283" tabindex="0"><el-top>
        <el-kw>else </el-kw><el-field id="elif285" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
    <el-statement class="ok" id="call286" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident287" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>current</el-id>.<el-method>setVisited</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args288" class="optional ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
    <el-kw>end if</el-kw>
    </el-statement>
    <el-kw>end procedure</el-kw>
    </el-proc>
</el-code-block>
<p>It is also possible explicitly to set a property or a named value to an empty instance of the appropriate Type.</p>

<h1 id="Comment">Comments</h1>
<h2># comment</h2>
<p>A comment is not an instruction: it is ignored by the compiler and does not change how the program works.
Rather, a comment contains information <em>about</em> the program, intended to be read by a person seeking to understand or modify the code.</p>
<p>Every comment starts with the hash symbol <el-code>#</el-code> followed by some text or a blank line. The text field in
a comment may contain any text, except that it must not start with the open square bracket symbol <el-code>[</el-code>.</p>
<p>Comments may be inserted at any level: in the <a href="#GlobalInstructions">Global</a>,
<a href="#MemberInstructions">Member</a>, or <a href="#StatementInstructions">Statement</a> instruction levels,
as well as from the <el-code>new code</el-code> prompt &ndash; every prompt provides a <el-code>#</el-code> for entering a comment.</p>
<p> Every Elan program has a single comment at the top of the file, which is generated by the system and cannot be edited or deleted by the user.
  This comment is known as the 'file header' and shows the version of Elan being run.</p>

<h1 id="compile_error">Compile Errors and Warnings</h1>

<h2></h2>

 <p>Q: What is the difference between a compile <i>error</i> and a <i>warning</i>.</p>
 <p>A: A warning usually indicates that the fix may involve <i>adding</i> some more code,
 for example adding a definition for an unknown identifier. An error usually indicates
 that you will need to <i>alter</i> code to fix the error.
 But they are similar in that you will not be able to run your program until the issues are fixed. In all programming
 languages it is a good practice 'treat all compile warnings as errors' i.e. fix them as soon as you see them appear.</p>

<h2>Messages</h2>

<h3 id="TypeCompileError" class="no-TOC">Expression must be ...</h3>
 <p>An expression, when evaluated, results in a value of a Type that is not compatible with its 'target',
 for example: if the result of the expression is being assigned to an existing variable, or if an expression is defined 'inline' as
 an argument into a method call.</p>

<h3 id="ThisCompileError" class="no-TOC">Cannot use 'this' outside class context</h3>
 <p>The keyword <el-kw>this</el-kw> may only be used within an instance method on a class to refer to the current instance.</p>

<h3 id="DeclaredAboveCompileError" class="no-TOC">Abstract Class ... must be declared before it is used</h3>
 <p>If a class inherits from one or more abstract classes, then the latter must all have already been declared (defined) earlier in the code file.</p>

<h3 id="MemberTypeCompileError" class="no-TOC">Member ... must be of type ...</h3>
 <p>This error occurs when a class is defined as inheriting from an abstract class,
 and has implemented an inherited member (method or property) with the correct name, but with different Types.</p>

<h3 id="TypesCompileError" class="no-TOC">Incompatible types. Expected: ... Provided: ...</h3>

<h3 id="TernaryCompileError" class="no-TOC">Cannot determine common type between ... and ...</h3>

<h3 id="UndefinedSymbolCompileError" class="no-TOC"> ... is not defined for type ...</h3>
 <p>Arises when 'dot calling' a member (method or property) that does not exist on the Type of the named value or expression before the dot.</p>

<h3 id="CannotCallAFunction" class="no-TOC">Cannot call a function as a procedure</h3>
 <p>A function (or function method) is to be used within an expression, not via a <el-kw>call</el-kw> instruction.</p>

<h3 id="CannotUseSystemMethodInAFunction" class="no-TOC">Cannot use a system method in a function</h3>
 <p>A 'system method' (defined in the Standard Library) returns a value like a function does. However, because a system method
 either makes changes to the system and/or depends on external inputs, it may be used only within a procedure or the main routine.</p>

<h3 id="IsDeprecated" class="no-TOC">Code change required ...</h3>
 <p>Indicates that a library method or class has been changed since the version in which your Elan code was written. The link in the
 message should take you directly to information in the Library Reference documentation on how to update your code to cope with the change.</p>

<h3 id="CannotUseLikeAFunction" class="no-TOC">Cannot call procedure ... within an expression</h3>
 <p>A procedure may be used only within a <el-kw>call</el-kw> instruction.</p>

<h3 id="CannotCallAsAMethod" class="no-TOC">Cannot invoke ... as a method</h3>
 <p>The code is attempting to use a free-standing method (function or procedure) as a 'dot method' on a named value or the result of an expression.</p>

<h3 id="NotIndexableCompileError" class="no-TOC">Cannot ...index ...</h3>
 <p>An index (in square brackets) may be applied only to certain data structure Types: <el-type>String</el-type>, <el-type>Array</el-type>, <el-type>Array2D</el-type>,
 <el-type>List</el-type>, <el-type>ListImmutable</el-type>, <el-type>Dictionary</el-type>, and <el-type>DictionaryImmutable</el-type>.</p>

<h3 id="NotRangeableCompileError" class="no-TOC">Cannot range ...</h3>
 <p>A range may be applied only to certain data structure Types: <el-type>String</el-type>, <el-type>Array</el-type>, <el-type>List</el-type>, and <el-type>ListImmutable</el-type>.</p>

<h3 id="NotNewableCompileError" class="no-TOC">Cannot new ...</h3>
 <p>The Type specified after the <el-kw>call</el-kw> keyword cannot be instantiated. Either the Type is unknown,
 or it is an abstract class or interface.</p>

<h3 id="InvalidSourceForEachCompileError" class="no-TOC">Source for 'each' must be an Array, List, or String.</h3>

<h3 id="MustBeAbstractCompileError" class="no-TOC">Superclass ... must be inheritable class</h3>
 <p>A concrete class may inherit from an abstract class, and/or an interface, but not from another concrete class.
 In Elan, all classes must be either abstract or 'final' &ndash; a final class being concrete and not-inheritable.</p>

<h3 id="MustBeInterfaceCompileError" class="no-TOC">Superclass ... must be an interface</h3>
 <p>An interface may inherit from other interfaces, but not from any class.</p>

<h3 id="MustNotBeCircularDependencyCompileError" class="no-TOC">Class/interface ... cannot inherit from itself</h3>
 <p>The message is self explanatory.</p>

<h3 id="MustBeSingleAbstractCompileError" class="no-TOC">There must be only one abstract superclass ...</h3>
 <p>A class may inherit from only one abstract class. However, it may additionally inherit from one or more interfaces.</p>

<h3 id="PrivateMemberCompileError" class="no-TOC">Cannot reference private member ...</h3>
 <p>A private member (method or property) may be accessed only by code within the class, or within subclasses of it.
 It may not be accessed by any code outside the class hierarchy.</p>

<h3 id="MustImplementCompileError" class="no-TOC">... must implement ...</h3>
 <p>If a concrete class inherits from any abstract class or interface(s) it must implement all abstract methods defined in those Types.</p>

<h3 id="MustBeConcreteCompileError" class="no-TOC">... must be concrete to new</h3>
 <p>You cannot create an instance of any abstract class or interface: only of a concrete class.</p>

<h3 id="OutParameterCompileError" class="no-TOC">Cannot pass ... as an out parameter</h3>
 <p>If a parameter of a procedure is marked with <el-kw>out</el-kw> then this means that the parameter may be
 reassigned within the procedure. Therefore you must pass in a variable that can be re-assigned. You cannot pass in: a
 constant, a literal value, or a named value that is defined by a <el-kw>let</el-kw> instruction.</p>

<div id="ExtensionFunction"></div>
<div id="ExtensionProcedure"></div>
<h3 id="ExtensionCompileError" class="no-TOC">Cannot call extension method directly</h3>
 <p>A method that is defined within the Library as an 'extension method', such as <el-method>asString</el-method> may only be called using 'dot syntax' on a named
 value or an expression.</p>

<h3 id="PropertyCompileError" class="no-TOC">Cannot prefix function with 'property'</h3>
 <p>The prefix <el-kw>property.</el-kw> may only be used before a property name: not a function name.</p>

<h3 id="MissingParameterCompileError" class="no-TOC">Missing argument(s) ...</h3>
 <p>The method being called expects more arguments than have been provided.</p>

<h3 id="ExtraParameterCompileError" class="no-TOC">Too many argument(s) ...</h3>
 <p>A method has been passed more arguments than it expects.</p>

<h3 id="ParameterTypesCompileError" class="no-TOC">Argument types ...</h3>
 <p>One or more arguments provided to the method are of the wrong Type.</p>

<h3 id="GenericParametersCompileError" class="no-TOC">...&lt;of Type&gt;...</h3>
 <p>Certain data structure Types, including <el-type>Array</el-type>, <el-type>Array2D</el-type>,
 <el-type>List</el-type> must specify the Type of their members, for example <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;.
 Failure to specify the '&lt;of Type&gt;' on these Types will give an error, as will specifying 'of Type' where it is <i>not</i> required.
 Dictionaries require Types to be specified for both the keys and the values,
 for example: <el-code><el-type>Dictionary</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>Float</el-type>&gt;</el-code>.</p>

<h3 id="MutateCompileError" class="no-TOC">May not re-assign the ...</h3>
 <p>Attempting to re-assign, or mutate, a named value that may not be re-assigned in the current context.</p>

<h3 id="NotUniqueNameCompileError" class="no-TOC">Name ... not unique in scope ...</h3>
 <p>Attempting to create an identifier with the same name as one already defined <i>within the same scope</i>.</p>

<h3 id="ReassignInFunctionCompileError" class="no-TOC">May not set ... in a function</h3>
 <p>A property can be re-assigned only within a procedure method, not within a function, because re-assigning a property is a 'side effect'.</p>

<h3 id="RedefinedCompileError" class="no-TOC">The identifier ... is already used for a ... and cannot be re-defined here.</h3>
 <p>An existing named value may not be defined again within the same scope.</p>

<h3 id="DuplicateKeyCompileError" class="no-TOC">Duplicate Dictionary key(s)</h3>
 <p>Attempting to define a literal <el-type>Dictionary</el-type> or <el-type>DictionaryImmutable</el-type>
 with one or more duplicated keys in the definition.</p>

<h3 id="FunctionRefCompileError" class="no-TOC">To evaluate function ... add brackets ...</h3>
 <p>If you intend to <i>evaluate</i> a function, the function name must be followed by brackets even if the function
 defines no parameters. If your intent was to define a <i>reference</i> to the function (a pattern used commonly in
 'Functional Programming' then the name of the function must be preceded by the keyword <el-kw>ref</el-kw> and a single space.</p>

<h3 id="NotGlobalFunctionRefCompileError" class="no-TOC">Library or class function ... cannot be preceded by by 'ref'</h3>
 <p>The keyword <el-kw>ref</el-kw> may be applied only to functions that you have defined in your own code as a standalone (global) function.
 It may not be applied to a function method defined on a class, nor to a library function.
 (You may, however, define your own function that simply <i>delegates</i> its implementation to a library function.)</p>

<h3 id="UnknownCompilerDirectiveCompileError" class="no-TOC">a comment may not start with [ unless it is a recognised compiler directive</h3>
 <p>Compiler directives are a planned future capability. They will look like comments, but begin with an open square bracket.
 To avoid the possibility of ambiguity, you may not start your own comments with an open square bracket.</p>

<h3 id="mustBeBooleanCondition" class="no-TOC">Condition of 'if' expression does not evaluate to a Boolean.</h3>

<h3 id="mustNotHaveConditionalAfterUnconditionalElse" class="no-TOC">Cannot have any clause after unconditional 'else'.</h3>

<h3 id="mustNotBeKeyword" class="no-TOC">... is a keyword, and may not be used as an identifier.</h3>
 <p>An Elan keyword cannot be used to as the name for a value, property, or method. Try shortening the name, lengthening it, or using a different name</p>
<p>For reference, the complete list of keywords is:<br><el-code>#, abstract, and, as, assert, be, call, catch, class, constant, constructor, cpy, div, each, else, empty, end, enum, exception, for, from, function, if, ignore, image, in, inherits, interface, is, isnt, lambda, let, main, mod, new, not, of, or, out, print, private, procedure, property, record, ref, repeat, return, returns, set, step, test, then, this, throw, to, try, variable, while, with </el-code></p>

<h3 id="mustNotBeReservedWord" class="no-TOC">...  is a reserved word, and may not be used as an identifier.</h3>
 <p>In addition to Elan keywords there are certain other 'reserved words' that cannot be used to define the name for a
 value, property, or method.If you encounter this error you may eliminate the error simply by adding
  more valid characters to the name &ndash; for example just by changing <el-id>case</el-id> to <el-id>case_</el-id>.</p>
 <p>Why are there any reserved words that are not Elan keywords? There are three kinds of reserved word:</p>
 <ul>
  <li><i>Potential</i> keywords that might be added to Elan in future releases.</li>
  <li>Lower case versions of Elan Type names, such as <el-code>int, float, string, boolean, array, list, dictionary</el-code>.
  It is not considered good practice to use Type names for identifiers: instead you should give each identifier a name that indicates
  what it does (for a method), or represents (for a named value).</li>
  <li>Words that are keywords in JavaScript (but not in Elan). Elan compiles to JavaScript and
  use of these words as identifiers could cause errors. (If you are asking, 'Why doesn't the Elan compiler
  just obfuscate these?' the answer is that we evaluated that option but concluded that it added a lot of
  complexity &ndash; especially in regard to debugging and interaction with the Elan editor &ndash; just to eliminate
  the minor inconvenience of having to extend the word so as to make your identifier distinct.)</li>
 </ul>
<p>For reference, the complete list of reserved words is:<br><el-code>action, arguments, array, async, await, boolean, break, by, byte, case, char, const, continue, curry, debugger, default, delete, dictionary, do, double, eval, export, extends, final, finally, float, goto, implements, import, instanceof, int, into, list, long, match, namespace, native, null, on, optional, otherwise, package, partial, pattern, protected, public, short, static, string, super, switch, system, synchronized, throws, todo, transient, typeof, void, volatile, var, when, yield</el-code></p>

<h3 id="mustNotBeNegativeIndex" class="no-TOC">Index cannot be negative.</h3>
 <p>An index into an array or list cannot have a negative value. If a negative is given in literal form e.g.
 <el-code><el-id>a</el-id>[-<el-lit>3</el-lit>]</el-code> then this will generate a compile error.
 If you use a named value for an index and it is negative, then this will cause a runtime error.</p>

<h3 id="CannotCompareProcFunc" class="no-TOC">Cannot do equality operations on Procedures or Functions.</h3>
 <p>It is not possible to apply comparison operations to functions (with or without the <el-kw>ref</el-kw> keyword prefix)
 or procedures as themselves. It is, however, possible to compare the results of two function evaluations.
 It is possible that you are seeing this message because you intended to evaluate a function but forgot to
 add the brackets after the name.</p>

<h3 id="mustBeImmutableType" class="no-TOC">Property ... is not of an immutable type.</h3>
 <p>Properties on a <a href="#record">record</a> may only be of immutable Types.</p>

<h3 id="mustBeImmutableGenericType" class="no-TOC">... cannot be of mutable type ...</h3>
 <p>Element Type for a <a href="LibRef.html#ListImmutable">ListImmutable</a> must itself be an immutable Type.
 Similarly, for an <a href="LibRef.html#DictionaryImmutable">DictionaryImmutable</a> the Types for both the key and the value must be immutable ones.</p>

<h3 id="mustBeValidKeyType" class="no-TOC">... cannot have key of type ...</h3>
 <p>The Type of the key for any dictionary <a href="LibRef.html#Dictionary">Dictionary</a> must be an immutable Type, and not itself an indexable Type.</p>

<h3 id="invalidPropertyInRecordDeconstruction" class="no-TOC">No such property ... on record ...</h3>
 <p>The property name given in the record deconstruction does not match a property on the given Type of record.</p>

<h3 id="discardInRecordDeconstruction" class="no-TOC">Cannot discard in record deconstruction ...</h3>

<h3 id="mustBeCompatibleDefinitionNode" class="no-TOC">Wrong number of deconstructed variables.</h3>

<h3 id="mustBePropertyPrefixedOnMember" class="no-TOC">referencing a property requires a prefix.</h3>
 <p>If you are referring to a property of a class <i>from code defined within the class</i> then the
 property name must be preceded by <el-kw>property</el-kw>.</p>

<h3 id="mustNotBeOutParameter" class="no-TOC">'out' parameters are only supported on procedures.</h3>
 <p>You cannot defined an <el-kw>out</el-kw> parameter in a function (because that would
 imply the possibility of creating a side effect).</p>

<h3 id="mustNotHaveDuplicateMain" class="no-TOC">There can only be one 'main' in a program.</h3>

<h3 id="mustNotBeTwoUnaryExpressions" class="no-TOC">Unsupported operation.</h3>
 <p>You cannot chain two 'unary' operators (those that apply to a single value), such as <el-code>-</el-code>
 or <el-kw>not</el-kw> successively within an expression.</p>

<h3 id="TestTimeout" class="no-TOC">Tests timed out and were aborted</h3>
<p>An error or infinite loop found in a test. Refer to <a href="#TestIgnore">ignoring tests</a>.</p>

<h2>Field help</h2>

<h4 id="ArgListField" class="no-TOC">'arguments' field in a call instruction</h4>
 <p>An argument list passed into a function or procedure call, must consist of one or more arguments separated by commas.
 Each argument may in general be any of:</p>
<ul>
 <li>A literal value</li>
 <li>A named value</li>
 <li>An expression</li>
</ul>
 <p>In certain very specific contexts, however, some options are disallowed by the compiler.</p>

<h3 id="AssertActualField" class="no-TOC">'computed value' field in an assert instruction</h3>
 <p>The 'actual' field should be kept as simple as possible, <i>preferably</i>
 just a named value or a function evaluation. Generally, if you want to use a more
 complex expression, it is better to evaluate it in a preceding <el-kw>let</el-kw>
 instruction and then use the named value in the 'actual' field of the <el-kw>assert</el-kw>
 instruction. Some more complex expressions are permissible, but these two restrictions apply:</p>
 <ul>
  <li>Any expression involving a binary operator such as <el-code>+</el-code>, <el-kw>isnt</el-kw>, etc.,
  must have brackets around it.</li>
  <li>You may <i>not</i> use the <el-kw>is</el-kw> operator within the 'actual' field, because
  the parser will confuse this with the <el-kw>is</el-kw> keyword that is part of the <el-kw>assert</el-kw> instruction.</li>
 </ul>

<h3 id="AssignableField" class="no-TOC">'variable name' field in a set instruction</h3>
 <p>The first field in a <el-kw>set</el-kw> instruction most commonly takes the name of an existing variable.
 It may, however, may also take the following forms:
 <ul>
  <li>Within a <el-kw>class</el-kw> it may take the form <el-kw>property</el-kw><el-code>.</el-code><el-id>name</el-id> to set the property <el-id>name</el-id></li>
  <li>A tuple deconstruction. See <a href="LibRef.html#Tuple">Tuple</a></li>
  <li>A list deconstruction. See <a href="LibRef.html#List">List</a></li>
 </ul></p>

<h3 id="CommentField" class="no-TOC">'comment' field</h3>

<h3 id="ConstantValueField" class="no-TOC">literal value or data structure in a constant</h3>
 <p>The value of a constant must be a literal value of a Type that is not mutable.
 This can be a simple value (e.g. a number or string), or an <i>immutable</i> List or Dictionary.</p>

<h3 id="EnumValuesField" class="no-TOC">'values' field in an enum definition</h3>
 <p><el-kw>enum</el-kw> values must each be a valid identifier, separated by commas.</p>

<h3 id="ExceptionMessageField" class="no-TOC">'message' field in a throw instruction</h3>
 <p>An exception message must  be either a literal string or a named value holding a string.</p>

<h3 id="ExpressionField" class="no-TOC">expression field - used within multiple instructions</h3>
 <p>This field expects an expression. For the various forms of expression see <a href="#Expression">Expressions</a>.</p>

<h3 id="IdentifierField" class="no-TOC">identifier field - used within multiple instructions</h3>

<h3 id="IfSelectorField" class="no-TOC">'if' field in an else clause</h3>

<h3 id="InheritsFromField" class="no-TOC">'inherits ClassName' field in a class</h3>
 <p>An inheritance clause, if used, must consist of the keyword <el-kw>inherits</el-kw>
 followed by a space and then one or more Type names separated by commas.</p>

<h3 id="MethodNameField" class="no-TOC">'name' field in a function or procedure definition</h3>
 <p>A method name must follow the rules for an <a href="#Identifier">identifier</a>.</p>

<h3 id="ParamListField" class="no-TOC">'parameter definitions' in a function or procedure definition</h3>
 <p>Each parameter definition takes the form:</p>
 <el-code><el-id>name</el-id> <el-kw>as</el-kw> <el-type>Type</el-type></el-code>
 <p>The name must follow the rules for an <a href="#Identifier">identifier</a>.</p>
 <p>The Type must follow the rules for a <a href="#parse_type">Type</a>.</p>
 <p>If more than one parameter is defined, the definitions must be separated by commas.</p>

<h3 id="ProcRefField" class="no-TOC">'procedureName' in a call statement</h3>
 <p>Valid forms for a procedure call are
 <ul>
  <li><el-kw>call</el-kw> <el-method>procedureName</el-method>()</li>
  <li><el-kw>call</el-kw> <el-id>instanceName</el-id>.<el-method>procedureMethodName</el-method>()</li>
  <li><el-kw>call</el-kw> <el-kw>property</el-kw>.<el-id>propertyName</el-id>.<el-method>procedureMethodName</el-method>()</li>
  <li><el-kw>call</el-kw> <el-kw>library</el-kw>.<el-method>procedureName</el-method>()</li>
 </ul>
 The last one is used only if there is a need to disambiguate between a library procedure and a user-defined (global)
 procedure with the same name.</p>

<h3 id="TypeField" class="no-TOC">'Type' field in a function or property definition</h3>
 <p>For certain Types the name may be followed by an <el-kw>of</el-kw> clause, for example:</p>
<el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;<br>
<el-type>Dictionary</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>Int</el-type>&gt;

<div id="parse_type"></div>
<h3 id="TypeNameField" class="no-TOC">'Name' field in a class or enum definition</h3>
 <p>Type names always begin with a capital letter, optionally followed by letters of either case, numeric digits,
 or underscore symbols. Nothing else.</p>

<h3 id="ValueDefField" class="no-TOC">'name' field in a let or variable instruction</h3>
 <p>The definition for a variable or for a <el-kw>let</el-kw> statement is most commonly
 a simple <a href="#parse_name">name</a>. Less commonly, it may take the form of:
 <a href="LibRef.html#Tuple">tuple deconstruction</a>, list deconstruction, or <a href="#record_deconstruction">record deconstruction</a>.</p>

<hr>
<p><b>Elan Language Reference</b> go to the <a href="#top">top</a></p>
<script>
  var accordions = document.getElementsByClassName("acc-title");
  for (const item of accordions) {
    item.addEventListener("click", function() {
      item.parentElement.classList.toggle("active");
    });
    item.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        item.parentElement.classList.toggle("active");
      }
    });
  }
</script>
</body>
</html>