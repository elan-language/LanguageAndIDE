<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../styles/colourScheme.css" rel="stylesheet" />
<link href="../styles/documentation.css" rel="stylesheet" />
<link href="../styles/elanStyle.css" rel="stylesheet" />
<title>Elan Language Reference</title>
<script type="text/javascript" src="generated_toc.js"></script>
</head>
<body>
Documents that open in a new tab:<br>
<a href="ElanIndex.html#top" target="_blank">Elan Index and Symbols</a><br>
<a href="LibRef.html#top" target="_blank">Elan Library Reference</a><br>
<a href="IDEguide.html#top" target="_blank">Elan IDE Guide</a>
<div class="docTitle">Elan Language Reference</div>
<div id="docTOC">
<div id="generated-toc" class="generate_from_h1 generate_for_page"></div></div>
<!-- TODO: suggestion -->
<!-- for temporary note of where change is needed -->

<h3 id="Comment" class="no-TOC">Comments</h3>
<p>A comment is not an instruction: it is ignored by the compiler and does not change how the program works.
Rather, a comment contains information <em>about</em> the program, intended to be read by a person seeking to understand or modify the code.</p>
<p>Every comment starts with the symbol <el-code>#</el-code> (known as &lsquo;hash&rsquo;) followed by some text or a blank line. The text field in
a comment may contain any text, except that it must not start with the open-square-bracket symbol - <el-code>[</el-code>.
Comments may be inserted at the same level as a <a href="#Global">global</a>,
<a href="#Member">member</a>, or <a href="#statement">statement</a> instruction, by entering <el-code>#</el-code> from the <el-code>new code</el-code> selector.</p>
<p> Every Elan program has a single comment at the top of the file, which is generated by the system and cannot be edited or deleted by the user.
  This comment is known as the &lsquo; file-header&rsquo; and shows the version of Elan being run.</p>

<h1 id="GlobalInstructions">Global Instructions</h1>
<p>Global instructions (also referred to simply as &lsquo;globals&rsquo;) are located <em>directly</em> within a code file.
  They are never indented from the left-hand edge, nor may they be located <em>within</em> other instructions.
  Three of the globals &ndash; <el-code>main</el-code>, <el-code>function</el-code>, and <el-code>procedure</el-code> &ndash; are described as &lsquo;methods&rsquo; and these are defined by one or more <a href="#statement">statements</a> within them.
  Four of the globals &ndash; <a href="#record"><el-code>record</el-code></a>, <a href="#class"><el-code>class</el-code></a>, <a href="#AbstractClass"><el-code>abstract class</el-code></a>, and <a href="#interface"><el-code>interface</el-code></a> &ndash; define data structures and these always contain <a href="#Member">members</a>.
  The two remaining globals &ndash; <el-code>constant</el-code>, and <el-code>enum</el-code> &ndash; do not contain any further instructions.</p>
<p>When you navigate to a <el-code>new code</el-code> at the <em>global</em> level (not indented from the left-hand edge of the code pane),
you will be shown the 'global selector' listing the set of globals that you may insert there, namely all or only some of:</p>
<p><a href="#main"><el-code>main</el-code></a>
<a href="#Procedure"><el-code>procedure</el-code></a>
<a href="#Function"><el-code>function</el-code></a>
<a href="#Test"><el-code>test</el-code></a>
<a href="#Constant"><el-code>constant</el-code></a>
<a href="#Enum"><el-code>enum</el-code></a>
<a href="#record"><el-code>record</el-code></a>
<a href="#class"><el-code>class</el-code></a>
<a href="#ClassAbs"><el-code>abstract</el-code></a>
<a href="#interface"><el-code>interface</el-code></a>
<a href="#Comment"><el-code>#</el-code></a></p>
where <el-code>abstract</el-code> is, in this context, short for <a href="#AbstractClass"><el-code>abstract class</el-code></a>.

<el-code><el-global class="selected focused ok empty" id="select0" tabindex="0"><el-select><el-txt></el-txt><el-place>new code</el-place></el-select></el-global></el-code>

<p>The specific globals offered will depend upon your user profile.</p>

<h2 id="main">Main</h2>
<p>A program file must have a <el-code>main</el-code> method, sometimes called its main routine, if it is intended to be run as a program. You may, however, develop and test code that does not have a <el-code>main</el-code> method, either as a coding exercise or for subsequent use within another program.</p>
<p>The <el-code>main</el-code> defines the start point when a program is run.</p>
<p>The <el-code>main</el-code> does not have to be at the top of the file, but this is a good convention to follow.</p>
<p>The <el-code>main</el-code> may delegate work to one or more <a href="#procedure"><el-code>procedure</el-code></a> or <a href="#function"><el-code>function</el-code></a>.</p>
<p>There may not be more than one <el-code>main</el-code> in a file &ndash; and the global selector will not show the <el-code>main</el-code> option when one already exists in the file.</p>
Example of a <el-code>main</el-code> method:

<el-code-block source="main.elan">
<main class="multiline" id="main1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw> <el-msg class="warning"></el-msg></el-top>
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="warning" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end main</el-kw></main>
</el-code-block>

<h2 id="procedure">Procedure</h2>
<p id="Argument">A procedure is a named piece of code that can define <b>parameters</b> which are given inputs via <b>arguments</b> in a <el-code>call</el-code> statement.
Unlike a function, a procedure does not return a value.
  Also unlike a function, a procedure can have &lsquo;side effects&rsquo;: indeed it <em>should</em> have side effects, otherwise there would be no point in calling it!
  For this reason the statements within a procedure can:</p>
<ul>
<li>Include <el-code>print</el-code> statements and methods.</li>
<li>include <el-code>input</el-code> methods or other &lsquo;system&rsquo; methods (such as a random number generation).</li>
<li><el-code>call</el-code> other procedures (or itself if <a href="#recursion">&lsquo;recursion&rsquo;</a> is required).</li>
<li>Assign a value to a parameter, provided that the parameter definition is preceded by the keyword <el-code>out</el-code>, as in this example:</li>
</ul>
<el-code-block source="inPlaceRippleSort.elan">
  <el-proc class="ok multiline" id="proc11" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident13" class="ok" tabindex="0"><el-txt>inPlaceRippleSort</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params14" class="optional ok" tabindex="0"><el-txt><el-kw>out</el-kw> <el-id>arr</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
  <el-statement class="ok" id="var15" tabindex="0"><el-kw>variable </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="var18" tabindex="0"><el-kw>variable </el-kw><el-field id="var19" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="repeat21" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
  <el-statement class="ok" id="set24" tabindex="0"><el-kw>set </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="for27" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
  <el-statement class="ok multiline" id="if33" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>] &gt; <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
  <el-statement class="ok" id="let36" tabindex="0"><el-kw>let </el-kw><el-field id="var37" class="ok" tabindex="0"><el-txt><el-id>temp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call39" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>putAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args41" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id>, <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="call42" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident43" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>putAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args44" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id> + <el-lit>1</el-lit>, <el-id>temp</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="set45" tabindex="0"><el-kw>set </el-kw><el-field id="ident46" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr47" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end if</el-kw>
  </el-statement>
  <el-kw>end for</el-kw>
  </el-statement>
  <el-statement class="ok" id="set48" tabindex="0"><el-kw>set </el-kw><el-field id="ident49" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr50" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id> - <el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end repeat when </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>changes</el-id></el-txt><el-place><i>condition</i></el-place></el-field>
  </el-statement>
  <el-kw>end procedure</el-kw>
  </el-proc>
</el-code-block>
<p>Procedures are executed by means of a <a href="#call">call</a> statement, for example:</p>
<el-code-block source="sort.elan">
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h2 id="function">Function</h2>
<p>A <el-code>function</el-code> is a named piece of code that can define <b>parameters</b> which are given inputs via <b>arguments</b> when reference to the function occurs in a statement or expression.</p>
<p>Unlike a <a href="#procedure">procedure</a>, a function returns a value. Also unlike a procedure, a function can have no &lsquo;side effects&rsquo; and cannot depend on any <a href="LibRef.html#SystemMethods">System methods</a>.</p>
<p>The <el-code><el-kw>return</el-kw></el-code> statement is followed by the value returned by the function.</p>
<p>Example of a function:</p>
<el-code-block source="score.elan">
<el-func class="ok multiline" id="func91" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident93" class="ok" tabindex="0"><el-txt>score</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params94" class="optional ok" tabindex="0"><el-txt><el-id>g</el-id> <el-kw>as</el-kw> <el-type>Game</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type95" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return96" tabindex="0"><el-kw>return </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>g</el-id>.<el-id>body</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<div id="as"></div>
<h2 id="Parameters">Parameters</h2>
Parameters for both <el-code>procedures</el-code> and <el-code>functions</el-code> are defined in exactly the same way: each parameter definition takes the form:
<br>&nbsp;&nbsp;&lt;name&gt; <el-code>as</el-code> &lt;Type&gt;
<br> for example:
<el-code-block source="ageAsInt.elan">
<el-field id="params50" class="optional ok" tabindex="0"><el-txt><el-id>age</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>
</el-code-block>

<h2 id="recursion">Recursion</h2>
Procedures and functions may be called or referenced recursively. For example, a simple factorial calculation:
<el-code-block source="factorial.elan">
<el-func class="ok multiline" id="func1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident3" class="ok" tabindex="0"><el-txt>factorial</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params4" class="optional ok" tabindex="0"><el-txt><el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type5" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return6" tabindex="0"><el-kw>return </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt>(<el-kw>if </el-kw><el-id>n</el-id> &gt; <el-lit>1</el-lit><el-kw> then </el-kw><el-id>n</el-id>*<el-method>factorial</el-method>(<el-id>n</el-id> - <el-lit>1</el-lit>)<el-kw><br>else </el-kw><el-lit>1</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h2 id="test">Tests</h2>
<p>A <el-code>test</el-code> is a set of assertions, at the global level, about the output of functions. Example of a <el-code>test</el-code>, from the binary search demo program:</p>

<el-code-block source="test_search.elan">
<el-test class="ok multiline" id="test74" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment76" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>li1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>lime</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert80" tabindex="0"><el-kw>assert </el-kw><el-field id="text81" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert83" tabindex="0"><el-kw>assert </el-kw><el-field id="text84" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let92" tabindex="0"><el-kw>let </el-kw><el-field id="var93" class="ok" tabindex="0"><el-txt><el-id>li2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr94" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert95" tabindex="0"><el-kw>assert </el-kw><el-field id="text96" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert98" tabindex="0"><el-kw>assert </el-kw><el-field id="text99" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr100" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert101" tabindex="0"><el-kw>assert </el-kw><el-field id="text102" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr103" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let104" tabindex="0"><el-kw>let </el-kw><el-field id="var105" class="ok" tabindex="0"><el-txt><el-id>li3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr106" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert107" tabindex="0"><el-kw>assert </el-kw><el-field id="text108" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr109" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert110" tabindex="0"><el-kw>assert </el-kw><el-field id="text111" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr112" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let113" tabindex="0"><el-kw>let </el-kw><el-field id="var114" class="ok" tabindex="0"><el-txt><el-id>li4</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr115" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert116" tabindex="0"><el-kw>assert </el-kw><el-field id="text117" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li4</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr118" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>Elan tests are designed to test functions only. It is not possible to call a <el-code>procedure</el-code> or <el-code>main</el-code> routine within a test. Nor is it possible to use any <a href="#System_methods">System method</a> (the same rule as for a function).</li>
 <li>A test may optionally be given a name or description in free-form text, just like a comment, which plays no role in the execution of the test. You might give the test the same name as a function that it is testing, or you might describe a particular scenario that is being tested.</li>
 <li><el-code>test</el-code> methods may be written anywhere in the code, provided they are at the global level. </li>
 <li>A <el-code>test</el-code> method may contain any number of <el-code>assert</el-code> statements. When tests are run, the test runner (part of the Elan IDE), will attempt to run all <el-code>assert</el-code> statements and show each one's pass or fail outcome alongside. However, if the test hits a runtime error (as distinct from an <el-code>assert</el-code> failure) then execution of the test will stop and remaining <el-code>assert</el-code>s will be shown as &lsquo;not run&rsquo;.</li>
 <li>In addition to <el-code>assert</el-code> statements, a <el-code>test</el-code> may contain any other statements that may be added into a <el-code>function</el-code> (except <el-code>return</el-code>).</li>
 <li>All <el-code>assert</el-code> statements should be at the top level within the <el-code>test</el-code> frame; none may be put into a loop structure.</li>
</ul>

<h4 class="no-TOC">Testing Float values</h4>
<p>When testing <el-code>Float</el-code> values it is recommend that you always use the <el-code>round</el-code> function to round the computed result to a fixed number of decimal places. This avoids rounding errors and is easier to read. For example:</p>

<el-code-block source="test_round.elan">
<el-test class="ok multiline" id="test3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment5" class="optional ok" tabindex="0"><el-txt>round()</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="assert14" tabindex="0"><el-kw>assert </el-kw><el-field id="text15" class="ok" tabindex="0"><el-txt><el-method>sqrt</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.414</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h4 class="no-TOC">Testing for runtime errors</h4>
<p>If the expression you are testing causes a runtime error then the error will be displayed in the red fail message:</p>
<el-code-block source="test_runtime.elan">
<el-test class="error multiline" id="test5" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment7" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let62" tabindex="0"><el-kw>let </el-kw><el-field id="var63" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr64" class="ok" tabindex="0"><el-txt>[<el-lit>5</el-lit>, <el-lit>1</el-lit>, <el-lit>7</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert77" tabindex="0"><el-kw>assert </el-kw><el-field id="text78" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>0</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt><el-lit>5</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert84" tabindex="0"><el-kw>assert </el-kw><el-field id="text85" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>2</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr86" class="ok" tabindex="0"><el-txt><el-lit>7</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert91" tabindex="0"><el-kw>assert </el-kw><el-field id="text92" class="ok" tabindex="0"><el-txt><el-id>a</el-id>[<el-lit>3</el-lit>]</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr93" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="error">actual: Out of range index: 3 size: 3</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<p>If this occurs, mark the tests that you added since the last successful test run with <el-code>ignore</el-code> (see below), and then remove their ignore status one by one until the cause is identified and fixed.</p>

<h4 class="no-TOC" id="ignore">Marking a test with <el-code><el-kw>ignore</el-kw></el-code></h4>
<p>It is possible to mark a <el-code>test</el-code> with the <el-code>ignore</el-code> keyword, by selecting the <el-code>test</el-code> frame and then hitting Ctrl-i, as in this example:</p>

<el-code-block source="test_ignore.elan">
<el-test class="warning multiline" id="test213" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>ignore test </el-kw><el-field id="comment215" class="optional ok" tabindex="0"><el-txt>clockTick</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let216" tabindex="0"><el-kw>let </el-kw><el-field id="var217" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr218" class="ok" tabindex="0"><el-txt><el-method>newGame</el-method>(<el-kw>new</el-kw> <el-type>Random</el-type>())</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let219" tabindex="0"><el-kw>let </el-kw><el-field id="var220" class="ok" tabindex="0"><el-txt><el-id>g2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr221" class="ok" tabindex="0"><el-txt><el-method>newApple</el-method>(<el-id>g1</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let222" tabindex="0"><el-kw>let </el-kw><el-field id="var223" class="ok" tabindex="0"><el-txt><el-id>g3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr224" class="ok" tabindex="0"><el-txt><el-method>clockTick</el-method>(<el-id>g2</el-id>, "<el-lit>s</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert225" tabindex="0"><el-kw>assert </el-kw><el-field id="text226" class="ok" tabindex="0"><el-txt><el-id>g3</el-id>.<el-id>head</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr227" class="ok" tabindex="0"><el-txt><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>16</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="warning">not run</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<p>When a test is marked with <el-code>ignore</el-code>, that test will not be executed when the tests are run, and its result will be shown as &lsquo;not run&rsquo;. The overall test status will also show in the &lsquo;warning&rsquo; status (amber colour), even if all the tests that did run passed. This is to discourage you from leaving a test marked <el-code>ignore</el-code> for long.</p>
<p>The principal reason for marking a test <el-code>ignore</el-code> is when either the test code, or code in any function being called, does not terminate. This typically means that there is a loop (or a recursive call) with no exit condition, or where the exit condition is never met.</p>
<p>If you do create such code without realising it, then when the tests are executed the test runner will &lsquo;time out&rsquo; after a few seconds (most tests will pass in milliseconds), and an error message will be shown in the System info pane. The test that caused the timeout will automatically then be marked <el-code>ignore</el-code>. Your priority should then be to identify the cause of the timeout and attempt to fix it before then restoring the <el-code>test</el-code> by selecting its frame and hitting <el-code>Ctrl-i</el-code> {which is a toggle for setting and unsetting an <el-code>ignore</el-code> status).</p>

<h2 id="constant">Constant</h2>
<p>A <el-code>constant</el-code> defines a named value that cannot change, is always defined at global level (directly within a file), and is global in scope.</p>
<p>A constant is created at compile time, so cannot be defined with reference to any function, nor use any operators.</p>
<p>A constant can be defined as a literal <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>, <el-code><el-type>Boolean</el-type></el-code>,
 <el-code><el-type>String</el-type></el-code>, <el-code><el-type>ListImmutable</el-type></el-code> or <el-code><el-type>DictionaryImmutable</el-type></el-code>.</p>
<p>A constant may not be defined within any method, but see the description of the <a href="#let"><el-code><el-kw>let</el-kw></a></el-code> statement.</p>
<p>The name of a <el-code>constant</el-code> follows the rules for an <a href="#Identifier">Identifier</a>.</p>

<p>Some examples:</p>
<el-code-block source="constants_enum.elan">
<el-const class="ok multiline" id="const5" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-id>phi</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text7" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.618</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const16" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>maxHits</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text18" class="ok" tabindex="0"><el-txt><el-lit>10</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const23" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident24" class="ok" tabindex="0"><el-txt><el-id>warningMsg</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text25" class="ok" tabindex="0"><el-txt>"<el-lit>Limit reached</el-lit>"</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const30" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident31" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text32" class="ok" tabindex="0"><el-txt>{"<el-lit>apple</el-lit>", "<el-lit>orange</el-lit>", "<el-lit>banana</el-lit>"}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const39" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>black</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text41" class="ok" tabindex="0"><el-txt><el-lit>0x000000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const46" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident47" class="ok" tabindex="0"><el-txt><el-id>red</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text48" class="ok" tabindex="0"><el-txt><el-lit>0xff0000</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const75" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident76" class="ok" tabindex="0"><el-txt><el-id>colours</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text77" class="ok" tabindex="0"><el-txt>{<el-type>Suit</el-type>.<el-id>spades</el-id>:<el-id>black</el-id>, <el-type>Suit</el-type>.<el-id>hearts</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>diamonds</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>clubs</el-id>:<el-id>black</el-id>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
<el-const class="ok multiline" id="const65" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident66" class="ok" tabindex="0"><el-txt><el-id>scrabbleValues</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text67" class="ok" tabindex="0"><el-txt>{"<el-lit>A</el-lit>":<el-lit>1</el-lit>, "<el-lit>B</el-lit>":<el-lit>3</el-lit>, "<el-lit>C</el-lit>":<el-lit>3</el-lit>, "<el-lit>D</el-lit>":<el-lit>2</el-lit>, "<el-lit>E</el-lit>":<el-lit>1</el-lit>, "<el-lit>F</el-lit>":<el-lit>4</el-lit>, "<el-lit>G</el-lit>":<el-lit>2</el-lit>, "<el-lit>H</el-lit>":<el-lit>4</el-lit>, "<el-lit>I</el-lit>":<el-lit>1</el-lit>, "<el-lit>J</el-lit>":<el-lit>8</el-lit>, "<el-lit>K</el-lit>":<el-lit>5</el-lit>, "<el-lit>L</el-lit>":<el-lit>1</el-lit>, "<el-lit>M</el-lit>":<el-lit>3</el-lit>, "<el-lit>N</el-lit>":<el-lit>1</el-lit>, "<el-lit>O</el-lit>":<el-lit>1</el-lit>, "<el-lit>P</el-lit>":<el-lit>3</el-lit>, "<el-lit>Q</el-lit>":<el-lit>10</el-lit>, "<el-lit>R</el-lit>":<el-lit>1</el-lit>, "<el-lit>S</el-lit>":<el-lit>1</el-lit>, "<el-lit>T</el-lit>":<el-lit>1</el-lit>, "<el-lit>U</el-lit>":<el-lit>1</el-lit>, "<el-lit>V</el-lit>":<el-lit>4</el-lit>, "<el-lit>W</el-lit>":<el-lit>4</el-lit>, "<el-lit>X</el-lit>":<el-lit>8</el-lit>, "<el-lit>Y</el-lit>":<el-lit>4</el-lit>, "<el-lit>Z</el-lit>":<el-lit>10</el-lit>}</el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
</el-code-block>
<p>In the <el-id>colours</el-id> example, <el-code>Suit</el-code> is an <a href="#Enum_1">Enum</a>.</p>

<h2 id="enum">Enum</h2>
<p>An <el-code>enum</el-code> &ndash; short for &lsquo;enumeration&rsquo; &ndash; is the simplest form of &lsquo;user-defined Type&rsquo;.
It specifies a set of values, each of which is defined as a name, such that a named value of Type <el-code>enum</el-code> necessarily always holds one of those values.</p>
<p><el-code>enum</el-code>s are read-only: once they have been defined it is not possible to add, remove, or update their values.</p>

<p>Some examples:</p>
<el-code-block source="constants_enum.elan">
<el-enum class="ok multiline" id="enum120" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type121" class="ok" tabindex="0"><el-txt><el-type>Suit</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals122" class="ok" tabindex="0"><el-txt><el-id>spades</el-id>, <el-id>hearts</el-id>, <el-id>diamonds</el-id>, <el-id>clubs</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum137" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type138" class="ok" tabindex="0"><el-txt><el-type>Action</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals139" class="ok" tabindex="0"><el-txt><el-id>stand</el-id>, <el-id>draw</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum140" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type141" class="ok" tabindex="0"><el-txt><el-type>Outcome</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals142" class="ok" tabindex="0"><el-txt><el-id>undecided</el-id>, <el-id>win</el-id>, <el-id>lose</el-id>, <el-id>draw</el-id>, <el-id>winDouble</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type144" class="ok" tabindex="0"><el-txt><el-type>Status</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals145" class="ok" tabindex="0"><el-txt><el-id>pending</el-id>, <el-id>playing</el-id>, <el-id>standing</el-id>, <el-id>blackjack</el-id>, <el-id>bust</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
</el-code-block>

<h3 class="no-TOC">Type name</h3>
<p>The name given to an <el-code>enum</el-code> (see below), which must begin with an upper case letter, is used as the Type name when passing a value to or from a procedure or function. </p>

<h3 class="no-TOC">Using an enum</h3>
The value is specified by the Type name for the specified <el-code>enum</el-code>, followed by a dot and the value name, for example:

<el-code-block source="enum_status.elan">
<el-statement class="ok" id="var69" tabindex="0"><el-kw>variable </el-kw><el-field id="var70" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr71" class="ok" tabindex="0"><el-txt><el-type>Status</el-type>.<el-id>pending</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h2 id="record">Record</h2>

<p>A <el-code>record</el-code> is a user-defined data structure that is given a Type name (which must begin with an upper case letter).
  The <el-code>record</el-code> defines one or more properties, each of which has a name (starting with a lower case letter) and a Type.
  The Type of a property may be any simple value Type, or a <el-code>ListImmutable</el-code>, or another Type of <el-code>record</el-code> ( or even the same Type of <el-code>record</el-code>).</p>
  <p>Note that the Type <el-code><el-type>record</el-type></el-code> has some similarity to a <a href="#class"><el-code><el-type>class</el-type></el-code></a> in that:</p>
<ul>
  <li>Both are user-defined data structures</li>
  <li>Both are given a &lsquo;Type name&rsquo;</li>
  <li>Both may define one or more properties, each with a name and Type</li>
  <li>Both may define encapsulated methods</li>
</ul>
<p>However a <el-code>record</el-code> differs  from a <el-code>class</el-code> in that:</p>
 <ul>
  <li>A <el-code>record</el-code> is immutable (like a <el-code>ListImmutable</el-code> or a <el-code>String</el-code>). You can create a copy with specified differences but you cannot modify a <el-code>property</el-code> on a given instance.</li>
  <li>A <el-code>record</el-code> instance may be created or copied using a <el-code>with</el-code> clause, whereas <el-code>with</el-code> may not be used on a class instance.</li>
  <li>A <el-code>record</el-code> does not define a constructor</li>
  <li>A <el-code>record</el-code> may define only <i>function</i> methods, since <i>procedure</i> methods would imply the ability to <i>mutate</i> the record.</li>
</ul>
Examples:
<el-code-block source="record_Square.elan">
<el-class class="ok multiline" id="class203" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type204" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop207" tabindex="0"><el-kw>property </el-kw><el-field id="ident208" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type209" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop210" tabindex="0"><el-kw>property </el-kw><el-field id="ident211" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type212" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
<el-code-block source="record_Game.elan">
<el-class class="ok multiline" id="class168" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type169" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop172" tabindex="0"><el-kw>property </el-kw><el-field id="ident173" class="ok" tabindex="0"><el-txt><el-id>head</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type174" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop175" tabindex="0"><el-kw>property </el-kw><el-field id="ident176" class="ok" tabindex="0"><el-txt><el-id>body</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type177" class="ok" tabindex="0"><el-txt><el-type>ListImmutable</el-type>&lt;<el-kw>of</el-kw> <el-type>Square</el-type>&gt;</el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop178" tabindex="0"><el-kw>property </el-kw><el-field id="ident179" class="ok" tabindex="0"><el-txt><el-id>priorTail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type180" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop181" tabindex="0"><el-kw>property </el-kw><el-field id="ident182" class="ok" tabindex="0"><el-txt><el-id>apple</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type183" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop184" tabindex="0"><el-kw>property </el-kw><el-field id="ident185" class="ok" tabindex="0"><el-txt><el-id>isOn</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type186" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop187" tabindex="0"><el-kw>property </el-kw><el-field id="ident188" class="ok" tabindex="0"><el-txt><el-id>rnd</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type189" class="ok" tabindex="0"><el-txt><el-type>Random</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop190" tabindex="0"><el-kw>property </el-kw><el-field id="ident191" class="ok" tabindex="0"><el-txt><el-id>graphics</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type192" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop193" tabindex="0"><el-kw>property </el-kw><el-field id="ident194" class="ok" tabindex="0"><el-txt><el-id>key</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type195" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
Having defined a record Type, such as <el-code>Game</el-code> above, you can create as many instances as you wish using the following syntax to specify the values:
<el-code-block source="newGame from snake_FP.elan">
<el-statement class="ok" id="let603" tabindex="0"><el-kw>let </el-kw><el-field id="var604" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr605" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Game</el-type>()<el-kw> with </el-kw><br><el-id>head</el-id><el-kw> set to </el-kw><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>15</el-lit>), <br><el-id>key</el-id><el-kw> set to </el-kw>"<el-lit>d</el-lit>", <br><el-id>isOn</el-id><el-kw> set to </el-kw><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<p>Note that you are not <em>required</em> to provide a value for each property because, where a property is not specified in the &lsquo;<el-code>with</el-code> clause&rsquo; (as above), that property will be given the empty (default) value of the correct Type.</p>
<p>You can then read the values from the properties using &lsquo;dot syntax&rsquo; for example:</p>
<el-code-block source=""><el-statement class="" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional" tabindex="0"><el-txt><el-id>sq</el-id>.<el-id>size</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p><el-code><el-kw>record</el-kw></el-code> Types are immutable: the properties on an instance may not be changed, directly.
  However, you can easily create another instance that is a copy of the original,
  with all the same property values except for any specific changes made in another <el-code>with</el-code> clause.
  The newly-minted copy (with changes) must be assigned to a new named value. For example:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>sq1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit>, <br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>1</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="error"></el-msg></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>2</el-lit>.0</el-lit>, <br><el-id>colour</el-id><el-kw> set to </el-kw><el-id>red</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p>Or even to the same name if that name is a variable:</p>
<el-code-block>
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="ok" id="set6" tabindex="0"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>a</el-id><el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>This last example shows how you enter the comma-separated <el-code>with</el-code> clauses. The earlier examples show how the Editor displays a set of <el-code>with</el-code> clauses.</p>

<p>If you want to use one or more existing property values in order to determine a new value, the property names must be prefixed with the name of the instance being copied, for example:</p>
<el-code-block>
  <el-statement class="" id="let9" tabindex="0"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr11" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-id>sq1</el-id>.<el-id>size</el-id> + <el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class=""></el-msg></el-statement>
</el-code-block>

<h4 class="no-TOC" id="record_deconstruction">Record deconstruction</h4>
<p>A record may be &lsquo;deconstructed&rsquo;, meaning that its properties are read into separate variables using the same syntax as for deconstructing a <span class="Link">Tuple</span>. For example, assuming that Square is a record defined as in the example above, then this code:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>y</el-id>, <el-id>size</el-id>, <el-id>colour</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-id>mySquare</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p>will read the <el-code>properties</el-code> into the four names defined.</p>
When deconstructing, the names of the values must match the names of the <el-code>properties</el-code> of the <el-code><el-kw>record</el-kw></el-code>. However, the ordering of the names does not have to match the order in which the <el-code>properties</el-code> are defined in the <el-code><el-kw>record</el-kw></el-code>.

<h2 id="Class">Class</h2>
<!-- TODO Subclass and Superclass -->
<div id="Subclass"></div>
<div id="Superclass"></div>
<p>See also: <a href="Inheritance">Inheritance</a></p>

<p>A <el-code>class</el-code> is a user-defined Type offering far richer capability than an <el-code>enum</el-code>. </p>
<p>Note that a <el-code><el-kw>record</el-kw></el-code> is in some ways similar to a <el-code>class</el-code> but simpler: it defines properties, but has no constructor and no methods. See <a href="">Working with records</a>.</p>

<h4 class="no-TOC">Definition</h4>
<p>Here is an example of <el-code>class</el-code> definition, taken from the Snake OOP demo program:</p>
<el-code-block source="class_Apple.elan">
<el-class class="ok multiline" id="class177" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>class </el-kw><el-field id="type178" class="ok" tabindex="0"><el-txt><el-type>Apple</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text179" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>inherits ClassName(s)</i></el-place></el-field></el-top>
<el-prop class="ok" id="prop181" tabindex="0"><el-kw>property </el-kw><el-field id="ident182" class="ok" tabindex="0"><el-txt><el-id>location</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type183" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-proc class="ok multiline" id="proc184" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident186" class="ok" tabindex="0"><el-txt>newRandomPosition</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params187" class="optional ok" tabindex="0"><el-txt><el-id>snake</el-id> <el-kw>as</el-kw> <el-type>Snake</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
<el-statement class="ok multiline" id="repeat188" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
<el-statement class="ok" id="let191" tabindex="0"><el-kw>let </el-kw><el-field id="var192" class="ok" tabindex="0"><el-txt><el-id>ranX</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr193" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let194" tabindex="0"><el-kw>let </el-kw><el-field id="var195" class="ok" tabindex="0"><el-txt><el-id>ranY</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr196" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set197" tabindex="0"><el-kw>set </el-kw><el-field id="ident198" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr199" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-id>ranX</el-id>, <el-id>ranY</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end repeat when </el-kw><el-field id="expr190" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>snake</el-id>.<el-method>bodyCovers</el-method>(<el-kw>property</el-kw>.<el-id>location</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field>
</el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-func class="ok multiline" id="func200" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident202" class="ok" tabindex="0"><el-txt>updateGraphics</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params203" class="optional ok" tabindex="0"><el-txt><el-id>gr</el-id> <el-kw>as</el-kw> <el-type>BlockGraphics</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type204" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return205" tabindex="0"><el-kw>return </el-kw><el-field id="expr206" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id>.<el-method>updateGraphics</el-method>(<el-id>gr</el-id>, <el-id>red</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
<el-kw>end class</el-kw>
</el-class>
</el-code-block>
<p>A <el-code>class</el-code> must have a name that, like any other Type, begins with an upper case letter.</p>
<p>A class may define:</p>
<ul>
<li>One or more properties &ndash; see <a href="#property">Property</a></li>
<li><el-code>function</el-code> methods &ndash; see <span class="Link">Function method</span></li>
<li><el-code>procedure</el-code> methods &ndash; see <span class="Link">Procedure method</span></li>
<li>a <el-code>constructor</el-code> which may be used for setting up the values of properties. The <el-code>constructor</el-code> may optionally define parameters to force the calling code to provide initial values. However, it is not necessary to add a <el-code>constructor</el-code> if you have no need to initialise properties. Code in the constructor may make use of any functions, and follows the same constraints as a <el-code>function</el-code> (i.e. it may not call any <el-code>procedure</el-code>, whether defined on the <el-code>class</el-code> or outside).</li>
</ul>

<h3 class="no-TOC">Using a class</h3>
<p>A <el-code>class</el-code> is instantiated using the keyword <el-code>new</el-code> followed by the class name and brackets, which should enclose the comma-separated arguments required to match the parameters (if any) defined on the constructor for that <el-code>class</el-code>. For example (also from the Snake OOP demo):</p>
<el-code-block source="constructor.elan">
<el-constructor class="ok multiline" id="constructor41" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params43" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place><el-compl><i>parameter definitions</i></el-compl></el-field>)</el-top>
<el-statement class="ok" id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set47" tabindex="0"><el-kw>set </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>currentDir</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-type>Direction</el-type>.<el-id>right</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set50" tabindex="0"><el-kw>set </el-kw><el-field id="ident51" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>body</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr52" class="ok" tabindex="0"><el-txt>[<el-id>tail</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set53" tabindex="0"><el-kw>set </el-kw><el-field id="ident54" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>head</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-id>tail</el-id>.<el-method>getAdjacentSquare</el-method>(<el-kw>property</el-kw>.<el-id>currentDir</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set56" tabindex="0"><el-kw>set </el-kw><el-field id="ident57" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>priorTail</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr58" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end constructor</el-kw>
</el-constructor>
</el-code-block>
<p>The created instance may then be used within expressions, like any other variable.</p>

<h3 class="no-TOC" id="Inheritance">Inheritance</h3>
  <p>An ordinary <a href="class">class</a> (also known as a &lsquo;concrete class&rsquo;) may optionally inherit from just one <a href="AbstractClass"><el-code>abstract class</el-code></a>
    but may additionally inherit from any number of <a href="interface">interfaces</a>.
    The concrete class must define for itself a concrete implementation of every <em>abstract</em> member defined in the <el-code>abstract class</el-code> or any <el-code>interface</el-code>s that it inherits from, directly or indirectly.</p>

<h4 class="no-TOC">Notes</h4>
<ul>
  <li>An <el-code>abstract class</el-code> must be declared in the code above any class that inherits from it. This is the only case where the order of definition (of global constructs) matters.</li>
  <li>The <el-code>abstract class</el-code> (if any) and the interfaces (if any) that a concrete <el-code>class</el-code> inherits from may not contain duplicates of any <el-code>abstract</el-code> member. Any duplicated definitions in the hierarchy will result in a compile error. If such duplications arise, you should factor out the common member definitions, and move them up the hierarchy or into new <el-code>interface</el-code>s inherited by the<el-code> interface</el-code>s and/or classes that need them.</li>
  <li>Inheritance hierarchies must form a tree, that is you must avoid creating a &lsquo;circular&rsquo; dependency where, for example, Type <el-code>A</el-code> inherits from Type <el-code>B</el-code>, which inherits from Type <el-code> C</el-code>, which inherits from Type <el-code>A</el-code>.</li>
  <li>The various &lsquo;super-Types&rsquo; (abstract classes and <el-code>interface</el-code>s) that a concrete <el-code>class</el-code> inherits from must not define conflicting members, e.g. members with the same name but having different Type signatures.</li>
</ul>

<h2 id="AbstractClass">Abstract class</h2>
<p>See also: <a href="Inheritance">Inheritance</a></p>
<p>An <el-code>abstract class</el-code> may not be instantiated (and hence may not define a constructor). It may define concrete members i.e.:</p>
<ul>
<li>a <el-code><el-kw>property</el-kw></el-code> </li>
<li>a <el-code>function</el-code></li>
<li>a <el-code>procedure</el-code></li>
</ul>
<p>As with a concrete class, any of these members may be made <el-code>private</el-code>, after the corresponding frame has been added, by selecting that member frame and pressing Ctrl-p.</p>
<p>These concrete members are automatically inherited by any subclass, but they may not be overridden (re-defined) by the subclass. Therefore you should define concrete members only if they are intended to work identically on every subclass.</p>
<!-- Need the span below as you can't put two id's on the same element -->
<p id="AbstractFunction"><span id="AbstractProcedure">You</span> may also define abstract methods on an <el-code>abstract class</el-code>, i.e. <el-code>abstract property</el-code>, <el-code>abstract function</el-code>, <el-code>abstract procedure</el-code>. Such methods define only the signature of the method, not the implementation (body), therefore they have no <el-code>end</el-code> statement. For example:</p>
<p><el-code>abstract function calculateDiscount() as Float</el-code></p>
<p>
If you wish to have several subclasses of an <el-code>abstract class</el-code> that share a common implementation for a method, but require that some of the subclasses can define a different implementation, then you should:</p>
<ul>
<li>Define the method as <el-code>abstract</el-code> on the superclass.</li>
<li>Define a concrete implementation on the superclass with a similar, but slightly different, name e.g. by adding a prefix such as: <el-code>default</el-code>.</li>
<li>Each subclass must then define its implementation of the abstract method, but the ones needing a common implementation can be just one line, delegating responsibility up to the &lsquo;default&rsquo; method on the superclass. </li>
</ul>

<h2 id="interface">Interface</h2>
<p>See also: <a href="Inheritance">Inheritance</a></p>
<p>An <el-code>interface</el-code> is similar to an <el-code>abstract class</el-code>, with the difference that it may define only abstract members. The advantage of using an <el-code>interface</el-code> instead of an <el-code>abstract class</el-code> is that a concrete<el-code> class</el-code> can inherit from multiple <el-code>interface</el-code>s.</p>
<p>An <el-code>interface</el-code> may inherit only from other <el-code>interface</el-code>s.</p>
<p>Important: An <el-code>interface</el-code> must not re-declare abstract interfaces that are defined in any <el-code>interface</el-code> it inherits from, directly or indirectly.</p>

<h2 id="global_comment"># (comment)</h2>
<p>See <a href="#Comment">Comments</a>.</p>

<h1 id="MemberInstructions">Member Instructions</h1>
<p>Member instructions (also referred to simply as &lsquo;members&rsquo;) are located directly within the a: <el-code>record</el-code>, <el-code>class</el-code>, <el-code>abstract class</el-code>, <el-code>interface</el-code>.
  All members, with the exception of <el-code>property</el-code>, define one or more <a href="#statement">statements</a> within them.</p>
<p>When you navigate to a <el-code>new code</el-code> that is at <em>member</em> level
  (located directly within a <a href="#record">record</a>, <a href="#class">class</a>, <a href="#AbstractClass"><el-code>abstract class</el-code></a>, or <a href="#interface">interface</a>)
  you will be shown the set of statements that may be inserted there, for example:</p>

  <el-code><el-member class="selected focused ok empty" id="select8" tabindex="0"><el-select><el-txt></el-txt><el-place>new code</el-place></el-select></el-member></el-code>

  <p>The specific members offered will depend upon the context, and/or upon your user profile.
    The full set of entries is shown here, with links to explanations below:</p>

    <a href="#constructor">constructor</a>,
    <a href="#property">property</a>,
    <a href="#procedure">procedure</a>,
    <a href="#function">function</a>,
    <a href="#abstractProperty">abstract property</a>,
    <a href="#abstractProcedure">abstract procedure</a>,
    <a href="#abstractFunction">abstract function</a>,
    <a href="#property">private property</a>,
    <a href="#procedure">private procedure</a>,
    <a href="#function">private function</a>,
    <a href="#Comment">#</a>
<!-- #endregion-->
<!--     #region Constructor-->
<h2 id="constructor">Constructor</h2>
<p>A concrete class <em>may</em> define a single <el-code>constructor</el-code>, which may:</p>
<ul>
<li>initialise any properties with fixed values</li>
<li>define one or more parameters, which are then used to initialise properties</li>
</ul>
<p>If a class does define a constructor, and the constructor defines any parameters, then when the class is instantiated (using <el-code>new</el-code>) then values of
the correct types must be provided, for example, if the class <el-code><el-type>Square</el-type></el-code> defines this constructor:</p>

<el-code-block>
  <el-constructor class="ok multiline" id="constructor211" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params213" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
    <el-statement class="ok" id="set214" tabindex="0"><el-kw>set </el-kw><el-field id="ident215" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>x</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr216" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="set217" tabindex="0"><el-kw>set </el-kw><el-field id="ident218" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>y</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr219" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-kw>end constructor</el-kw>
  </el-constructor>
</el-code-block>

<p>then it may be instantiated like this:</p>

<el-code>
<el-statement id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>

<h2 id="property">Property</h2>
<p>Examples:</p>
<el-code>property height as Int</el-code><br>
<el-code>property board as Board</el-code><br>
<el-code>property head as Square</el-code><br>
<el-code>property body as [Square]</el-code><br>
<ul>
<li>A <el-code><el-kw>property</el-kw></el-code> is defined on a <span class="Link">Class</span> and must <el-code>specify</el-code> a name (conforming to the rules for an <a href="#identifier">Identifier</a>) and a Type.</li>
<li>A <el-code><el-kw>property</el-kw></el-code> may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>If not marked <el-code>private</el-code>, a property may be read but not be written to. Properties may only be modified from outside the class by means of a <span class="Link">Procedure method</span>.</li>
<li>A property may be given an initial value in the <el-code>constructor</el-code>.</li>
</ul>
<p>
If the <el-code><el-kw>property</el-kw></el-code> is not initialised within the constructor then it will automatically be given the <el-code>empty</el-code> value for that Type. You may test whether a property contains this default value by writing e.g.:<br>
<el-code>if head is empty Square</el-code></p>
<ul>
<li>Whenever you wish to access a property from within a method (or from within the constructor) on the same class, then the name of the property must be prefixed with the &lsquo;qualifier&rsquo;: <el-code>property. </el-code>(&lsquo;property-dot&rsquo;). This applies whether you are reading or setting the property. By this means you can have a method parameter with the same name as a property, but they are unambiguous, because the property must be prefixed. A common pattern is to use the same name in a &lsquo;setter&rsquo; method, for example:</li>
</ul>
<el-code>constructor(board as Board)</el-code><br>
<el-code>  set property.board to board</el-code><br>
<el-code>end constructor</el-code><br>
<br>
<el-code>procedure setHeight(height as Int)</el-code><br>
<el-code>  set property.height to height</el-code><br>
<el-code>end procedure</el-code><br>

<h2 id="procedure_method">Procedure Method</h2>
<p>A &lsquo;procedure method&rsquo; follows the same syntax and rules as a global <a href="procedure">procedure</a>. The differences are:</p>
<ul>
<li>A procedure method, like a function method, is always referenced (used) by code outside the class using &lsquo;dot syntax&rsquo; on an instance.</li>
<li>A procedure method may read, or write to, any <el-code><el-kw>property</el-kw></el-code> defined on the class.</li>
<li>A procedure method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
</ul>

<h2 id="function_method">Function Method</h2>
<p>A function method follows the same syntax and rules as a global <a href="function">function</a>. The differences are:</p>
<ul>
<li>A <el-code>function</el-code> method is always referenced (used) by code outside the class using &lsquo;dot syntax&rsquo; on an instance.</li>
<li>A <el-code>function</el-code> method may directly reference (read only) any <el-code><el-kw>property</el-kw></el-code> defined on the class as though it were a variable/parameter.</li>
<li>A <el-code>function</el-code> method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then pressing Ctrl-p. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li>asString() method</li>
<li>asString method. This is just a regular function method with a specific name, no parameters and returning a String. If defined for a class, then if an instance of the class is printed, the <el-code>asString</el-code> function method will automatically be used. Typically <el-code>asString</el-code> will return a string made up of one or more of the property values, perhaps with additional text, or the results of function calls.</li>
</ul>

<h2 id="AbstractProperty">Abstract Property</h2>
<p>An abstract property may be defined only on an <a href="#AbstractClass"><el-code>abstract class</el-code></a>. Any concrete sub-class must then implement a concrete (regular) property to match.</p>

<h2 id="AbstractProcedureMethod">Abstract Procedure Method</h2>
<p>An abstract procedure method may be defined only on an <a href="#AbstractClass"><el-code>abstract class</el-code></a>. Any concrete sub-class must then implement a concrete (regular) property to match.</p>

<h2 id="abstractFunctionMethod">Abstract Function Method</h2>
<p>An abstract function method may be defined only on an <a href="#AbstractClass"><el-code>abstract class</el-code></a>. Any concrete sub-class must then implement a concrete (regular) property to match.</p>

<h2 id="member_comment"># (comment)</h2>
<p>See <a href="#Comment">Comments</a>.</p>

<h1 id="StatementInstructions">Statement Instructions</h1>
<p>Statement instructions (also referred to simply as &lsquo;statements&rsquo;) are located within &lsquo;methods&rsquo;. Some of these statements may contain other statements.</p>
<p>When you navigate to a <el-code>new code</el-code> that is at <em>statement</em> level
  (located within a <a href="#Global">global</a> or a <a href="#Member">member</a> instruction)
  you will be shown the set of statements that may be inserted there, for example:</p>

  <el-code><el-statement class="selected focused ok empty" id="select4" tabindex="0"><el-select><el-txt></el-txt><el-place>new code</el-place></el-select></el-statement></el-code>

  <p>The specific statements offered will depend upon the context, and/or upon your user profile.
    The full set of entries is shown here, with links to explanations below:</p>

<a href="LibRef.html#assert">assert</a>
<a href="#call">call</a>
<a href="#each">each</a>
<a href="#else">else</a>
<a href="#for">for</a>
<a href="#if">if</a>
<a href="#let">let</a>
<a href="#print">print</a>
<a href="#repeat">repeat</a>
<a href="#set">set</a>
<a href="#throw">throw</a>
<a href="#try">try</a>
<a href="#variable">variable</a>
<a href="#while">while</a>
<a href="#Comment">#</a>

<h2 id="assert">Assert statement</h2>

<h2 id="call">Procedure call</h2>

<h2 id="each">Each loop</h2>
<p>The <el-code>each..in..</el-code> construct specifies looping sequentially over the elements in a <el-code><el-type>List</el-type></el-code> or  an <el-code><el-type>Array</el-type></el-code>, or over the characters in a <el-code><el-type>String</el-type></el-code>.</p>
<p>The <el-code>each..</el-code> loop counter variable (which counts from 0) is of Type <el-code><el-type>Int</el-type></el-code> and does not have to have been defined in a <el-code>variable</el-code> statement.</p>
<p>Example:</p>
<el-code-block source="each.elan">
<el-statement class="ok" id="var16" tabindex="0"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt>["<el-lit>Tom</el-lit>", "<el-lit>Dick</el-lit>", "<el-lit>Harriet</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print30" tabindex="0"><el-kw>print </el-kw><el-field id="expr31" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-lit>0</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="each19" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>each </el-kw><el-field id="ident21" class="ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> in </el-kw><el-field id="expr22" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>source</i></el-place></el-field></el-top>
<el-statement class="ok" id="print23" tabindex="0"><el-kw>print </el-kw><el-field id="expr24" class="optional ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end each</el-kw>
</el-statement>
</el-code-block>

<h2 id="for">For loop</h2>
<div id="step"></div>
<p>The <el-code>for..from..to..step..</el-code> construct specifies looping through a sequence of integer values with a given increment.</p>
<p>The <el-code>for..</el-code> loop counter variable (which counts from 0) is of Type <el-code><el-type>Int</el-type></el-code> and does not have to have been defined in a <el-code>variable</el-code> statement.</p>
<p>The three defining values, <el-code>from</el-code>, <el-code>to</el-code>, and <el-code>step</el-code>, must all be of Type <el-code><el-type>Int</el-type></el-code>, positive or negative.
and may be defined by literals, variables  or expressions that evaluate to integers.</p>
<p>Note that, if you require a negative step value, then the literal, variable, or expression must start with a negative sign.
This is needed at compile time to determine the nature of the exit condition.
So if you have a variable <el-code>s</el-code> that holds a negative value to be used to step in reverse order, then you would write:</p>
<el-code-block source="forStepNeg.elan">
<el-statement class="ok" id="var16" tabindex="0"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt>["<el-lit>Tom</el-lit>", "<el-lit>Dick</el-lit>", "<el-lit>Harriet</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var40" tabindex="0"><el-kw>variable </el-kw><el-field id="var41" class="ok" tabindex="0"><el-txt><el-id>s</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr42" class="ok" tabindex="0"><el-txt>-<el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="for34" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident36" class="ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr37" class="ok" tabindex="0"><el-txt><el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr39" class="ok" tabindex="0"><el-txt>-(-<el-id>s</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="print43" tabindex="0"><el-kw>print </el-kw><el-field id="expr44" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-id>n</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<h2 id="if_statement">If statement</h2>
<p>See also <a href="if_expression">if expression</a></p>
<p>The <el-code>if..then..else..</el-code> and <el-code>if..then..else if..else..</el-code> constucts specify which of several code sequences is to be executed next.</p>
<p>The <el-code>else</el-code> clause is optional.</p>
<p>You can add as many <el-code>else if</el-code> clauses as you wish, but only one unconditional <el-code>else</el-code> (which, if present, must be the last clause).</p>

Example 1:
<el-code-block source="if_else">
<el-statement class="ok multiline" id="if71" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr73" class="ok" tabindex="0"><el-txt><el-id>head</el-id><el-kw> is </el-kw><el-id>apple</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="call80" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident81" class="ok" tabindex="0"><el-txt><el-method>setAppleToRandomPosition</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args82" class="optional ok" tabindex="0"><el-txt><el-id>apple</el-id>, <el-id>body</el-id></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok outdent" id="else83" tabindex="0"><el-top>
<el-kw>else </el-kw><el-field id="elif85" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
<el-statement class="ok" id="call86" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident87" class="ok" tabindex="0"><el-txt><el-id>body</el-id>.<el-method>removeAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args88" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>

Example 2:
<el-code-block source="if_else">
<el-statement class="ok multiline" id="if135" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr137" class="ok" tabindex="0"><el-txt><el-id>item</el-id><el-kw> is </el-kw><el-id>value</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="set157" tabindex="0"><el-kw>set </el-kw><el-field id="ident158" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr159" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok outdent" id="else174" tabindex="0"><el-top>
<el-kw>else </el-kw><el-kw>if </el-kw><el-field id="expr175" class="ok" tabindex="0"><el-txt><el-id>item</el-id>.<el-method>isBefore</el-method>(<el-id>value</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top></el-statement>
<el-statement class="ok" id="set195" tabindex="0"><el-kw>set </el-kw><el-field id="ident196" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr197" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>lst</el-id>[..<el-id>mid</el-id>], <el-id>item</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok outdent" id="else198" tabindex="0"><el-top>
    <el-kw>else </el-kw><el-field id="elif200" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
<el-statement class="ok" id="set201" tabindex="0"><el-kw>set </el-kw><el-field id="ident202" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr203" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>lst</el-id>[<el-id>mid</el-id> + <el-lit>1</el-lit>..], <el-id>item</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>

<h2 id="let">Let statement</h2>
<p>The <el-code><el-kw>let</el-kw></el-code> statement may be thought of as being between a constant and a variable.
Like a variable a <el-code><el-kw>let</el-kw></el-code>  may be defined only within a routine, but unlike a variable it may not be re-assigned once defined.
It is recommended that you always use a let in preference to a variable unless you need to be able to assign a new value to it.
</p>
<p>You can put a <el-code><el-kw>let</el-kw></el-code> in a loop, so the variable gets a new value each time it is executed, but the value of the variable cannot be changed any other way.</p>

<h2 id="print">Print statement</h2>
<p>The simplest way to print is with the <el-code>print</el-code> statement. For example:</p>
<el-code-block>
    <el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt>"<el-lit>Hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="let7" tabindex="0"><el-kw>let </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-lit>4</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id>*<el-id>b</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional ok" tabindex="0"><el-txt>"<el-lit></el-lit>{<el-id>a</el-id>}<el-lit> times </el-lit>{<el-id>b</el-id>}<el-lit> equals </el-lit>{<el-id>a</el-id>*<el-id>b</el-id>}<el-lit></el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h4 class="no-TOC">Note</h4>
<ul>
<li>The last line in the example above uses an <a href="LibRef.html#InterpolatedString">interpolated strings</a>. Arguments placed within curly braces are evaluated before printing, and these may be separated by literal text and punctuation as needed. This is one recommended way to print more than one value on a line. The other way is to use print procedures.</li>
</ul>

<h2 id="repeat">Repeat loop</h2>

<h2 id="set">Set statement</h2>
<p>
The <el-code><el-kw>set</el-kw></el-code> statement is used to assign a new value to an existing variable.
The new value must be of the same Type as (or a Type compatible with) that of the variable.
A <el-code><el-kw>set</el-kw></el-code> statement may not assign a new value to a parameter within a procedure.</p>

<h2 id="throw">Throw statement</h2>
<p>If you are in mode <i>Advanced level coding</i> (see <a href="IDEguide.html#preferences">Preferences</a>), you can deliberately generate, or &lsquo;throw&rsquo;, an exception when a specific circumstance is identified, using a <el-code>throw</el-code> statement, for example:</p>
<el-code>throw exception "something has happened"</el-code><br>

<h2 id="try">Try statement</h2>
<p>If you are in mode <i>Advanced level coding</i> (see <a href="IDEguide.html#preferences">Preferences</a>), you can test whether another piece of code might throw an exception by wrapping it in a <el-code>try</el-code> statement. This might arise when calling a <a href="#System_methods">System method</a> that is dependent upon external conditions, for example:</p>

<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try18" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call38" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident39" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args40" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print47" tabindex="0"><el-kw>print </el-kw><el-field id="expr48" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch20" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok" id="print64" tabindex="0"><el-kw>print </el-kw><el-field id="expr65" class="optional ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>
The variable holding the exception (by default named <el-code>e</el-code>, but this may be changed by you) is of Type <el-code><el-type>String</el-type></el-code>. You can compare the exception message to one or more expected messages and, if the message does not match an expected exception, you may choose to throw the exception 'up', as in this example:
<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try141" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call158" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident159" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args160" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print177" tabindex="0"><el-kw>print </el-kw><el-field id="expr178" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident145" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok multiline" id="if211" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr213" class="ok" tabindex="0"><el-txt><el-id>e</el-id><el-kw> isnt </el-kw>"<el-lit>an expected message</el-lit>"</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="throw234" tabindex="0"><el-kw>throw exception </el-kw><el-field id="msg235" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>message</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>

<h2 id="variable">Variable statement</h2>

<h2 id="while">While loop</h2>

<h2 id="statement_comment"># (comment)</h2>
<p>See <a href="#Comment">Comments</a>.</p>

<h1 id="Expression">Expressions</h1>
<p>One of the most important constructs in programming is the &lsquo;expression&rsquo;. An expression is evaluated to return a value. An expression is made up of the following possible elements:</p>
<ul>
<li>Literal value</li>
<li>Named value</li>
<li>Operator (including brackets)</li>
<li>Function call</li>
</ul>
<p>which this chapter describes.</p>

<h2 id="LiteralValue">Literal value</h2>
<p>A literal value is where a value is written &lsquo;literally&rsquo; in the code, such as <el-code>3.142</el-code> &ndash; in contrast to a value that is referred to by a name.</p>
<p>The following data Types may be written as literal values (follow the links to view the form of each literal value):</p>
<el-code><a href="#Int">Int</a>, <a href="#Float">Float</a>, <a href="#Boolean">Boolean</a>, <a href="#String">String</a>, <a href="#List">List</a>, <a href="#ListImmutable">ListImmutable</a>, <a href="#Dictionary">Dictionary</a>, <a href="#DictionaryImmutable">DictionaryImmutable</a>, <a href="#Tuple">Tuple</a></el-code><br>

<h2 id="named_value">Named value</h2>
<p>A named value is a value that is associated with a name rather than being defined literally in code. There are various kinds of named value:</p>
<p><a href="#Constant">Constants</a>, <span class="Hyperlink"><a href="#Let_statement_1">let</a></span> statement, <span class="Hyperlink"><a href="#Variables">variable</a></span> statement, <a href="#Parameter_passing_1">Parameter passing</a>, <span class="Hyperlink"><a href="#Enum_1">enum</a></span> statement.
  Once a named value has been defined, it can be referred to by the name.</p>

<h2 id="Identifier">Identifier</h2>
<p>For all kinds of named values, the name must follow the rules for an &lsquo;identifier&rsquo;.
  It must start with a lower case letter, followed by any combination of lower case and upper case letters,
   numeric digits, and the _ (underscore) symbol.
   It may not contain spaces or other symbols.</p>

<h2 id="scoping">Scoping and name qualification</h2>
<p>With the exception of a <el-code>constant</el-code> (below), which is global in scope, named values are always &lsquo;local&rsquo;: their scope is confined to the method in which they are defined. </p>
<p>Elan allows local named values to be defined with the same name as a constant, function, or procedure defined at global level or defined in the standard library. In such cases, when the name is used within the same method, then it will refer to the local definition. If you have done this, but then need to access the <el-code>constant</el-code>, <el-code>function</el-code>, or <el-code>procedure</el-code> with the same name, then you can simply prefix the use of the name with a &lsquo;qualifier&rsquo; of either <el-code>global.</el-code> or <el-code>library.</el-code> as appropriate.</p>

<h2 id="IndexedValue">Indexed Value</h2>
If a variable is of an indexable Type, then an index or index range may be applied to the variable within an expression. For example:
<pre>
    <el-code>variable a set to "Hello World!"</el-code>
    <el-code>print a[4]</el-code>        &rarr; <el-code>o</el-code>
    <el-code>print a[4..]</el-code>    &rarr; <el-code>o World!</el-code>
    <el-code>print a[..7]</el-code>    &rarr; <el-code>Hello W</el-code>   (since the upper bound of a range is <em>exclusive</em>)
    <el-code>print a[0..4]</el-code>  &rarr; <el-code>Hell</el-code>         (for the same reason)
</pre>
<p>See also: <a href="#Using_a_List">Using an List</a>, <a href="#Using_a_Dictionary">Using a Dictionary</a></p>
<p>Important: unlike in many languages, indexes in Elan (whether, single, multiple, or a range) are only ever used for <em>reading</em> values.
Writing a value to a specific index location is done through a method such as in these examples:</p>
<pre>
    <el-code>putAt</el-code>            on a   <el-code>List</el-code>
    <el-code>withPut</el-code>        on a    <el-code>ListImmutable</el-code>
    <el-code>putAtKey</el-code>      on a    <el-code>Dictionary</el-code>
    <el-code>withPutKey</el-code>  on a    <el-code>DictionaryImmutable</el-code>
</pre>

<h2 id="Operators">Operators</h2>

<h4 class="no-TOC" id="ArithmeticOperators">Arithmetic operators</h4>
<p>Arithmetic operators can be applied to <el-code>Float</el-code> or <el-code>Int</el-code> arguments. The result may be a <el-code>Float</el-code> or an <el-code>Int</el-code> depending on the arguments.</p>
<p>For <el-code>^ + - *</el-code>, the result is a <el-code>Float</el-code> if either of the arguments is a <el-code>Float</el-code>, and an <el-code>Int</el-code> if both arguments are <el-code>Int</el-code>.</p>
<p>For <el-code>/</el-code>, the result is always a <el-code>Float</el-code>.  It can be converted to an <el-code>Int</el-code> using the <a href="LibRef.html#floor">floor()</a> function.</p>
<p id="mod"><el-code>mod</el-code> and <el-code>div</el-code> only operate on <el-code>Int</el-code> arguments, and the result is <el-code>Int</el-code>.
<pre>
    <el-code>2^3</el-code>             &rarr;  <el-code>8</el-code>
    <el-code>2/3</el-code>             &rarr;  <el-code>0.666...</el-code>
    <el-code>2*3</el-code>             &rarr;  <el-code>6</el-code>
    <el-code>2 + 3</el-code>         &rarr;  <el-code>5</el-code>
    <el-code>2 - 3</el-code>         &rarr;  <el-code>-1</el-code>
    <el-code>11 mod 3</el-code>   &rarr;  <el-code>2</el-code> (integer remainder)
    <el-code>11 div 3</el-code>   &rarr;  <el-code>3</el-code> (integer division)
</pre>
<p>Arithmetic operators follow the conventional rules for precedence i.e. &lsquo;BIDMAS&rsquo; (or &lsquo;BODMAS&rsquo;).</p>
When combining <el-code>div</el-code> or <el-code>mod</el-code> with any other operators within an expression, insert brackets to avoid ambiguity e.g.:</p>
<pre>
    <el-code>(5 + 6) mod 3</el-code>
</pre>
<p>Note that <el-code>mod</el-code> is more of a remainder operator than a modulus operator -- the result takes the sign of the first argument.  If both arguments are positive, there is no difference.</p>
The minus sign may also be used as a unary operator, and this takes precedence over binary operators so:
<pre>
    <el-code>2*-3</el-code>           &rarr;  <el-code>-6</el-code>
</pre>
<p>Note that the Elan editor automatically puts spaces around the <el-code>+</el-code> and <el-code>&ndash;</el-code> binary operators, but not around <el-code>^</el-code>, <el-code>/</el-code> or <el-code>*</el-code>. This is just to visually reinforce the precedence.</p>
<p>The <el-code>div</el-code> operator rounds its result down, as if with the <el-method>floor</el-method> function.  This can give unexpected results with negative numbers, for example:</p>
<pre>
    <el-code>11 div -3</el-code>   &rarr;  <el-code>-4</el-code>
</pre>
<p>The <el-code>+</el-code> operator is also used for concatenating <el-type>String</el-type>s.  See <a href="LibRef.html#String">String</a>.</p>

<h4 class="no-TOC" id="LogicalOperators">Logical operators</h4>
<!-- TODO table of logical operators -->
<div id="and"></div>
<div id="not"></div>
<div id="or"></div>
<p>Logical operators are applied to <el-code>Boolean</el-code> arguments and return a <el-code>Boolean</el-code> result.</p>
<p><el-code>and</el-code> and <el-code>or</el-code> are binary operators<br>
<el-code>not</el-code> is a unary operator. </p>
<p>The operator precedence is <el-code>not</el-code> &rarr; <el-code>and</el-code> &rarr; <el-code>or</el-code>, so this
example, which implements an &lsquo;exclusive or&rsquo;, need not use brackets and can rely on the operator precedence:</p>

<el-code-block source="xor.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>xor</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type>, <el-id>b</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>a</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>b</el-id><el-kw> or </el-kw><el-id>b</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>a</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw></el-func>
</el-code-block>

<h4 class="no-TOC" id="EqualityTesting">Equality testing</h4>
<p>Equality testing uses the <el-code>is</el-code> and <el-code>isnt</el-code> keywords with two arguments. The arguments may be of any Type.</p>
<ul>
<li><el-code> a is b</el-code> returns <el-code>true</el-code>, if <el-code>a</el-code> and <el-code>b</el-code> are both of the same Type and their values are equal. The only exception is that if one argument is of Type <el-code>Float</el-code> and the other is of Type <el-code>Int</el-code>, then <el-code>is</el-code> will return <el-code>true</el-code> if their values are the same, i.e. are the same whole number.</li>
<li><el-code>isnt</el-code> returns the opposite of <el-code>is</el-code>.</li>
<p>Note that in Elan equality testing is always &lsquo;equality by value&rsquo;; there is no such thing as &lsquo;equality by reference&rsquo;.</p>
<li>Where a binary operator is expected, as soon as you type <el-code>is</el-code> the editor will automatically insert a space after it. To enter <el-code>isnt</el-code> you need to delete the space (using the Backspace key) and then type <el-code>nt</el-code>.</li>
</ul>

<h4 class="no-TOC">Numeric comparison</h4>
<p>The numeric comparison operators are:</p>
<pre>
    <el-code>&gt; </el-code>        for     greater than
    <el-code>&lt; </el-code>        for     less than
    <el-code>&gt;=</el-code>        for     greater than or equal to
    <el-code>&lt;=</el-code>        for     less than or equal to
</pre>
<p>Each is applied to two arguments of Type <el-code>Float</el-code>, but any variable or expression that evaluates to an <el-code>Int</el-code> may always be used where a <el-code>Float</el-code> is expected.</p>
Notes:
<ul>
<li>These operators cannot be applied to strings. Use the dot methods <el-code>isBefore</el-code> and <el-code>isAfter</el-code> to compare strings alphabetically.
 See <a href="LibRef.html#isAfter">Dot methods on a String</a>.</li>
<li>Where a binary operator is expected, as soon as you type <el-code>&lt; </el-code>or <el-code>&gt;</el-code> the editor will automatically insert a space after it. To enter <el-code>&lt;=</el-code> or <el-code>&gt;=</el-code> you need to delete the space (using the Backspace key) and then type <el-code>=</el-code>.</li>
</ul>

<h4 class="no-TOC">Combining operators </h4>
<p>You can combine operators of different kinds, e.g. combining numeric comparison with logical operators in a single expression. However the rules of precedence between operators of different kinds are complex. It is strongly recommend that you always use brackets to disambiguate such expressions, for example:</p>

<el-code-block source="combiningOperators.elan">
<el-field id="expr19" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> &gt; <el-id>b</el-id>)<el-kw> and </el-kw>(<el-id>b</el-id> &lt; <el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
<br>
<el-field id="expr35" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> + <el-id>b</el-id>) &gt; (<el-id>c</el-id> - <el-id>d</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
</el-code-block>

<h2 id="function_call">Function call</h2>
An expression may simply be a function call, or it may include one or more function calls within it. Examples:
<el-code-block source="sinDeg.elan">
<el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var7" tabindex="0"><el-kw>variable </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit> + <el-method>cosDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var10" tabindex="0"><el-kw>variable </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>name</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>inputString</el-method>("<el-lit>Your name</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>name</el-id>.<el-method>upperCase</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
Notes:
<ul>
<li>The third example above is not strictly a function call, but is a &lsquo;system method&rsquo; call.
System methods may be used only within the <el-code>main</el-code> routine or a <el-code>procedure</el-code>, because they have external dependencies or side effects.</li>
<li>In the fourth example, <el-code>upperCase</el-code> is a &lsquo;dot method&rsquo; that may be applied to any instance (variable or literal) of Type <el-code>String</el-code>.
See <span class="Link">Dot methods on a String</span>.</li>
</ul>

<h2 id="lambda">Lambda</h2>
<p>A <el-code><el-kw>lambda</el-kw></el-code> is a lightweight means to define a function &lsquo;in line&rsquo;. You typically define a <el-code>lambda</el-code>:</p>
<ul>
<li>If the functionality it defines is needed in only one location: typically for a particular call to a <a href="LibRef.html#HoFs">Higher order Function</a> (HoF).</li>
<li>If you need to capture a local variable in the implementation. This is called &lsquo;closing around a variable&rsquo;.</li>
</ul>
<p>The syntax for a <el-code><el-kw>lambda</el-kw></el-code> is as follows:</p>
<ul>
<li>Start with the keyword <el-code><el-kw>lambda</el-kw></el-code>.</li>
<li>Parameter definitions, comma-separated, follow the same form as parameter definitions in a function or procedure, but without surrounding brackets.</li>
<li>The <el-code>=&gt;</el-code> symbol, which is usually articulated as &lsquo;returns&rsquo;,  &lsquo;yields&rsquo; or even &lsquo;fat arrow&rsquo;.</li>
<li>An expression that makes use of the parameters, and may also make use of other variables that are in scope. </li>
</ul>
Example:
<el-code-block source="liveNeighbours.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>liveNeighbours</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>cells</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Boolean</el-type>&gt;, <el-id>c</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>neighbourCells</el-method>(<el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let13" tabindex="0"><el-kw>let </el-kw><el-field id="var14" class="ok" tabindex="0"><el-txt><el-id>live</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr15" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id>.<el-method>filter</el-method>(<el-kw>lambda</el-kw> <el-id>i</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>cells</el-id>[<el-id>i</el-id>])</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>live</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw> </el-func>
</el-code-block>
Notes:
<ul>
<li>Although a <el-code><el-kw>lambda</el-kw></el-code> is commonly defined &lsquo;inline&rsquo; (as shown above) it is possible to assign a lambda to a variable and hence to re-use it within the scope of that variable.</li>
</ul>

<h2 id="if_expression">If expression</h2>
The &lsquo;if expression&rsquo; is in certain respects similar to an <span class="Link">If statement</span>, but with the following differences:
<ul>
<li>It is written entirely within a single expression. This is possible because the <el-code>if</el-code> expression always returns a value.</li>
<li>There is always a single <el-code>then</el-code> and a single <el-code>else</el-code> clause, and each clause contains just a single expression. The <el-code>if</el-code> expression returns the result of evaluating one of these two expressions, according to whether the condition evaluates to <el-code>true</el-code> or <el-code>false</el-code>.</li>
</ul>
<p>Here are three examples:</p>
<el-code-block source="if_expression.elan">
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>c</el-id> &lt; <el-lit>1160</el-lit><el-kw> then </el-kw><el-id>c</el-id> + <el-lit>40</el-lit><el-kw><br>else </el-kw><el-id>c</el-id> - <el-lit>1160</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<br>
<el-statement class="ok" id="return25" tabindex="0"><el-kw>return </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-method>isGreen</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw> then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>*</el-lit>")<el-kw><br>else </el-kw><el-id>attempt</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<br>
<el-statement class="ok" id="return104" tabindex="0"><el-kw>return </el-kw><el-field id="expr105" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>attempt</el-id>[<el-id>n</el-id>]<el-kw> is </el-kw>"<el-lit>*</el-lit>"<el-kw> then </el-kw><el-id>attempt</el-id><el-kw><br>else </el-kw><el-kw>if </el-kw><el-method>isYellow</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw> then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>+</el-lit>")<el-kw><br>else </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>_</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h2 id="new">New instance</h2>
<p>A 'new instance' expression is used to create a new instance of a <a href="LibRef.html#StandardDataStructures">library data structure</a>,
   or a <a href="#class"> user-defined class</a> or <a href="#record">record</a> - either to assign to a named value, or as part
  of a more complex expression. Example of use (taken from the `Snake - procedural` demo):</p>

<el-code-block>
<el-statement id="var5" tabindex="0"><el-kw>let </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>blocks</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Array2D</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;(<el-lit>40</el-lit>, <el-lit>30</el-lit>, <el-id>white</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>Where the new instance is of a <a href="class"> user-defined class</a> or <a href="record">record</a> the expression may optionally
be followed by a 'with clause` in order to specify any property values. Example of this use:</p>

<el-code-block source="dealCard.elan">
<el-func id="func302" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident304" class="ok" tabindex="0"><el-txt>dealCard</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params305" class="optional ok" tabindex="0"><el-txt><el-id>random</el-id> <el-kw>as</el-kw> <el-type>Float</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type306" class="ok" tabindex="0"><el-txt><el-type>Card</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
  <el-statement class="ok" id="let309" tabindex="0"><el-kw>let </el-kw><el-field id="var310" class="ok" tabindex="0"><el-txt><el-id>number</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr311" class="ok" tabindex="0"><el-txt>(<el-id>random</el-id>*<el-lit>52</el-lit>).<el-method>floor</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let312" tabindex="0"><el-kw>let </el-kw><el-field id="var313" class="ok" tabindex="0"><el-txt><el-id>rank</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr314" class="ok" tabindex="0"><el-txt><el-id>rankValue</el-id>.<el-method>keys</el-method>()[<el-id>number</el-id><el-kw> div </el-kw><el-lit>4</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let315" tabindex="0"><el-kw>let </el-kw><el-field id="var316" class="ok" tabindex="0"><el-txt><el-id>suit</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr317" class="ok" tabindex="0"><el-txt><el-id>number</el-id><el-kw> mod </el-kw><el-lit>4</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="return307" tabindex="0"><el-kw>return </el-kw><el-field id="expr308" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Card</el-type>()<el-kw> with </el-kw><br><el-id>rank</el-id><el-kw> set to </el-kw><el-id>rank</el-id>, <br><el-id>suit</el-id><el-kw> set to </el-kw><el-id>suit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end function</el-kw>
  </el-func>
</el-code-block>

<h2 id="copy_with">Copy with</h2>
<p>A 'copy with' expression is used to make a copy of an existing instance, but with a different value for one or more of the properties
  - either to assign to a named value, or as part of a more complex expression..
It is used extensively within 'functional programming' where you are dealing with<a href="#record">record</a>s or other <i>immutable</i> types.
Example of use in this manner (taken from the 'Snake - functional' demo program):</p>

<el-code-block>
<el-func class="ok multiline" id="func72" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident74" class="ok" tabindex="0"><el-txt>newApple</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params75" class="optional ok" tabindex="0"><el-txt><el-id>g</el-id> <el-kw>as</el-kw> <el-type>Game</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type76" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
  <el-statement class="ok" id="let79" tabindex="0"><el-kw>let </el-kw><el-field id="var80" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>rnd2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr81" class="ok" tabindex="0"><el-txt><el-id>g</el-id>.<el-id>rnd</el-id>.<el-method>nextInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let82" tabindex="0"><el-kw>let </el-kw><el-field id="var83" class="ok" tabindex="0"><el-txt><el-id>y</el-id>, <el-id>rnd3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr84" class="ok" tabindex="0"><el-txt><el-id>rnd2</el-id>.<el-method>nextInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let85" tabindex="0"><el-kw>let </el-kw><el-field id="var86" class="ok" tabindex="0"><el-txt><el-id>apple2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr87" class="ok" tabindex="0"><el-txt><el-method>newSquare</el-method>(<el-id>x</el-id>, <el-id>y</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let88" tabindex="0"><el-kw>let </el-kw><el-field id="var89" class="ok" tabindex="0"><el-txt><el-id>g2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr90" class="ok" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>g</el-id><el-kw> with </el-kw><br><el-id>apple</el-id><el-kw> set to </el-kw><el-id>apple2</el-id>, <br><el-id>rnd</el-id><el-kw> set to </el-kw><el-id>rnd3</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="return77" tabindex="0"><el-kw>return </el-kw><el-field id="expr78" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-method>bodyOverlaps</el-method>(<el-id>g2</el-id>, <el-id>apple2</el-id>)<el-kw> then </el-kw><el-method>newApple</el-method>(<el-id>g2</el-id>)<el-kw><br>else </el-kw><el-id>g2</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end function</el-kw>
</el-func>
</el-code-block>

<p>However, <el-code><el-kw>copy with</el-kw></el-code> may also be used in object-oriented programming, with instances of regular (<i>mutable</i>) classes. Also,
  note that a <el-code><el-kw>with</el-kw></el-code> clause (following the same syntax as in a <el-code><el-kw>copy with</el-kw></el-code> expression), may be used
  within a new instance expression to set up properties for the object not specified in the constructor.</p>

<h2 id="empty">Empty of Type</h2>
<p>An 'empty of Type' expression is used to make the default (empty) instance of any Type
  - usually only created for comparing to another instance to test whether that other instance is also empty or default.
  This may arise, for example, if a <a href="#class">class</a> or <a href="#record">record</a> is defined with a property that has never had a value assigned to it.
  The following example is taken from the 'Pathfinder' demo program:</p>

<el-code-block>
  <el-proc class="ok multiline" id="proc267" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident269" class="ok" tabindex="0"><el-txt>visitNextPoint</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params270" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place><el-compl><i>parameter definitions</i></el-compl></el-field>)</el-top>
    <el-statement class="ok" id="call271" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident272" class="ok" tabindex="0"><el-txt><el-method>updateNeighbours</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args273" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
    <el-statement class="ok" id="set274" tabindex="0"><el-kw>set </el-kw><el-field id="ident275" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>current</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr276" class="ok" tabindex="0"><el-txt><el-method>nextNodeToVisit</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok multiline" id="if277" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr279" class="ok" tabindex="0"><el-txt>(<el-kw>property</el-kw>.<el-id>current</el-id><el-kw> is </el-kw><el-kw>empty</el-kw> <el-type>Node</el-type>)<el-kw> or </el-kw>(<el-kw>property</el-kw>.<el-id>current</el-id>.<el-id>point</el-id><el-kw> is </el-kw><el-kw>property</el-kw>.<el-id>destination</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
    <el-statement class="ok" id="set280" tabindex="0"><el-kw>set </el-kw><el-field id="ident281" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>running</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr282" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok outdent" id="else283" tabindex="0"><el-top>
        <el-kw>else </el-kw><el-field id="elif285" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
    <el-statement class="ok" id="call286" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident287" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>current</el-id>.<el-method>setVisited</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args288" class="optional ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
    <el-kw>end if</el-kw>
    </el-statement>
    <el-kw>end procedure</el-kw>
    </el-proc>
</el-code-block>

<p>It is also possible explicitly to set a property or a named value to an empty instance of the appropriate Type.</p>

<h1 id="errors_and_warnings">Errors and warnings</h1>

<h2 id="parse_error">Parse errors</h2>

<p>A parse error occurs when the text entered into a field cannot be matched against any of the valid formats for contents of that fields.
  The field will display in red (for the default colour scheme) with a message alongside it containing a link to
  one of the headings below. The <b>Parse</b> status in the status panel in the IDE will show as <b>Invalid</b>.
</p>

<h3 id="parse_arg_list" class="no-TOC">Invalid argument list</h3>
<p>An argument list passed into a function or procedure call, must consist of one or more arguments separated by commas.
  Each argument may in general be any of:</p>
  <ul>
    <li>A literal value</li>
    <li>A named value</li>
    <li>An expression</li>
  </ul>
  <p>(though in certain very specific contexts some options are disallowed by the compiler.)</p>

<h3 id="parse_assert_actual" class="no-TOC">Invalid assert actual</h3>
<p>The 'actual' field in an assert statement must be a named value or a function evaluation.</p>

<h3 id="parse_constant_literal" class="no-TOC">Invalid constant value</h3>
<p>The value of a constant must be a literal value of a type that is not mutable.
  This can be a simple value (e.g. a number or string), or an <i>immutable</i> List or Dictionary.</p>

<h3 id="parse_enum_values" class="no-TOC">Invalid enum value(s)</h3>
<p>Enum values must each be a valid identifier, separated by commas.</p>

<h3 id="parse_exception_message" class="no-TOC">Invalid exception message</h3>
<p>An exception message must either be a literal string or a named value holding a string.</p>

<h3 id="parse_expression" class="no-TOC">Invalid expression</h3>
<p>The field you are entering must be a valid <a href="#Expression">expression</a>.</p>

<h3 id="parse_name" class="no-TOC">Invalid name</h3>
<p>The name defined for any variable, constant, let, parameter, function, procedure, or property
  must follow the rules for an <a href="#identifier">identifier</a>.</p>

<h3 id="parse_inheritance" class="no-TOC">Invalid inheritance clause</h3>
<p>An inheritance clause, if used, must consist of the keyword <el-code><el-kw>inherits</el-kw></el-code>
followed by a space and then one or more Type names separated by commas.</p>

<h3 id="parse_params" class="no-TOC">Invalid parameter list</h3>
<p>Each parameter definition takes the form:</p>
<el-code><el-id>name</el-id> <el-kw>as</el-kw> <el-type>Type</el-type></el-code>
<p>The name must follow the rules for an <a href="#identifier">identifier</a>.</p>
<p>The type must follow the rules for an <a href="#parse_type">type</a>.</p>
<p>If more than one parameter is defined, the definitions must be separated by commas.</p>

<h3 id="parse_proc_ref" class="no-TOC">Invalid reference to a procedure</h3>
<p>Valid forms for a procedure call are</p>
<ul>
  <li><el-code><el-kw>call</el-kw> <el-method>procedureName</el-method>()</el-code></li>
  <li><el-code><el-kw>call</el-kw> <el-id>instanceName</el-id>.<el-method>procedureMethodName</el-method>()</el-code></li>
  <li><el-code><el-kw>call</el-kw> <el-kw>property</el-kw>.<el-id>propertyName</el-id>.<el-method>procedureMethodName</el-method>()</el-code></li>
  <li><el-code><el-kw>call</el-kw> <el-kw>library</el-kw>.<el-method>procedureName</el-method>()</el-code></li>
 </ul>

<p>The last one is used only if there is a need to disambiguate between a library procedure and a user-defined (global)
  procedure with the same name.
</p>

<h3 id="parse_type" class="no-TOC">Invalid Type format</h3>
<p>For certain types the name may be followed by an <el-code><el-kw>of</el-kw></el-code> clause, for example:</p>

<el-code><el-Type>List</el-Type>&lt;<el-kw>of</el-kw> <el-Type>Int</el-Type>&gt;</el-code>
<el-code><el-Type>Dictionary</el-Type>&lt;<el-kw>of</el-kw> <el-Type>String</el-Type>, <el-Type>Int</el-Type>&gt;</el-code>

<h3 id="parse_type_name" class="no-TOC">Invalid Type name</h3>
<p>Type names always begin with a capital letter,  optionally followed by letters or either case, numeric digits,
  or underscore symbols. Nothing else.
</p>

<h3 id="parse_var_or_let_def" class="no-TOC">Invalid variable or let definition</h3>
<p>The definition for a variable, or for a <el-code><el-kw>let</el-kw></el-code> statement is most commonly
a simple <a href="#parse_name">name</a>. Less commonly, it may take the form of:
<a href="LibRef.html#Tuple">tuple deconstruction</a>, list deconstruction, or <a href="record_deconstruction">record deconstruction</a>.
</p>

<h2 id="compile_error">Compile Errors and Warnings</h2>

<p>Q: What is the difference between a compile <i>error</i> and a <i>warning</i>.
A: A warning usually indicates that the fix may involved <i>adding</i> some more code,
for example adding a definition for an unknown identifier. An error usually indicates
that you will need to <i>alter</i> code to fix the error.
But they are similar in that
you will not be able to run your program until the issues are fixed. In all programming
languages it is a good practice 'treat all compile warnings as errors' i.e. fix them
as soon as you see them appear.
</p>

<h3 id="TypeCompileError" class="no-TOC">Expression must be ...</h3>
<p>An expression, when evaluated, results in a value of a type that is not compatible with its 'target',
  for example: if the result of the expression is being assigned to an existing variable, or if an expression is defined 'inline' as
  an argument into a method call.
</p>

<h3 id="ThisCompileError" class="no-TOC">Cannot use 'this' outside class context</h3>
<p>The keyword <el-code><el-kw>this</el-kw></el-code> may only be used within an instance method on a class to refer to the current instance.</p>

<h3 id="DeclaredAboveCompileError" class="no-TOC">Abstract Class ... must be declared before it is used</h3>
<p>If a class inherits from one or more abstract classes, then the latter must all be already declared (defined) earlier in the code file.</p>

<h3 id="MemberTypeCompileError" class="no-TOC">Member ... must be of type ...</h3>
<p>This error occurs when a class is defined as inheriting from an abstract class, #
  and has implemented an inherited member (method or property) with the correct name, but with different type(s).</p>

  <h3 id="TypesCompileError" class="no-TOC">Incompatible types. Expected: ... Provided: ...</h3>

<h3 id="TernaryCompileError" class="no-TOC">Cannot determine common type between ... and ...</h3>

<h3 id="UndefinedSymbolCompileError" class="no-TOC"> ... is not defined for type ...</h3>
<p>Arises when 'dot-calling' a member (method or property) that does not exist on the type of the named value or expression before the dot.</p>

<h3 id="CannotCallAFunction" class="no-TOC">Cannot call a function as a procedure</h3>
<p>A function (or function-method) is to be used within an expression, not via a <el-code><el-kw>call</el-kw></el-code> instruction.</p>

<h3 id="CannotUseSystemMethodInAFunction" class="no-TOC">Cannot use a system method in a function</h3>
<p>A 'system method' (defined in the Standard Library) returns a value like a function does. However, because a system method
  either makes changes to the system and/or depends on external inputs, it may be used only within a procedure or the main routine.
</p>

<h3 id="IsDeprecated" class="no-TOC">Code change required ...</h3>
<p>Indicates that a library method or class has been changed since the version in which your Elan code was written. The link in the
  message should take you directly to information in the Library Reference documentation on how to update your code to cope with the change.
</p>

<h3 id="CannotUseLikeAFunction" class="no-TOC">Cannot call procedure ... within an expression</h3>
<p>A procedure may only be used within a <el-code><el-kw>call</el-kw></el-code> instruction.</p>

<h3 id="CannotCallAsAMethod" class="no-TOC">Cannot invoke ... as a method</h3>
<p>The code is attempting to use a free-standing method (function or procedure) as a 'dotted-method' on a named value or the result of an expression.</p>

<h3 id="NotIndexableCompileError" class="no-TOC">Cannot ...index ...</h3>
<p>An index (in square brackets) may be applied only to certain data structure types: String, Array, Array2D, List, ImmutableList, Dictionary, and ImmutableDictionary.</p>

<h3 id="NotRangeableCompileError" class="no-TOC">Cannot range ...</h3>
<p>An range may be applied only to certain data structure types: String, Array, List, and ImmutableList.</p>

<h3 id="NotNewableCompileError" class="no-TOC">Cannot new ...</h3>
<p>The type specified after the <el-code><el-kw>call</el-kw></el-code> keyword cannot be instantiated. Either the type is unknown,
or it is an abstract class, or an interface.</p>

<h3 id="InvalidSourceForEachCompileError" class="no-TOC">Source for 'each' must be an Array, List, or String.</h3>

<h3 id="MustBeAbstractCompileError" class="no-TOC">Superclass ... must be inheritable class</h3>
<p>A concrete class may inherit from an abstract class, and/or an interface, but not from another concrete class.</p>

<p>In Elan, all classes must be either abstract or 'final' - a final class being concrete and not-inheritable.</p>
<h3 id="MustBeInterfaceCompileError" class="no-TOC">Superclass ... must be an interface</h3>

<p>An interface may inherit from other interfaces, but not from any class.</p>

<h3 id="MustNotBeCircularDependencyCompileError" class="no-TOC">Class/interface ... cannot inherit from itself</h3>
<p>The message is self explanatory.</p>

<h3 id="MustBeSingleAbstractCompileError" class="no-TOC">There must be only one abstract superclass ...</h3>
<p>A class may inherit from only one abstract class. However, it may additionally inherit from one or more interfaces.</p>

<h3 id="PrivateMemberCompileError" class="no-TOC">Cannot reference private member ...</h3>
<p>A private member (method or property) may be accessed only by code within the class, or within sub-classes of it.
  It may not be accessed by any code outside the class hierarchy.
</p>

<h3 id="MustImplementCompileError" class="no-TOC">... must implement ...</h3>
<p>If a concrete class inherits from any abstract class or interface(s) it must implement all abstract methods defined in those types.</p>

<h3 id="MustBeConcreteCompileError" class="no-TOC">... must be concrete to new</h3>
<p>You cannot create an instance of any abstract class or interface - only of a concrete class.</p>

<h3 id="OutParameterCompileError" class="no-TOC">Cannot pass ... as an out parameter</h3>
<p>If a parameter of a procedure is marked with <el-code><el-kw>out</el-kw></el-code> then this means that the parameter may be
reassigned within the procedure. Therefore you must pass in a variable that can be re-assigned. You cannot pass in: a
constant, a literal value, or a named value that is defined by a <el-code><el-kw>let</el-kw></el-code> instruction.</p>

<h3 id="ExtensionCompileError" class="no-TOC">Cannot call extension method directly</h3>

<p>A method that is defined within the Library as an 'extension method', such as <el-code><el-method>asString</el-method></el-code> may only be called using 'dot-syntax' on a named
  value or an expression.</p>

<h3 id="PropertyCompileError" class="no-TOC">Cannot prefix function with 'property'</h3>
<p>The prefix <el-code><el-kw>out</el-kw>.</el-code> may only be used before a property name - not a function name.</p>

<h3 id="MissingParameterCompileError" class="no-TOC">Missing argument(s) ...</h3>
<p>The method being called expects more arguments than have been provided.</p>

<h3 id="ExtraParameterCompileError" class="no-TOC">Too many argument(s) ...</h3>
<p>A method has been passed more arguments than it expects.</p>

<h3 id="ParameterTypesCompileError" class="no-TOC">Argument types ...</h3>
<p>One or more arguments provided to the method are of the wrong type.</p>

<h3 id="GenericParametersCompileError" class="no-TOC">...&lt;of Type&gt;...</h3>
<p>Certain data structure types, including <el-code><el-type>Array</el-type></el-code>, <el-code><el-type>Array2D</el-type></el-code>,
  <el-code><el-type>List</el-type></el-code> must specify the Type of their members, for example <el-code><el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-code>.
  Failure to specify the 'of Type' on these types will give an error, as will specifying 'of Type' where it is <i>not</i> required.
Dictionaries require Types to be specified for both the keys and the values,
for example: <el-code><el-type>Dictionary</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>Float</el-type>&gt;</el-code>.</p>

<h3 id="MutateCompileError" class="no-TOC">May not re-assign the ...</h3>
<p>Attempting to re-assign, or mutate, a named value that may not be re-assigned in the current context.</p>

<h3 id="NotUniqueNameCompileError" class="no-TOC">Name ... not unique in scope ...</h3>
<p>Attempting to create an identifier with the same name as one already defined <i>within the same scope</i>.</p>

<h3 id="ReassignInFunctionCompileError" class="no-TOC">May not set ... in a function</h3>
<p>A property cannot be re-assigned only within a procedure method, not within a function - because re-assigning a property is a 'side effect'.</p>

<h3 id="RedefinedCompileError" class="no-TOC">The identifier ... is already used for a ... and cannot be re-defined here.</h3>
<p>An existing named value may not be defined again within the same scope.</p>

<h3 id="DuplicateKeyCompileError" class="no-TOC">Duplicate Dictionary key(s)</h3>
<p>Attempting to define a literal <el-code><el-type>Dictionary</el-type></el-code> or <el-code><el-type>DictionaryImmutable</el-type></el-code>
with one or more duplicated keys in the definition.</p>

<h3 id="FunctionRefCompileError" class="no-TOC">To evaluate function ... add brackets ...</h3>
<p>If you intend to <i>evaluate</i> a function, the function name must be followed by brackets even if the function
defines no parameters. If your intent was to define a <i>reference</i> to the function (a pattern used commonly in
'Functional Programming' then the name of the function must be preceded by the keyword <el-code><el-kw>ref</el-kw></el-code> and a single space.</p>

<h3 id="NotGlobalFunctionRefCompileError" class="no-TOC">Library or class function ... cannot be preceded by by 'ref'</h3>
<p>The keyword <el-code><el-kw>ref</el-kw></el-code> may be applied only to functions that you have defined in your own code as a standalone (global) function.
  It may not be applied to a function method defined on a class, nor to a library function.
  (You may, however, define your own function that simply <i>delegates</i> its implementation to a library function.)</p>

  <h3 id="UnknownCompilerDirectiveCompileError" class="no-TOC">a comment may not start with [ unless it is a recognised compiler directive</h3>
<p>Compiler directives are a planned future capability - they will look like comments, but begin with an open-square bracket.
  To avoid the possibility of ambiguity, you may not start your own comments with an open square bracket.
</p>

<h3 id="mustBeBooleanCondition" class="no-TOC">Condition of 'if' expression does not evaluate to a Boolean.</h3>
  <h3 id="mustNotHaveConditionalAfterUnconditionalElse" class="no-TOC">Cannot have any clause after unconditional 'else'.</h3>

<h3 id="mustNotBeKeyword" class="no-TOC">... is a keyword, and may not be used as an identifier.</h3>
<p>An Elan keyword cannot be used to as the name for a value, property, or method. Try shortening the name, lengthening it, or using a different name</p>

<h3 id="mustNotBeReservedWord" class="no-TOC">...  is a reserved word, and may not be used as an identifier.</h3>
<p>In addition to keywords there are certain other 'reserved words' that cannot be used the name for a value, property, or method.
  Some of these are potential keywords that <i>might</i> be added to Elan in future releases.
  The reason you cannot use <el-code>int, float, string, boolean, array, list, dictionary</el-code> as identifiers
  is because it is not considered good practice to use the name of a type as an identifier
   <i>even though (in Elan) the capitalisation is different</i>. Instead you should give each identifier a name that indicates
   what it does (for a method), or represents (for a named value).
</p>

<h3 id="mustNotBeNegativeIndex" class="no-TOC">Index cannot be negative.</h3>
  <p>An index into an array or list cannot have a negative value. If a negative is given in literal form e.g.
    <el-code><el-id>a</el-id>[-<el-lit>3</el-lit>]</el-code> then this will generate a compile error.
    If you use a named value for an index and it is negative, then this will cause a run-time error.</p>

<h3 id="CannotCompareProcFunc" class="no-TOC">Cannot do equality operations on Procedures or Functions.</h3>
<p>It is not possible to apply comparison operations to functions (with or without the <el-code><el-kw>ref</el-kw></el-code> keyword prefix)
    or procedures as themselves. It is, however, possible to compare the results of two function evaluations. 
    It is possible that you are seeing this message because you intended to evaluate a function but forgot to
    add the brackets after the name.</p>

<h3 id="mustBeImmutableType" class="no-TOC">Property ... is not of an immutable type.</h3>
<p>Properties on a <a href="#record">record</a> may only be of immutable types.</p>

<h3 id="mustBeImmutableGenericType" class="no-TOC">... cannot be of mutable type ...</h3>
<p>Element type for a <a href="LibRef.html#ListImmutable">ListImmutable</a> must itself be an immutable type.
Similarly, for an <a href="LibRef.html#DictionaryImmutable">DictionaryImmutable</a> the types for both the key and the value must be immutable types.</p>

<h3 id="mustBeValidKeyType" class="no-TOC">... cannot have key of type ...</h3>
<p>The type of the key for any dictionary <a href="LibRef.html#Dictionary">Dictionary</a> must be an immutable type, and not itself an indexable type.</p>

<h3 id="invalidPropertyInRecordDeconstruction" class="no-TOC">No such property ... on record ...</h3>

<p>The property name given in the record deconstruction does not match a property on the given type of record.</p>

<h3 id="discardInRecordDeconstruction" class="no-TOC">Cannot discard in record deconstruction ...</h3>
<h3 id="mustBeCompatibleDefinitionNode" class="no-TOC">Wrong number of deconstructed variables.</h3>
<h3 id="mustBePropertyPrefixedOnMember" class="no-TOC">referencing a property requires a prefix.</h3>

<p>If you are referring to a property of a class <i>from code defined within the class</i> then the
property name must be preceded by <el-code><el-kw>property</el-kw>.</el-code></p>
<h3 id="mustNotBeOutParameter" class="no-TOC">'out' parameters are only supported on procedures.</h3>
<p>You cannot defined an <el-code><el-kw>out</el-kw></el-code> parameter in a function (because that would
imply the possibility of creating a side effect).</p>
<h3 id="mustNotHaveDuplicateMain" class="no-TOC">There can only be one 'main' in a program.</h3>
<h3 id="mustNotBeTwoUnaryExpressions" class="no-TOC">Unsupported operation.</h3>

<p>You cannot chain two 'unary' operators (those that apply to a single value) - such as <el-code>-</el-code>
or <el-code><el-kw>not</el-kw></el-code> successively within an expression.</p>

<hr>
<p><b>Elan Language Reference</b> go to the <a href="#top">top</a></p>
</body>
</html>
