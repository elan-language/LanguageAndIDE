<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">
<head>
<link rel="stylesheet" href="../ide/styles/colourScheme.css">
<link rel="stylesheet" href="../ide/styles/documentation.css">
<link rel="stylesheet" href="../ide/styles/elanStyle.css">
<link rel="icon" href="favicon.ico">
<title>Elan Language Reference</title>
<script type="text/javascript" src="generated_toc.js"></script>
</head>
<body>
<div class="docTitle">Elan Language Reference</div>
<div id="docTOC">
 <div id="generated-toc" class="generate_from_h1 generate_for_page"></div>
</div>

<h1 id="namedValue">Named values</h1>

<p>In most programming, the term <b>variable</b> describes a data entity in a program that contains a value and has a name by which you can read and write its value, i.e. its value can be varied. In an Elan program, these data entities are called <b>named values</b> so that a distinction can be made between:</p>
<ul>
 <li><b>mutable named values</b> whose content can be assigned and re-assigned, e.g. defined with a <el-kw>variable</el-kw> instruction and re-assigned with a <el-kw>set</el-kw> instruction or,
 for <a href="LibRef.html#StandardDataStructures">mutable data structures</a>, there are methods for their update.</li>
 <li><b>immutable named values</b> whose content is assigned, e.g. with a <el-kw>let</el-kw> instruction, and then cannot be re-assigned.</li>
</ul>
<p>This distinction applies both to single values and to data structures (which contain multiple values) and, while it is most pertinent in functional programming, it provides a useful discipline in any code. Preferring immutable named values can help avoid duplication and assist in the modularisation of code.</p>
<p>Both kinds of named value may be initialised with either literals or expressions.</p>

<h2 id="Type">Named value Types</h2>
<p>The Types used in the language are here listed, each linking to its definition and further details:</p>
<table>
 <tr><th>Type group</th><th colspan="5">Types</th>
 </tr><tr>
  <td>Fundamental</td>
  <td><a href="LibRef.html#Int">Integer<br><el-type>Int</el-type></a></td>
  <td><a href="LibRef.html#Float">Floating point<br><el-type>Float</el-type></a></td>
  <td><a href="LibRef.html#Boolean">Truth value<br><el-type>Boolean</el-type></a></td>
  <td><a href="LibRef.html#String">Character string<br><el-type>String</el-type></a></td>
  <td></td>
 </tr><tr>
  <td>Mutable<br> data structures</td>
  <td><a href="LibRef.html#List">List<br><el-type>List</el-type></a></td>
  <td><a href="LibRef.html#Dictionary">Look-up dictionary<br><el-type>Dictionary</el-type></a></td>
  <td><a href="LibRef.html#Array">Simple array<br><el-type>Array</el-type></a></td>
  <td><a href="LibRef.html#Array2D">2-dimensional array<br><el-type>Array2D</el-type></a></td>
  <td></td>
 </tr><tr>
  <td>Immutable<br> data structures</td>
  <td><a href="LibRef.html#ListImmutable">Immutable list<br><el-type>ListImmutable</el-type></a></td>
  <td><a href="LibRef.html#DictionaryImmutable">Immutable look-up dictionary<br><el-type>DictionaryImmutable</el-type></a></td>
  <td><a href="LibRef.html#SetType">Set<br><el-type>Set</el-type></a></td>
 <td><a href="LibRef.html#Stack">LIFO stack<br><el-type>Stack</el-type></a></td>
 <td><a href="LibRef.html#Queue">FIFO queue<br><el-type>Queue</el-type></a></td>
 </tr><tr>
  <td>Data I/O</td>
  <td><a href="LibRef.html#TextFileReader">Text file input<br><el-type>TextFileReader</el-type></a></td>
  <td><a href="LibRef.html#TextFileWriter">Text file output<br><el-type>TextFileWriter</el-type></a></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td>Graphics</td>
  <td><a href="LibRef.html#TurtleGraphics">Turtle</a></td>
  <td><a href="LibRef.html#VectorGraphics">SVG vector graphics</a></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td>User-defined</td>
  <td><a href="#enum">Enumeration<br><el-kw>enum</el-kw> <el-type>Name</el-type></a></td>
  <td><a href="#record">Record<br><el-kw>record</el-kw> <el-type>Name</el-type></a></td>
  <td><a href="#class">Class<br><el-kw>class</el-kw> <el-type>Name</el-type></a></td>
  <td><a href="#abstract_class">Abstract class<br><el-kw>abstract class</el-kw> <el-type>Name</el-type></a></td>
  <td><a href="#interface">Interface<br><el-kw>interface</el-kw> <el-type>Name</el-type></a></td>
 </tr><tr>
  <td>Other</td>
  <td><a href="LibRef.html#Random">Random number<br><el-type>Random</el-type></a></td>
  <td><a href="LibRef.html#Func">Function reference<br><el-type>Func</el-type></a></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
</table>
<p>Named values are statically typed: their Type, once defined, cannot be changed. A named value's Type is:
<ul>
 <li><i>either</i> automatically inferred from the value of the literal or expression defining a Fundamental Type,</li>
 <li><i>or</i> specified in the definition of:</li>
 <ul>
  <li>Data structures whose elements have a particular Type, e.g. <el-type>Array</el-type>&lt;of <el-type>Int</el-type>&gt;</li>
  <li><p><a href="#Parameter"</p>parameters</a> of functions and procedures</li>
  <li><el-kw>return</el-kw> value of a function</li>
  <li><el-kw>property</el-kw> of an interface, class or record</li>
  <li>empty named value, e.g. <el-kw>empty</el-kw> <el-type>List</el-type></li>
 </ul>
</ul>

<h2 id="Mutability">Mutability of named values</h2>

<p>The properties or contents of a named value that is of an immutable Type may not be changed directly.
You can, however, create another instance that is a copy of the original,
with all the same property values except for specific changes that you want to make.
 The newly-minted copy (with changes) may be assigned either to a new named value, or as a re-definition of the original named value.</p>

<p>This table shows which named values can be re-assigned and/or mutated depending on how they were defined:</p>
<table>
 <tr><th colspan="3">define named value</th><th colspan="3">named value</th><th rowspan="2">notes</th></tr>
 <tr><th>with</th><th>as<br>mutable Type</th><th>as<br> immutable Type</th><th>re-assign<br>with '<el-kw-th>set</el-kw-th>'</th><th>mutate</th><th>scope</th></tr>
 <tr><td><a href="#constant"><el-kw>constant</el-kw></a></td></td><td>&#x2718;</td><td>&#x2714;</td><td>&#x2718;</td><td>&#x2718;</td><td>global</td>
  <td>constant values are set only at compile time</td></tr>
 <tr><td><a href="#let"><el-kw>let</el-kw></a></td><td>&#x2714;</td><td></td><td>&#x2718;</td><td>&#x2714;</td><td>local</td>
  <td></td></tr>
 <tr><td><a href="#let"><el-kw>let</el-kw></a></td><td></td><td>&#x2714;</td><td>&#x2718;</td><td>&#x2718;</td><td>local</td>
  <td></td></tr>
 <tr><td><a href="#variable"><el-kw>variable</el-kw></a></td><td>&#x2714;<td>&#x2714;</td><td>&#x2714;</td><td>&#x2714;</td><td>local</td>
  <td></td></tr>
 <tr><td><a href="#Parameter">parameter</a></td><td>&#x2714;</td><td></td><td>&#x2718;</td><td>&#x2714;</td><td>local</td>
  <td>formal input argument of function, procedure or lambda</td></tr>
 <tr><td><a href="#Parameter">parameter</a></td><td></td><td>&#x2714;</td><td>&#x2718;</td><td>&#x2718;</td><td>local</td>
  <td>formal input argument of function, procedure or lambda</td></tr>
 <tr><td><a href="#out"><el-kw>out</el-kw> parameter</a></td><td>&#x2714;</td><td></td><td>&#x2714;</td><td>&#x2714;</td><td>local</td>
  <td>formal output argument of procedure</td></tr>
 <tr><td><a href="#out"><el-kw>out</el-kw> parameter</a></td><td></td><td>&#x2714;</td><td>&#x2714; (see note)</td><td>&#x2714;</td><td>local</td>
  <td>formal output argument of procedure<br>
  an <el-kw>out</el-kw> parameter of an immutable Type may be re-assigned<br>if the actual argument is defined with <el-kw>variable</el-kw>, not <el-kw>let</el-kw></td></tr>
</table>

<h2 id="Identifier">Identifiers and Type names</h2>
<h3 class="no-TOC">Named value identifier</h3>
<p>The name given to every named value must follow the rules for an <b>identifier</b>:</p>
<ul>
 <li>It must start with a lowercase letter followed by any combination ot letters (upper- or lowercase), digits and underscore '_' symbols.</li>
 <li>It must not contain spaces or other symbols.</li>
 <li>It cannot be the same as any language keyword, method or other reserved word. If you happen to choose such a name, an error message will tell you that it cannot be used for an identifier.</li>
 <li>Like all the language's keywords, it is case-sensitive.</li>
</ul>

<h3 class="no-TOC" id="TypeName">Type name</h3>
<p>Every Type, whether system (e.g. <el-type>List</el-type>)  or user defined (e.g. <el-type>MyClass</el-type>), is named like an identifier but
 with one important difference: its first character must be an uppercase letter. Type names are also case-sensitive.</p> 

<div id="global"></div>
<div id="library"></div>
<h2 id="Scope">Scope and name qualification</h2>
<p>'Scope' in the table above refers to where in your code a named value is accessible.
 <el-kw>constant</el-kw>s and <el-kw>enum</el-kw>s, being the only values having <i>global</i> scope, can be referenced from anywhere in your program.
 Every other kind of named value is <i>local</i> and restricted to the procedure or function within which it is defined.</p>
<p>Local named values can have the same name as a <el-kw>constant</el-kw>, <el-code>function</el-code>, or <el-code>procedure</el-code> (which are all defined at global level or are in the standard library).
 In such cases, when the name is used within the same method, then it will refer to the local definition.
  If you have done this, but then need to access the <el-code>constant</el-code>, <el-code>function</el-code>, or <el-code>procedure</el-code> with the same name,
  then you prefix the name with a <i>dot qualifier</i> of either <el-kw>global</el-kw> or <el-kw>library</el-kw> as appropriate</p>
                                                    
<h1 id="GlobalInstructions">Global instructions</h1>
<p>Global instructions (also referred to as <b>globals</b>) are located <em>directly</em> in your code at the highest level.
They are never indented from the left-hand edge, nor may they be located <em>within</em> other instructions. They are:
 <a href="#main"><el-kw>main</el-kw></a>,
 <a href="#procedure"><el-kw>procedure</el-kw></a>,
 <a href="#function"><el-kw>function</el-kw></a>,
 <a href="#test"><el-kw>test</el-kw></a>,
 <a href="#record"><el-kw>record</el-kw></a>,
 <a href="#class"><el-kw>class</el-kw></a>,
 <a href="#abstract_class"><el-kw>abstract class</el-kw></a>,
 <a href="#interface"><el-kw>interface</el-kw></a>,
 <a href="#constant"><el-kw>constant</el-kw></a> and
 <a href="#enum"><el-kw>enum</el-kw></a>.
</p>
<div id="Method"></div>
<ul>
 <li><el-kw>main</el-kw>, <el-kw>procedure</el-kw> and <el-kw>function</el-kw> are described as <b>methods</b> and these are defined by one or more <a href="#statement">statements</a> within them.</li>
 <li><el-kw>test</el-kw> also contains statements, in particular the <a href="#assert"><el-kw>assert</el-kw></a> statement for testing functions during development of your program.</li>
 <li><el-kw>record</el-kw>, <el-kw>class</el-kw>, <el-kw>abstract</el-kw> (class), and <el-kw>interface</el-kw> define data structures and these always contain <a href="#Member">members</a>.</li>
 <li><el-kw>constant</el-kw> and <el-kw>enum</el-kw> do not contain any further instructions &ndash; only names and values.</li>
 <li>The sequence of global instructions in your code is immaterial, with two exceptions:
  <ul>
   <li>If one <el-kw>constant</el-kw> is used in the definition of another constant, the first must be declared above the second.</li>
   <li>An <el-kw>abstract class</el-kw> must be declared above any <el-kw>class</el-kw> that inherits from it.</li>
  </ul>
</ul>

<h2 id="main"><el-kw>main</el-kw></h2>
<p>A program must have a <el-kw>main</el-kw> method, sometimes called its main routine, if it is intended to be run as a program. You may, however, develop and test code that does not have a <el-kw>main</el-kw> method, either as a coding exercise or for subsequent use within another program.</p>
<p>The <el-kw>main</el-kw> method defines the start point of a program when it is run (executed).</p>
<p>It does not have to be at the top of the file, but this is a good convention to follow.</p>
<p>It may delegate work to one or more <a href="#procedure">procedures</a> or <a href="#function">functions</a>.</p>
<p>There may not be more than one <el-kw>main</el-kw> in a program file, and the Global prompt will not show <el-kw>main</el-kw> as an option when one already exists in the file.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example of a <el-kw>main</el-kw> method</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; A <el-kw>main</el-kw> method</p>
<el-code-block source="main.elan">
<main class="multiline" id="main1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw> <el-msg class="warning"></el-msg></el-top>
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="warning" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end main</el-kw></main>
</el-code-block>
<hr>
</div></div>

<h2 id="procedure"><el-kw>procedure</el-kw></h2>
<p id="Argument">A procedure is a named piece of code that can define <b>parameters</b> which are given inputs via <b>arguments</b> in a <el-kw>call</el-kw> statement.
 Its name must follow  the rules for an <a href="#Identifier">identifier</a>.</p>
<p> Unlike a function:</p>
<ul>
 <li>a procedure does not return a value (unless its parameters include an <el-kw>out</el-kw> value).</li>
 <li>a procedure can have side effects: indeed it <em>should</em> have side effects, otherwise there would be no point in calling it!</li>
</ul>
<p>Therefore the statements within a procedure can:</p>
<ul>
<li>include <el-kw>print</el-kw> statements and methods.</li>
<li>include data input methods and other system methods (such as for random number generation).</li>
<li><el-kw>call</el-kw> other procedures (or itself if <a href="#recursion">recursion</a> is required).</li>
<li id="out">assign a value to a parameter, provided that the parameter definition is preceded by the keyword <el-kw>out</el-kw>.</li>
</ul>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples of procedures</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Calling a procedure:</p>
<el-code-block source="inPlaceRippleSort.elan">
  <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>3</el-lit>, <el-lit>6</el-lit>, <el-lit>1</el-lit>, <el-lit>0</el-lit>, <el-lit>99</el-lit>, <el-lit>4</el-lit>, <el-lit>67</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>inPlaceRippleSort</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>li</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Using keyword <el-kw>out</el-kw></p>
<el-code-block source="inPlaceRippleSort.elan">
  <el-proc class="ok multiline" id="proc11" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident13" class="ok" tabindex="0"><el-txt>inPlaceRippleSort</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params14" class="optional ok" tabindex="0"><el-txt><el-kw>out</el-kw> <el-id>arr</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
  <el-statement class="ok" id="var15" tabindex="0"><el-kw>variable </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="var18" tabindex="0"><el-kw>variable </el-kw><el-field id="var19" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="repeat21" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
  <el-statement class="ok" id="set24" tabindex="0"><el-kw>set </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="for27" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
  <el-statement class="ok multiline" id="if33" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>] &gt; <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
  <el-statement class="ok" id="let36" tabindex="0"><el-kw>let </el-kw><el-field id="var37" class="ok" tabindex="0"><el-txt><el-id>temp</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>[<el-id>i</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call39" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident40" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>put</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args41" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id>, <el-id>arr</el-id>[<el-id>i</el-id> + <el-lit>1</el-lit>]</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="call42" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident43" class="ok" tabindex="0"><el-txt><el-id>arr</el-id>.<el-method>put</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args44" class="optional ok" tabindex="0"><el-txt><el-id>i</el-id> + <el-lit>1</el-lit>, <el-id>temp</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="set45" tabindex="0"><el-kw>set </el-kw><el-field id="ident46" class="ok" tabindex="0"><el-txt><el-id>changes</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr47" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end if</el-kw>
  </el-statement>
  <el-kw>end for</el-kw>
  </el-statement>
  <el-statement class="ok" id="set48" tabindex="0"><el-kw>set </el-kw><el-field id="ident49" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr50" class="ok" tabindex="0"><el-txt><el-id>lastComp</el-id> - <el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end repeat when </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>changes</el-id></el-txt><el-place><i>condition</i></el-place></el-field>
  </el-statement>
  <el-kw>end procedure</el-kw>
  </el-proc>
</el-code-block>
<hr>
</div></div>

<h2 id="function"><el-kw>function</el-kw></h2>
<p>A <el-kw>function</el-kw> is a named piece of code that can define <b>parameters</b> which are given inputs via <b>arguments</b> when reference to the function occurs in a statement or expression. Its name must follow  the rules for an <a href="#Identifier">identifier</a>.</p>
<p>Unlike a <a href="#procedure">procedure</a>:</p>
<ul>
 <li>a function always returns a value.</li>
 <li>a function can have no side effects (i.e. no references outside its code) and cannot depend on any <a href="LibRef.html#SystemMethods">System methods</a>.</li>
 <li>a function's execution cannot be interrupted by any external event, though a a non-terminating loop in a function may be detected with tests that <a href="#ignore">time out</a>.</li>
</ul>
<p id="returns"></p>A function definition is comprised of its input parameters (with their Types), followed by the automatically added keyword <el-kw>returns</el-kw>,
and the Type of the value that will be returned, for example:
<el-code-block source="function.elan">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-method>factorial</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params8" class="optional ok" tabindex="-1"><el-txt><el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type9" class="ok" tabindex="-1"><el-txt><el-type>Int</el-type></el-txt></el-field></el-top>
</el-code-block>
</p>
<p id="return">A <el-kw>return</el-kw> statement is automatically added as the last instruction of a function, since a function <i>must</i> return a value,
and there can be only one <el-kw>return</el-kw> statement in a function.</p>
<p>You follow the <el-kw>return</el-kw> statement with the value to be returned by the function. This may be an expression that will be evaluated before returning. for example:</p>
<el-code-block source="returnExp.elan">
<el-statement class="ok" id="return6" tabindex="-1"><el-kw>return </el-kw><el-field id="expr7" class="ok" tabindex="-1"><el-txt><el-kw>if </el-kw>(<el-id>a</el-id>^<el-id>b</el-id>) &lt; (<el-id>b</el-id>^<el-id>a</el-id>)<el-kw><br>then </el-kw><el-id>true</el-id><el-kw><br>else </el-kw><el-id>false</el-id></el-txt></el-field></el-statement>
</el-code-block>
<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example of a function and reference to it</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; The function definition</p>
<el-code-block source="function.elan">
<el-func class="ok multiline" id="func5" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-method>score</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params8" class="optional ok" tabindex="-1"><el-txt><el-id>g</el-id> <el-kw>as</el-kw> <el-type>Game</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type9" class="ok" tabindex="-1"><el-txt><el-type>Int</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="return10" tabindex="-1"><el-kw>return </el-kw><el-field id="expr11" class="ok" tabindex="-1"><el-txt><el-id>g</el-id>.<el-id>body</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit></el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Reference to the function</p>
<main class="ok multiline" id="main1" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw></el-top>
<el-statement class="ok" id="let17" tabindex="-1"><el-kw>let </el-kw><el-field id="var18" class="ok" tabindex="-1"><el-txt><el-id>g</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr19" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>Game</el-type>()</el-txt></el-field></el-statement>
<el-statement class="ok" id="print3" tabindex="-1"><el-kw>print </el-kw><el-field id="expr4" class="optional ok" tabindex="-1"><el-txt><el-method>score</el-method>(<el-id>g</el-id>)</el-txt></el-field></el-statement>
<el-kw>end main</el-kw>
</main>
</el-code-block>
<hr>
</div></div>

<div id="dotMethod"></div>
<h3 class="no-TOC" id="dotSyntax">Dot syntax</h3>
<p>The function example above includes two uses of <b>dot syntax</b> to qualify items in an expression:</p>
<ul>
 <li><el-code>g.body</el-code> refers to <el-kw>property</el-kw> <el-code>body</el-code> (defined in class <el-type>Game</el-type>)
  to return its current value in the class instance named <el-code>g</el-code>.</li>
 <li><el-code>g.body.length()</el-code> applies method <el-method>length</el-method> to the value <el-code>g.body</el-code> to return its string length.<br>
 This use of dot syntax is usually referred to as applying a <b>dot method</b>.<br> Examples include the <a href="LibRef.html#CommonDotMethods">common dot methods</a>.</li>
</ul>
<p>Dot syntax is also used:</p>
<ul>
 <li>in a call to a procedure method referencing a variable, as in:
<el-code-block source="put.elan">
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>a4</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>Array</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;(<el-lit>4</el-lit>, <el-lit>0</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="call8" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident9" class="ok" tabindex="-1"><el-txt><el-id>a4</el-id>.<el-method><el-method>put</el-method></el-method></el-txt></el-field>(<el-field id="args10" class="optional ok" tabindex="-1"><el-txt><el-lit>2</el-lit>, <el-lit>5</el-lit></el-txt></el-field>)</el-top></el-statement>
</el-code-block>
<p>The procedure called may be defined in a class or provided by the system.</li>
 <li>to <a href="LibRef.html#deconstructTuple">deconstruct a Tuple</a>.</li>
</ul>
<p>You cannot, however, use dot syntax with your user-defined procedures at the global level,<br>
nor with some system provided functions (e.g. <el-method>abs</el-method>) and procedures (e.g. <el-method>clearPrintedText</el-method>).</p>

<div id="as"></div>
<h3 class="no-TOC" id="Parameter">Parameters</h3>
Parameters for both a <el-kw>procedure</el-kw> and a <el-kw>function</el-kw> are defined in exactly the same way.<br>Each parameter definition takes the form:
<el-code>named value <el-kw>as</el-kw> Type</el-code>, for example:
<el-code-block source="ageAsInt.elan">
<el-field id="params50" class="optional ok" tabindex="0"><el-txt><el-id>age</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>
</el-code-block>

<h3  class="no-TOC" id="recursion">Recursion</h3>
Procedures and functions may be called or referenced recursively, as in this simple factorial calculation:
<el-code-block source="factorial.elan">
<el-func class="ok multiline" id="func5" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-method>factorial</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params8" class="optional ok" tabindex="-1"><el-txt><el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type9" class="ok" tabindex="-1"><el-txt><el-type>Int</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="return10" tabindex="-1"><el-kw>return </el-kw><el-field id="expr11" class="ok" tabindex="-1"><el-txt>(<el-kw>if </el-kw><el-id>n</el-id> &gt; <el-lit>1</el-lit><el-kw><br>then </el-kw><el-id>n</el-id>*<el-method>factorial</el-method>(<el-id>n</el-id> - <el-lit>1</el-lit>)<el-kw><br>else </el-kw><el-lit>1</el-lit>)</el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h2 id="test"><el-kw>test</el-kw></h2>
<p>A <el-kw>test</el-kw> instruction is at the global level, and consists of a set of assertions about the outputs of functions.</p>
<p>Without having to run your program, the <el-kw>assert</el-kw> statements show whether your assertions pass or fail.

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example of a set of <el-kw>assert</el-kw> statements that test a function</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Test function <el-code>binarySearch</el-code> on three test lists</p>
<el-code-block source="test_search.elan">
<el-test class="ok multiline" id="test74" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment76" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>li1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>lime</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert80" tabindex="0"><el-kw>assert </el-kw><el-field id="text81" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert83" tabindex="0"><el-kw>assert </el-kw><el-field id="text84" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li1</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let92" tabindex="0"><el-kw>let </el-kw><el-field id="var93" class="ok" tabindex="0"><el-txt><el-id>li2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr94" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>", "<el-lit>orange</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert95" tabindex="0"><el-kw>assert </el-kw><el-field id="text96" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr97" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert98" tabindex="0"><el-kw>assert </el-kw><el-field id="text99" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>orange</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr100" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert101" tabindex="0"><el-kw>assert </el-kw><el-field id="text102" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li2</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr103" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let104" tabindex="0"><el-kw>let </el-kw><el-field id="var105" class="ok" tabindex="0"><el-txt><el-id>li3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr106" class="ok" tabindex="0"><el-txt>["<el-lit>lemon</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert107" tabindex="0"><el-kw>assert </el-kw><el-field id="text108" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lemon</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr109" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert110" tabindex="0"><el-kw>assert </el-kw><el-field id="text111" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li3</el-id>, "<el-lit>lime</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr112" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let113" tabindex="0"><el-kw>let </el-kw><el-field id="var114" class="ok" tabindex="0"><el-txt><el-id>li4</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr115" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert116" tabindex="0"><el-kw>assert </el-kw><el-field id="text117" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>li4</el-id>, "<el-lit>pear</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr118" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<hr>
</div></div>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>Elan tests are designed to test functions only. It is not possible to call a <el-kw>procedure</el-kw> or <el-kw>main</el-kw> routine within a test.
  Nor is it possible to use any <a href="LibRef.html#SystemMethods">System method</a> (the same rule as for a function).</li>
 <li>A test may optionally be given a name or description in free-form text, just like a comment, which plays no role in the execution of the test.
 You might give the test the same name as a function that it is testing, or you might describe a particular scenario that is being tested.</li>
 <li><el-kw>test</el-kw> instructions may be written anywhere in the code, provided they are at the global level. </li>
 <li>A <el-kw>test</el-kw> instruction may contain any number of <el-kw>assert</el-kw> statements. The test runner is part of the IDE and it automatically attempts to run all <el-kw>assert</el-kw> statements showing each one's pass or fail outcome alongside. However, if the test hits a runtime error (as distinct from an <el-kw>assert</el-kw> failure) then execution of the test will stop and remaining <el-kw>assert</el-kw>s will be shown as 'not run'.</li>
 <li>In addition to <el-kw>assert</el-kw> statements, a <el-kw>test</el-kw> may contain any other statements that may be added into a <el-kw>function</el-kw>.</li>
 <li>All <el-kw>assert</el-kw> statements should be at the top level within the <el-kw>test</el-kw> frame; none may be put into a loop structure.</li>
</ul>

<h3 class="no-TOC">Testing Float values</h3>
<p>When testing <el-type>Float</el-type> values it is recommend that you use the <el-method>round</el-method> method to round the computed result to a fixed number of decimal places. This avoids rounding errors and is easier to read. For example:</p>

<el-code-block source="test_round.elan">
<el-test class="ok multiline" id="test3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment5" class="optional ok" tabindex="0"><el-txt>round()</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="assert14" tabindex="0"><el-kw>assert </el-kw><el-field id="text15" class="ok" tabindex="0"><el-txt><el-method>sqrt</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.414</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h3 class="no-TOC">Testing for runtime errors</h3>
<p>If the expression you are testing would cause a runtime error then the error will be displayed in the red fail message:</p>
<el-code-block source="test_runtime.elan">
<el-test class="error multiline" id="test1" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="-1"><el-txt>&nbsp;</el-txt></el-field></el-top>
<el-statement class="ok" id="let4" tabindex="-1"><el-kw>let </el-kw><el-field id="var5" class="ok" tabindex="-1"><el-txt><el-id>a</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr6" class="ok" tabindex="-1"><el-txt>[<el-lit>5</el-lit>, <el-lit>1</el-lit>, <el-lit>7</el-lit>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="assert7" tabindex="-1"><el-kw>assert </el-kw><el-field id="text8" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>0</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr9" class="ok" tabindex="-1"><el-txt><el-lit>5</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert10" tabindex="-1"><el-kw>assert </el-kw><el-field id="text11" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>2</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr12" class="ok" tabindex="-1"><el-txt><el-lit>7</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert13" tabindex="-1"><el-kw>assert </el-kw><el-field id="text14" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>4</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr15" class="ok" tabindex="-1"><el-txt><el-lit>0</el-lit></el-txt></el-field> <el-msg class="error">actual (computed): Out of range index: 4 size: 3</el-msg></el-statement>
<el-statement class="ok" id="assert17" tabindex="-1"><el-kw>assert </el-kw><el-field id="text18" class="ok" tabindex="-1"><el-txt><el-id>a</el-id>[<el-lit>4</el-lit>]</el-txt></el-field><el-kw> is </el-kw><el-field id="expr19" class="ok" tabindex="-1"><el-txt>"<el-lit>Out of range index: 4 size: 3</el-lit>"</el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test></el-code-block>

<p>If there are failures, mark the tests that you added since the last successful test as <a href="IDENavigation.html#EditInstructions"><el-code>ghosted</el-code></a> and then remove their ghosted status one by one until the cause is identified and fixed.</p>
<p>In the last <el-kw>assert</el-kw> above, note how testing can also be done against an expected error message.</p>

<h3 class="no-TOC" >Testing long strings</h3>
<p>If you have a test that compares strings longer than 20 characters, any test failure message will be reduced to reporting the
 <i>first</i> character at which  the actual (computed) and expected strings differ.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example of testing long strings</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Reporting the first character at which the actual (computed) and expected strings differ:</p>

<el-code-block source="assertLongString.elan">
<el-const class="ok multiline" id="const1" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident2" class="ok" tabindex="-1"><el-txt><el-id>sGW</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text3" class="ok" tabindex="-1"><el-txt>'<el-lit>grid { display: flex; flex-direction: column; margin-top: 40px; width: 500px; } word { display: flex; flex-direction: row; margin: auto; }</el-lit>'</el-txt></el-field></el-const>
<el-func class="ok multiline" id="func4" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident6" class="ok" tabindex="-1"><el-txt><el-method>setInStyle</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params7" class="optional ok" tabindex="-1"><el-txt><el-id>s</el-id> <el-kw>as</el-kw> <el-type>String</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type8" class="ok" tabindex="-1"><el-txt><el-type>String</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="return9" tabindex="-1"><el-kw>return </el-kw><el-field id="expr10" class="ok" tabindex="-1"><el-txt>"<el-lit>&lt;style&gt;</el-lit>" + <el-id>s</el-id> + "<el-lit>&lt;style&gt;</el-lit>"</el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
<el-test class="error multiline" id="test11" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment13" class="empty optional ok" tabindex="-1"><el-txt>&nbsp;</el-txt></el-field></el-top>
<el-statement class="ok" id="assert14" tabindex="-1"><el-kw>assert </el-kw><el-field id="text15" class="ok" tabindex="-1"><el-txt><el-method>setInStyle</el-method>(<el-id>sGW</el-id>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr16" class="ok" tabindex="-1"><el-txt>'<el-lit>&lt;style&gt;</el-lit>' + <el-id>sGW</el-id> + '<el-lit>&lt;/style&gt;</el-lit>'</el-txt></el-field> <el-msg class="error">s found at [146] (expected: /)</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<hr>
</div></div>

<h3 class="no-TOC" id="ignore">Ignoring tests</h3>
<p>To ignore tests, use <a href="IDENavigation.html#EditInstructions"><el-code>ghosting</el-code></a>.</p>
<p>Even when <el-kw>test</el-kw>s or <el-kw>assert</el-kw>s are <el-code>ghosted</el-code>, all the tests will be run and their status shown, but
the overall test status will show the status of only the unghosted tests (green <b>pass</b>, amber <b>warning</b> or red <b>fail</b>).</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples of ghosting tests</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Ghosting an entire test:</p>

<el-code-block source="snake_FP.elan">
<el-test class="ghosted ok multiline" id="test210" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment212" class="optional ok" tabindex="-1"><el-txt>clockTick</el-txt></el-field></el-top>
<el-statement class="ok" id="let213" tabindex="-1"><el-kw>let </el-kw><el-field id="var214" class="ok" tabindex="-1"><el-txt><el-id>g1</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr215" class="ok" tabindex="-1"><el-txt><el-method>newGame</el-method>(<el-kw>new</el-kw> <el-type>Random</el-type>())</el-txt></el-field></el-statement>
<el-statement class="ok" id="let216" tabindex="-1"><el-kw>let </el-kw><el-field id="var217" class="ok" tabindex="-1"><el-txt><el-id>g2</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr218" class="ok" tabindex="-1"><el-txt><el-method>newApple</el-method>(<el-id>g1</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="let219" tabindex="-1"><el-kw>let </el-kw><el-field id="var220" class="ok" tabindex="-1"><el-txt><el-id>g3</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr221" class="ok" tabindex="-1"><el-txt><el-method>clockTick</el-method>(<el-id>g2</el-id>, "<el-lit>s</el-lit>")</el-txt></el-field></el-statement>
<el-statement class="ok" id="assert222" tabindex="-1"><el-kw>assert </el-kw><el-field id="text223" class="ok" tabindex="-1"><el-txt><el-id>g3</el-id>.<el-id>head</el-id></el-txt></el-field><el-kw> is </el-kw><el-field id="expr224" class="ok" tabindex="-1"><el-txt><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>16</el-lit>)</el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert225" tabindex="-1"><el-kw>assert </el-kw><el-field id="text226" class="ok" tabindex="-1"><el-txt><el-id>g3</el-id>.<el-id>body</el-id>.<el-method>length</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr227" class="ok" tabindex="-1"><el-txt><el-lit>2</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<hr>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; Ghosting an assert:</p>

<el-code-block source="snake_FP.elan">
</el-test>
<el-test class="ok multiline" id="test210" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment212" class="optional ok" tabindex="-1"><el-txt>clockTick</el-txt></el-field></el-top>
<el-statement class="ok" id="let213" tabindex="-1"><el-kw>let </el-kw><el-field id="var214" class="ok" tabindex="-1"><el-txt><el-id>g1</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr215" class="ok" tabindex="-1"><el-txt><el-method>newGame</el-method>(<el-kw>new</el-kw> <el-type>Random</el-type>())</el-txt></el-field></el-statement>
<el-statement class="ok" id="let216" tabindex="-1"><el-kw>let </el-kw><el-field id="var217" class="ok" tabindex="-1"><el-txt><el-id>g2</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr218" class="ok" tabindex="-1"><el-txt><el-method>newApple</el-method>(<el-id>g1</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="let219" tabindex="-1"><el-kw>let </el-kw><el-field id="var220" class="ok" tabindex="-1"><el-txt><el-id>g3</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr221" class="ok" tabindex="-1"><el-txt><el-method>clockTick</el-method>(<el-id>g2</el-id>, "<el-lit>s</el-lit>")</el-txt></el-field></el-statement>
<el-statement class="ghosted ok" id="assert222" tabindex="-1"><el-kw>assert </el-kw><el-field id="text223" class="ok" tabindex="-1"><el-txt><el-id>g3</el-id>.<el-id>head</el-id></el-txt></el-field><el-kw> is </el-kw><el-field id="expr224" class="ok" tabindex="-1"><el-txt><el-method>newSquare</el-method>(<el-lit>21</el-lit>, <el-lit>16</el-lit>)</el-txt></el-field> <el-msg class="error">actual (computed): 22, 16</el-msg></el-statement>
<el-statement class="ok" id="assert225" tabindex="-1"><el-kw>assert </el-kw><el-field id="text226" class="ok" tabindex="-1"><el-txt><el-id>g3</el-id>.<el-id>body</el-id>.<el-method>length</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr227" class="ok" tabindex="-1"><el-txt><el-lit>2</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<hr>
</div></div>

<h3 class="no-TOC">Non-terminating loops and recursion</h3>
<p>The principal reason for ghosting a test is when either the test code, or code in any function being called, does not terminate. This typically means that there is a loop (or a recursive call) with no exit condition, or where the exit condition is never met.</p>
<p>If you do create such code without realising it, then when the tests are executed the test runner will time out after a few seconds (most tests will pass in milliseconds), and an error message will appear. Your priority should then be to identify the cause of the timeout and attempt to fix it before then unghosting the <el-code>test</el-code>.</p>

<h2 id="record"><el-kw>record</el-kw></h2>
<p>A <el-code>record</el-code> is a user-defined data structure that is given a Type name (which must begin with an uppercase letter).
  The <el-code>record</el-code> defines one or more properties, each of which has a name (starting with a lowercase letter) and a Type.
  The Type of a property may be any simple value Type, or a <el-code>ListImmutable</el-code>, or another Type of <el-code>record</el-code> (or even of the same Type of <el-code>record</el-code>).</p>
  <p>Note that a <el-code>record</el-code> has some similarity to a <a href="#class"><el-code>class</el-code></a> in that:</p>
<ul>
  <li>Both are user-defined data structures</li>
  <li>Both are given a Type name</li>
  <li>Both may define one or more properties, each with a name and Type</li>
  <li>Both may be created or copied using a <el-kw>with</el-kw> clause</li>
  <li>Both may define encapsulated methods</li>
</ul>
<p>However a <el-code>record</el-code> differs  from a <el-code>class</el-code> in that:</p>
 <ul>
  <li>A <el-code>record</el-code> is immutable (like a <el-code>ListImmutable</el-code> or a <el-code>String</el-code>). You can create a copy with specified differences but you cannot modify a <el-code>property</el-code> on a given instance.</li>
  <li>A <el-code>record</el-code> does not define a constructor</li>
  <li>A <el-code>record</el-code> may define only <i>function</i> methods, since <i>procedure</i> methods would imply the ability to <i>mutate</i> the record.</li>
</ul>
Examples:
<el-code-block source="record_Square.elan">
<el-class class="ok multiline" id="class203" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type204" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop207" tabindex="0"><el-kw>property </el-kw><el-field id="ident208" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type209" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop210" tabindex="0"><el-kw>property </el-kw><el-field id="ident211" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type212" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
<el-code-block source="record_Game.elan">
<el-class class="ok multiline" id="class168" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>record </el-kw><el-field id="type169" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place>Name</el-place></el-field></el-top>
<el-prop class="ok" id="prop172" tabindex="0"><el-kw>property </el-kw><el-field id="ident173" class="ok" tabindex="0"><el-txt><el-id>head</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type174" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop175" tabindex="0"><el-kw>property </el-kw><el-field id="ident176" class="ok" tabindex="0"><el-txt><el-id>body</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type177" class="ok" tabindex="0"><el-txt><el-type>ListImmutable</el-type>&lt;<el-kw>of</el-kw> <el-type>Square</el-type>&gt;</el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop178" tabindex="0"><el-kw>property </el-kw><el-field id="ident179" class="ok" tabindex="0"><el-txt><el-id>priorTail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type180" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop181" tabindex="0"><el-kw>property </el-kw><el-field id="ident182" class="ok" tabindex="0"><el-txt><el-id>apple</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type183" class="ok" tabindex="0"><el-txt><el-type>Square</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop184" tabindex="0"><el-kw>property </el-kw><el-field id="ident185" class="ok" tabindex="0"><el-txt><el-id>isOn</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type186" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop187" tabindex="0"><el-kw>property </el-kw><el-field id="ident188" class="ok" tabindex="0"><el-txt><el-id>rnd</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type189" class="ok" tabindex="0"><el-txt><el-type>Random</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop190" tabindex="0"><el-kw>property </el-kw><el-field id="ident191" class="ok" tabindex="0"><el-txt><el-id>graphics</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type192" class="ok" tabindex="0"><el-txt><el-type>BlockGraphics</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-prop class="ok" id="prop193" tabindex="0"><el-kw>property </el-kw><el-field id="ident194" class="ok" tabindex="0"><el-txt><el-id>key</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> as </el-kw><el-field id="type195" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-prop>
<el-kw>end record</el-kw>
</el-class>
</el-code-block>
Having defined a record's Type, such as <el-code>Game</el-code> above, you can create as many instances as you wish using the following syntax to specify the values:
<el-code-block source="snake_FP.elan">
<el-statement class="ok" id="let603" tabindex="0"><el-kw>let </el-kw><el-field id="var604" class="ok" tabindex="0"><el-txt><el-id>g1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr605" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Game</el-type>()<el-kw> with </el-kw><br><el-id>head</el-id><el-kw> set to </el-kw><el-method>newSquare</el-method>(<el-lit>22</el-lit>, <el-lit>15</el-lit>), <br><el-id>key</el-id><el-kw> set to </el-kw>"<el-lit>d</el-lit>", <br><el-id>isOn</el-id><el-kw> set to </el-kw><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<p>Note that you are not <em>required</em> to provide a value for each property because, where a property is not specified in the <el-kw>with</el-kw> clause (as above), that property will be given the empty (default) value of the correct Type.</p>
<p>You can then read the values from the properties using <a href="#dotSyntax">dot syntax</a> for example:</p>
<el-code-block>
<el-statement class="" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional" tabindex="0"><el-txt><el-id>sq</el-id>.<el-id>size</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p><el-code>record</el-code> Types are immutable: the properties on an instance may not be changed directly.
  However, you can create another instance that is a copy of the original,
  with all the same property values except for specific changes made in a <el-kw>with</el-kw> clause.
  The newly-minted copy (with changes) must be assigned to a new named value. For example:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>sq1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>()<el-kw> with </el-kw><br><el-id>x</el-id><el-kw> set to </el-kw><el-lit><el-lit>3</el-lit>.5</el-lit>, <br><el-id>y</el-id><el-kw> set to </el-kw><el-lit><el-lit>4</el-lit>.0</el-lit>, <br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>1</el-lit>.0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="error"></el-msg></el-statement>
</el-code-block>
<el-code-block>
  <el-statement class="" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-lit><el-lit>2</el-lit>.0</el-lit>, <br><el-id>colour</el-id><el-kw> set to </el-kw><el-id>red</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p>Or even to the same name if that name is a <el-kw>variable</el-kw>:</p>
<el-code-block>
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>a</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="selected focused ok" tabindex="-1"><el-txt><input spellcheck="false" data-cursorstart="44" data-cursorend="44" size="43" style="width: 44ch" value="new Square() with x set to 3.5, y set to 4.0" tabindex="-1"></el-txt></el-field></el-statement>
<br>
<el-statement class="ok" id="set6" tabindex="-1"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-id>a</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr8" class="selected focused ok" tabindex="-1"><el-txt><input spellcheck="false" data-cursorstart="24" data-cursorend="24" size="23" style="width: 24ch" value="copy a with x set to 3.7" tabindex="-1"></el-txt></el-field></el-statement>
</el-code-block>
<p>This last example shows how you enter the comma-separated <el-kw>with</el-kw> clauses. The earlier examples show how the Editor displays a set of <el-kw>with</el-kw> clauses.</p>

<p>If you want to use one or more existing property values in order to determine a new value, the property names must be prefixed with the name of the instance being copied, for example:</p>
<el-code-block>
  <el-statement class="" id="let9" tabindex="0"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="0"><el-txt><el-id>sq2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr11" class="" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>sq1</el-id><el-kw> with </el-kw><br><el-id>size</el-id><el-kw> set to </el-kw><el-id>sq1</el-id>.<el-id>size</el-id> + <el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class=""></el-msg></el-statement>
</el-code-block>

<h3 class="no-TOC" id="deconstructRecord">Deconstructing a Record</h3>
<p>A record may be deconstructed, meaning that its properties are read into separate <el-kw>variable</el-kw>s using the same syntax as for deconstructing a Tuple. For example, assuming that Square is a record defined as in the example above, then this code:</p>
<el-code-block>
  <el-statement class="" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>y</el-id>, <el-id>size</el-id>, <el-id>colour</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="" tabindex="0"><el-txt><el-id>mySquare</el-id></el-txt><el-place><i>expression</i></el-place></el-field> <el-msg class="warning"></el-msg></el-statement>
</el-code-block>
<p>will read the <el-code>properties</el-code> into the four names defined.</p>
When deconstructing, the names of the values must match the names of the <el-code>properties</el-code> of the <el-code>record</el-code>. However, the ordering of the names does not have to match the order in which the <el-code>properties</el-code> are defined in the <el-kw>record</el-kw>.

<h2 id="class"><el-kw>class</el-kw></h2>

<p>A <el-kw>class</el-kw> is a user-defined Type offering richer capability than an <a href="enum"><el-kw>enum</el-kw></a>
 or a <a href="#record"><el-kw>record</el-kw></a>.</p>
<p>Unlike a <el-kw>record</el-kw>, a class may have a constructor and procedure methods.</p>
<p>Like any other Type its name must begin with an uppercase letter.</p>

<h3 class="no-TOC">Definition</h3>
<p>Here is an example of <el-code>class</el-code> definition, taken from demo program <el-code>snake_OOP.elan</el-code>:</p>
<el-code-block source="snake_OOP.elan">
<el-class id="class174" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>class </el-kw><el-field id="type175" class="ok" tabindex="-1"><el-txt><el-type>Apple</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text176" class="empty optional ok" tabindex="-1"></el-field></el-top>
<el-prop class="ok" id="prop178" tabindex="-1"><el-kw>property </el-kw><el-field id="ident179" class="ok" tabindex="-1"><el-txt><el-id>location</el-id></el-txt></el-field><el-kw> as </el-kw><el-field id="type180" class="ok" tabindex="-1"><el-txt><el-type>Square</el-type></el-txt></el-field></el-prop>
<el-proc class="ok multiline" id="proc181" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-field id="ident183" class="ok" tabindex="-1"><el-txt><el-method>newRandomPosition</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params184" class="optional ok" tabindex="-1"><el-txt><el-id>snake</el-id> <el-kw>as</el-kw> <el-type>Snake</el-type></el-txt></el-field><el-punc>)</el-punc></el-top>
<el-statement class="ok multiline" id="repeat185" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
<el-statement class="ok" id="let188" tabindex="-1"><el-kw>let </el-kw><el-field id="var189" class="ok" tabindex="-1"><el-txt><el-id>ranX</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr190" class="ok" tabindex="-1"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="let191" tabindex="-1"><el-kw>let </el-kw><el-field id="var192" class="ok" tabindex="-1"><el-txt><el-id>ranY</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr193" class="ok" tabindex="-1"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="set194" tabindex="-1"><el-kw>set </el-kw><el-field id="ident195" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr196" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-id>ranX</el-id>, <el-id>ranY</el-id>)</el-txt></el-field></el-statement>
<el-kw>end repeat when </el-kw><el-field id="expr187" class="ok" tabindex="-1"><el-txt><el-kw>not</el-kw> <el-id>snake</el-id>.<el-method>bodyCovers</el-method>(<el-kw>property</el-kw>.<el-id>location</el-id>)</el-txt></el-field>
</el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-proc class="ok multiline" id="proc197" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-field id="ident199" class="ok" tabindex="-1"><el-txt><el-method>updateBlocks</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params200" class="optional ok" tabindex="-1"><el-txt><el-id>blocks</el-id> <el-kw>as</el-kw> <el-type>Array2D</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-txt></el-field><el-punc>)</el-punc></el-top>
<el-statement class="ok" id="call201" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident202" class="ok" tabindex="-1"><el-txt><el-id>blocks</el-id>.<el-method><el-method>put</el-method></el-method></el-txt></el-field>(<el-field id="args203" class="optional ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>location</el-id>.<el-id>x</el-id>, <el-kw>property</el-kw>.<el-id>location</el-id>.<el-id>y</el-id>, <el-id>red</el-id></el-txt></el-field>)</el-top></el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-kw>end class</el-kw>
</el-class></el-code-block>

<p>A class may define:</p>
<ul>
<li>One or more properties &ndash; see <a href="#property">Property</a></li>
<li><el-code>function</el-code> methods &ndash; see Function method</li>
<li><el-code>procedure</el-code> methods &ndash; see Procedure method</li>
<li>a <el-code>constructor</el-code> which may be used for setting up the values of properties. The <el-code>constructor</el-code> may optionally define parameters to force the calling code to provide initial values. However, it is not necessary to add a <el-code>constructor</el-code> if you have no need to initialise properties. Code in the constructor may make use of any functions, and follows the same constraints as a <el-code>function</el-code> (i.e. it may not call any <el-code>procedure</el-code>, whether defined on the <el-code>class</el-code> or outside).</li>
</ul>

<h3 class="no-TOC">Using a class</h3>
<p>A <el-code>class</el-code> is instantiated using the keyword <el-code>new</el-code> followed by the class name and brackets, which should enclose the comma-separated arguments required to match the parameters (if any) defined on the constructor for that <el-code>class</el-code>. For example (also from demo program <el-code>snake_OOP.elan</el-code>):</p>

<el-code-block source="constructor.elan">
<el-constructor class="ok multiline" id="constructor41" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params43" class="empty optional ok" tabindex="0"><el-compl><i>parameter definitions</i></el-compl></el-field>)</el-top>
<el-statement class="ok" id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="set47" tabindex="0"><el-kw>set </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>currentDir</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-type>Direction</el-type>.<el-id>right</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="set50" tabindex="0"><el-kw>set </el-kw><el-field id="ident51" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>body</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr52" class="ok" tabindex="0"><el-txt>[<el-id>tail</el-id>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="set53" tabindex="0"><el-kw>set </el-kw><el-field id="ident54" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>head</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-id>tail</el-id>.<el-method>getAdjacentSquare</el-method>(<el-kw>property</el-kw>.<el-id>currentDir</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="set56" tabindex="0"><el-kw>set </el-kw><el-field id="ident57" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>priorTail</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr58" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt></el-field></el-statement>
<el-kw>end constructor</el-kw></el-constructor>
</el-code-block>
<p>The created instance may then be used within expressions, like any other named value.</p>

<h3 class="no-TOC" id="this"><el-kw>this</el-kw></h3>
If in the code of class <el-type>A</el-type> you want to invoke a method in class <el-type>S</el-type> <i>and</i> pass to it the current instance of <el-type>A</el-type>,
you can refer to this instance with the keyword <el-kw>this</el-kw>, as shown by this line in demo program <el-code>snake_OOP.elan</el-code>:</p>

<el-code=block source="snake_OOP.elan">
<el-top><el-kw>call </el-kw><el-field id="ident91" class="ok" tabindex="-1"><el-txt><el-id>apple</el-id>.<el-method><el-method>newRandomPosition</el-method></el-method></el-txt></el-field>(<el-field id="args92" class="optional ok" tabindex="-1"><el-txt><el-kw>this</el-kw></el-txt></el-field>)</el-top>
</el-code-block>

<p>Here, method <el-method>newRandomPosition</el-method> is defined on class <el-type>Apple</el-type> which needs to be passed an instance of class <el-type>Snake</el-type>.
(<el-id>apple</el-id> is an instance of class <el-type>Apple</el-type>).</p>

<h3 class="no-TOC" id="inherits"><el-kw>inherits</el-kw></h3>

  <p>An ordinary <a href="#class">class</a> (also known as a concrete class) may optionally inherit from just one <a href="#abstract_class"><el-code>abstract class</el-code></a>
    but may additionally inherit from any number of <a href="#interface">interfaces</a>.
    The concrete class must define for itself a concrete implementation of every <em>abstract</em> member defined in the <el-code>abstract class</el-code> or any <el-code>interface</el-code>s that it inherits from, directly or indirectly.</p>

<h4 class="no-TOC">Notes</h4>
<ul>
  <li>An <el-kw>abstract class</el-kw> must be declared in the code above any class that inherits from it.</li>
  <li>The <el-kw>abstract class</el-kw> (if any) and the interfaces (if any) that a concrete <el-code>class</el-code> inherits from may not contain duplicates of any <el-code>abstract</el-code> member. Any duplicated definitions in the hierarchy will result in a compile error. If such duplications arise, you should factor out the common member definitions, and move them up the hierarchy or into new <el-code>interface</el-code>s inherited by the<el-code> interface</el-code>s and/or classes that need them.</li>
  <li>Inheritance hierarchies must form a tree, that is you must avoid creating a circular dependency where, for example, Type <el-code>A</el-code> inherits from Type <el-code>B</el-code>, which inherits from Type <el-code> C</el-code>, which inherits from Type <el-code>A</el-code>.</li>
  <li>The various 'super-Types' (abstract classes and <el-code>interface</el-code>s) that a concrete <el-code>class</el-code> inherits from must not define conflicting members, e.g. members with the same name but having different Type signatures.</li>
<li>See also example in <a href="#interface"><el-kw>Interface</el-kw></a></li>
</ul>

<h2 id="abstract_class"><el-kw>abstract class</el-kw></h2>
<p>An <el-kw>abstract class</el-kw> may not be instantiated (and hence may not define a constructor). It may define concrete members i.e.:</p>
<ul>
<li>a <el-kw>property</el-kw> </li>
<li>a <el-code>function</el-code></li>
<li>a <el-code>procedure</el-code></li>
</ul>
<p>As with a concrete class, any of these members may be made <el-code>private</el-code>, after the corresponding frame has been added, by selecting that member frame and keying <b>Ctrl+p</b>.</p>
<p>These concrete members are automatically inherited by any subclass, but they may not be overridden (re-defined) by the subclass. Therefore you should define concrete members only if they are intended to work identically on every subclass.</p>

<p>You may also define abstract methods on an <el-code>abstract class</el-code>, i.e. <el-code>abstract property</el-code>, <el-code>abstract function</el-code>, <el-code>abstract procedure</el-code>. Such methods define only the signature of the method, not the implementation (body), therefore they have no <el-code>end</el-code> statement. For example:</p>
<p><el-code><el-kw>abstract function</el-kw> <el-method>calculateDiscount</el-method>() as <el-type>Float</el-type></el-code></p>
<p>
If you wish to have several subclasses of an <el-kw>abstract class</el-kw> that share a common implementation for a method, but require that some of the subclasses can define a different implementation, then you should:</p>
<ul>
<li>Define the method as <el-code>abstract</el-code> on the superclass.</li>
<li>Define a concrete implementation on the superclass with a similar, but slightly different, name e.g. by adding a prefix such as: <el-code>default</el-code>.</li>
<li>Each subclass must then define its implementation of the abstract method, but the ones needing a common implementation can be just one line, delegating responsibility up to the 'default' method on the superclass. </li>
</ul>

<h2 id="interface"><el-kw>interface</el-kw></h2>
<p>An <el-code>interface</el-code> is similar to an <el-code>abstract class</el-code>, with the difference that it may define only abstract members. The advantage of using an <el-code>interface</el-code> instead of an <el-code>abstract class</el-code> is that a concrete<el-code> class</el-code> can inherit from multiple <el-code>interface</el-code>s.</p>
<p>An <el-code>interface</el-code> may inherit only from other <el-code>interface</el-code>s.</p>
<p>Important: An <el-code>interface</el-code> must not redeclare abstract interfaces that are defined in any <el-code>interface</el-code> it inherits from, directly or indirectly.</p>
<p>See also: <a href="#Inheritance">Inheritance</a>.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example using <el-kw>interface</el-kw></h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Example from a version of program <el-code>blackjack.elan</el-code> of:</p>
<ul>
 <li>inheritance from <el-kw>interface</el-kw> <el-type>Player</el-type> to <el-kw>abstract class</el-kw> <el-type>Automated</el-type>
  and to <el-kw>class</el-kw> <el-type>HumanPlayer</el-type>, and</li>
 <li>inheritance from <el-kw>abstract class</el-kw> <el-type>Automated</el-type> to concrete <el-kw>class</el-kw> <el-type>Dealer</el-type></li>
 <li>(concrete) definitions of function <el-method>getAction</el-method> and procedure <el-method>changeScoreBy</el-method> following their
 abstract declarations.</li>
</ul>
<el-code-block source="blackjack.elan">
<el-class class="ok multiline" id="class320" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>interface </el-kw><el-field id="type321" class="ok" tabindex="-1"><el-txt><el-type>Player</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text322" class="empty optional ok" tabindex="-1"></el-field></el-top>
<el-prop class="ok" id="prop324" tabindex="-1"><el-top><el-kw>abstract property </el-kw><el-field id="ident325" class="ok" tabindex="-1"><el-txt><el-id>hand</el-id></el-txt></el-field><el-kw> as </el-kw><el-field id="type326" class="ok" tabindex="-1"><el-txt><el-type>Hand</el-type></el-txt></el-field></el-top></el-prop>
<el-proc class="ok" id="proc327" tabindex="-1">
<el-top><el-kw>abstract procedure </el-kw><el-method><el-field id="ident328" class="ok" tabindex="-1"><el-txt><el-id>changeScoreBy</el-id></el-txt></el-field></el-method><el-punc>(</el-punc><el-field id="params329" class="optional ok" tabindex="-1"><el-txt><el-id>amount</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc></el-top></el-proc>
<el-kw>end interface</el-kw>
</el-class>

<el-class class="ok multiline" id="class330" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>abstract class </el-kw><el-field id="type331" class="ok" tabindex="-1"><el-txt><el-type>Automated</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text332" class="optional ok" tabindex="-1"><el-txt><el-kw>inherits</el-kw> <el-type>Player</el-type></el-txt></el-field></el-top>
<el-prop class="ok" id="prop334" tabindex="-1"><el-kw>property </el-kw><el-field id="ident335" class="ok" tabindex="-1"><el-txt><el-id>hand</el-id></el-txt></el-field><el-kw> as </el-kw><el-field id="type336" class="ok" tabindex="-1"><el-txt><el-type>Hand</el-type></el-txt></el-field></el-prop>
<el-prop class="ok" id="prop337" tabindex="-1"><el-kw>property </el-kw><el-field id="ident338" class="ok" tabindex="-1"><el-txt><el-id>score</el-id></el-txt></el-field><el-kw> as </el-kw><el-field id="type339" class="ok" tabindex="-1"><el-txt><el-type>Int</el-type></el-txt></el-field></el-prop>
<el-func class="ok" id="func346" tabindex="-1">
<el-top><el-kw>abstract function </el-kw><el-method><el-field id="ident347" class="ok" tabindex="-1"><el-txt><el-id>getAction</el-id></el-txt></el-field></el-method><el-punc>(</el-punc><el-field id="params348" class="empty optional ok" tabindex="-1"><el-compl><i>parameter definitions</i></el-compl></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type349" class="ok" tabindex="-1"><el-txt><el-type>Action</el-type></el-txt></el-field></el-top></el-func>
<el-proc class="ok multiline" id="proc386" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-field id="ident388" class="ok" tabindex="-1"><el-txt><el-method>changeScoreBy</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params389" class="optional ok" tabindex="-1"><el-txt><el-id>amount</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc></el-top>
<el-statement class="ok" id="set390" tabindex="-1"><el-kw>set </el-kw><el-field id="ident391" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>score</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr392" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>score</el-id> + <el-id>amount</el-id></el-txt></el-field></el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-kw>end class</el-kw>
</el-class>
<el-class class="ok multiline" id="class393" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>class </el-kw><el-field id="type394" class="ok" tabindex="-1"><el-txt><el-type>Dealer</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text395" class="optional ok" tabindex="-1"><el-txt><el-kw>inherits</el-kw> <el-type>Automated</el-type></el-txt></el-field></el-top>
<el-constructor class="ok multiline" id="constructor397" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>constructor</el-kw><el-punc>(</el-punc><el-field id="params399" class="optional ok" tabindex="-1"><el-txt><el-id>startingPoints</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc></el-top>
<el-statement class="ok" id="set400" tabindex="-1"><el-kw>set </el-kw><el-field id="ident401" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>score</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr402" class="ok" tabindex="-1"><el-txt><el-id>startingPoints</el-id></el-txt></el-field></el-statement>
<el-kw>end constructor</el-kw>
</el-constructor>
<el-func class="ok multiline" id="func422" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident424" class="ok" tabindex="-1"><el-txt><el-method>getAction</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params425" class="empty optional ok" tabindex="-1"><el-compl><i>parameter definitions</i></el-compl></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type426" class="ok" tabindex="-1"><el-txt><el-type>Action</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="return427" tabindex="-1"><el-kw>return </el-kw><el-field id="expr428" class="ok" tabindex="-1"><el-txt><el-kw>if </el-kw><el-kw>property</el-kw>.<el-id>hand</el-id>.<el-id>total</el-id> &lt; <el-lit>17</el-lit><el-kw><br>then </el-kw><el-type>Action</el-type>.<el-id>draw</el-id><el-kw><br>else </el-kw><el-type>Action</el-type>.<el-id>stand</el-id></el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>

<el-kw>end class</el-kw>
</el-class>

<el-class class="ok multiline" id="class436" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>class </el-kw><el-field id="type437" class="ok" tabindex="-1"><el-txt><el-type>HumanPlayer</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text438" class="optional ok" tabindex="-1"><el-txt><el-kw>inherits</el-kw> <el-type>Player</el-type></el-txt><el-place><i>inherits ClassName(s)</i></el-place><el-msg></el-msg></el-field></el-top>
<el-constructor class="ok multiline" id="constructor440" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>constructor</el-kw><el-punc>(</el-punc><el-field id="params442" class="optional ok" tabindex="-1"><el-txt><el-id>startingPoints</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc></el-top>
<el-statement class="ok" id="set443" tabindex="-1"><el-kw>set </el-kw><el-field id="ident444" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>score</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr445" class="ok" tabindex="-1"><el-txt><el-id>startingPoints</el-id></el-txt></el-field></el-statement>
<el-kw>end constructor</el-kw>
</el-constructor>

<el-proc class="ok multiline" id="proc494" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-field id="ident496" class="ok" tabindex="-1"><el-txt><el-method>changeScoreBy</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params497" class="optional ok" tabindex="-1"><el-txt><el-id>amount</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc></el-top>
<el-statement class="ok" id="set498" tabindex="-1"><el-kw>set </el-kw><el-field id="ident499" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>score</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr500" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>score</el-id> + <el-id>amount</el-id></el-txt></el-field></el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-kw>end class</el-kw>
</el-class>
</el-code-block>
<hr>
</div></div>

<h2 id="constant"><el-kw>constant</el-kw></h2>
<p>A <el-kw>constant</el-kw> defines a named value that cannot change, is always defined at global level in a program, and is global in scope.
 Its name  follows the rules for an <a href="#Identifier">identifier</a>.</p>
<p>A constant is defined by a literal of an immutable Type, namely <el-type>Int</el-type>, <el-type>Float</el-type>, <el-type>Boolean</el-type>,
 <el-type>String</el-type>, <el-type>ListImmutable</el-type> or <el-type>DictionaryImmutable</el-type>.</p>
<p>Constants are created at compile time, so cannot be defined with reference to any function, nor can you use any operators in an expression.</p>
<p>A constant can be defined by a previously defined constant or a system constant, but take care not to re-define a <a href="LibRef.html#Constants">system constant</a> such as <el-id>pi</el-id> or <el-id>blue</el-id> without good reason.</p>

<p>Examples of literal definitions of the valid Types of constant:</p>

<el-const class="ok multiline" id="const4" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident5" class="ok" tabindex="-1"><el-txt><el-id>maxHits</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text6" class="ok" tabindex="-1"><el-txt><el-lit>10</el-lit></el-txt></el-field> &mdash; an <el-type>Int</el-type> value</el-const>
<el-const class="ok multiline" id="const53" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident54" class="ok" tabindex="-1"><el-txt><el-id>turquoise</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text55" class="ok" tabindex="-1"><el-txt><el-lit>0x00ced1</el-lit></el-txt></el-field> &mdash;  a hexadecimal <el-type>Int</el-type> value</el-const>
<el-const class="ok multiline" id="const16" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident17" class="ok" tabindex="-1"><el-txt><el-id>liveCell</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text18" class="ok" tabindex="-1"><el-txt><el-id>black</el-id></el-txt></el-field> &mdash;  a copy of a system constant</el-const>
<el-const class="ok multiline" id="const1" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident2" class="ok" tabindex="-1"><el-txt><el-id>phi</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text3" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>1</el-lit>.618</el-lit></el-txt></el-field> &mdash;  a <el-type>Float</el-type> value</el-const>
<el-const class="ok multiline" id="const13" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident14" class="ok" tabindex="-1"><el-txt><el-id>gameOver</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text15" class="ok" tabindex="-1"><el-txt><el-id>true</el-id></el-txt></el-field> &mdash;  a <el-type>Boolean</el-type> value</el-const>
<el-const class="ok multiline" id="const7" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident8" class="ok" tabindex="-1"><el-txt><el-id>warningMsg</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text9" class="ok" tabindex="-1"><el-txt>"<el-lit>Limit reached</el-lit>"</el-txt></el-field> &mdash;  a <el-type>String</el-type> value</el-const>
<el-const class="ok multiline" id="const10" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident11" class="ok" tabindex="-1"><el-txt><el-id>fruit</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text12" class="ok" tabindex="-1"><el-txt>{"<el-lit>apple</el-lit>", "<el-lit>orange</el-lit>", "<el-lit>banana</el-lit>"}</el-txt></el-field> &mdash;  a <el-type>ListImmutable</el-type></el-const>
<el-const class="ok multiline" id="const58" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident59" class="ok" tabindex="-1"><el-txt><el-id>palette</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text60" class="ok" tabindex="-1"><el-txt>{<el-id>red</el-id>, <el-id>blue</el-id>, <el-id>yellow</el-id>, <el-id>turquoise</el-id>}</el-txt></el-field> &mdash;  a <el-type>ListImmutable</el-type> of system and above defined constants</el-const>
<el-enum class="ok multiline" id="enum28" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type29" class="ok" tabindex="-1"><el-txt><el-type>Suit</el-type></el-txt></el-field></el-top> <el-field id="enumVals30" class="ok" tabindex="-1"><el-txt><el-id>spades</el-id>, <el-id>hearts</el-id>, <el-id>diamonds</el-id>, <el-id>clubs</el-id></el-txt></el-field> &mdash;  an <el-kw>enum</el-kw> for use in the following constant <el-id>colours</el-id></el-enum>
<el-const class="ok multiline" id="const19" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident20" class="ok" tabindex="-1"><el-txt><el-id>colours</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text21" class="ok" tabindex="-1"><el-txt>{<el-type>Suit</el-type>.<el-id>spades</el-id>:<el-id>black</el-id>, <el-type>Suit</el-type>.<el-id>hearts</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>diamonds</el-id>:<el-id>red</el-id>, <el-type>Suit</el-type>.<el-id>clubs</el-id>:<el-id>black</el-id>}</el-txt></el-field> &mdash;  a <el-type>DictionaryImmutable</el-type> using <el-kw>enum</el-kw> <el-type>Suit</el-type></el-const>
<el-const class="ok multiline" id="const22" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident23" class="ok" tabindex="-1"><el-txt><el-id>scrabbleValues</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text24" class="ok" tabindex="-1"><el-txt>{"<el-lit>A</el-lit>":<el-lit>1</el-lit>, "<el-lit>B</el-lit>":<el-lit>3</el-lit>, "<el-lit>C</el-lit>":<el-lit>3</el-lit>, "<el-lit>D</el-lit>":<el-lit>2</el-lit>, "<el-lit>E</el-lit>":<el-lit>1</el-lit>, "<el-lit>F</el-lit>":<el-lit>4</el-lit>, "<el-lit>G</el-lit>":<el-lit>2</el-lit>, "<el-lit>H</el-lit>":<el-lit>4</el-lit>, "<el-lit>I</el-lit>":<el-lit>1</el-lit>, "<el-lit>J</el-lit>":<el-lit>8</el-lit>, "<el-lit>K</el-lit>":<el-lit>5</el-lit>, "<el-lit>L</el-lit>":<el-lit>1</el-lit>, "<el-lit>M</el-lit>":<el-lit>3</el-lit>, "<el-lit>N</el-lit>":<el-lit>1</el-lit>, "<el-lit>O</el-lit>":<el-lit>1</el-lit>, "<el-lit>P</el-lit>":<el-lit>3</el-lit>, "<el-lit>Q</el-lit>":<el-lit>10</el-lit>, "<el-lit>R</el-lit>":<el-lit>1</el-lit>, "<el-lit>S</el-lit>":<el-lit>1</el-lit>, "<el-lit>T</el-lit>":<el-lit>1</el-lit>, "<el-lit>U</el-lit>":<el-lit>1</el-lit>, "<el-lit>V</el-lit>":<el-lit>4</el-lit>, "<el-lit>W</el-lit>":<el-lit>4</el-lit>, "<el-lit>X</el-lit>":<el-lit>8</el-lit>, "<el-lit>Y</el-lit>":<el-lit>4</el-lit>, "<el-lit>Z</el-lit>":<el-lit>10</el-lit>}</el-txt></el-field> &mdash;  a <el-type>DictionaryImmutable</el-type></el-const>
</el-code-block>

<h2 id="enum"><el-kw>enum</el-kw></h2>
<p>An <el-kw>enum</el-kw> &ndash; short for 'enumeration' &ndash; provides for the simplest form of user-defined Type.
You define it with a Type name (so starting with an uppercase letter) followed by a
number of values (which must be valid <a href="#Identifier">identifiers</a>).
<p>A reference to an <el-kw>enum</el-kw> by its Type name necessarily holds one of the values.</p>
<p>Reference to the value in an enum is by using <a href="#dotSyntax">dot syntax</a> <el-code>enumType.enumValue</el-code>.</p>
<p>An <el-kw>enum</el-kw> is read-only: once it has been defined it is not possible to add, remove, or update its values.</p>

<p>Examples of definition and use:</p>
<el-code-block source="constants_enum.elan">
<el-enum class="ok multiline" id="enum137" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type138" class="ok" tabindex="0"><el-txt><el-type>Action</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals139" class="ok" tabindex="0"><el-txt><el-id>stand</el-id>, <el-id>draw</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum140" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type141" class="ok" tabindex="0"><el-txt><el-type>Outcome</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals142" class="ok" tabindex="0"><el-txt><el-id>undecided</el-id>, <el-id>win</el-id>, <el-id>lose</el-id>, <el-id>draw</el-id>, <el-id>winDouble</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-enum class="ok multiline" id="enum143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type144" class="ok" tabindex="0"><el-txt><el-type>Status</el-type></el-txt><el-place><i>Name</i></el-place></el-field></el-top> <el-field id="enumVals145" class="ok" tabindex="0"><el-txt><el-id>pending</el-id>, <el-id>playing</el-id>, <el-id>standing</el-id>, <el-id>blackjack</el-id>, <el-id>bust</el-id></el-txt><el-place><i>values</i></el-place></el-field></el-enum>
<el-statement class="ok" id="var69" tabindex="0"><el-kw>variable </el-kw><el-field id="var70" class="ok" tabindex="0"><el-txt><el-id>status</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr71" class="ok" tabindex="0"><el-txt><el-type>Status</el-type>.<el-id>pending</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<p>And from demo program <el-code>snake.OOP.elan</el-code>, some code lines demonstrating reference to the <el-kw>enum</el-kw> <el-type>Direction</el-type> and to its values:</p>
<el-code-block source="snake.OOP.elan">
<el-enum class="ok multiline" id="enum267" tabindex="-1"><el-top><el-expand>+</el-expand><el-kw>enum </el-kw><el-field id="type268" class="ok" tabindex="-1"><el-txt><el-type>Direction</el-type></el-txt></el-field></el-top> <el-field id="enumVals269" class="ok" tabindex="-1"><el-txt><el-id>up</el-id>, <el-id>down</el-id>, <el-id>left</el-id>, <el-id>right</el-id></el-txt></el-field></el-enum>

<el-constructor class="focused ok multiline" id="constructor41" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>constructor</el-kw><el-punc>(</el-punc><el-field id="params43" class="empty optional ok" tabindex="-1"><el-compl><i>parameter definitions</i></el-compl></el-field><el-punc>)</el-punc></el-top>
<el-statement class="ok" id="set47" tabindex="-1"><el-kw>set </el-kw><el-field id="ident48" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>currentDir</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr49" class="ok" tabindex="-1"><el-txt><el-type>Direction</el-type>.<el-id>right</el-id></el-txt></el-field></el-statement>
<el-kw>end constructor</el-kw>
</el-constructor>

<el-func class="focused ok multiline" id="func223" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident225" class="ok" tabindex="-1"><el-txt><el-method>getAdjacentSquare</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params226" class="optional ok" tabindex="-1"><el-txt><el-id>d</el-id> <el-kw>as</el-kw> <el-type>Direction</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type227" class="ok" tabindex="-1"><el-txt><el-type>Square</el-type></el-txt></el-field></el-top>
</el-code-block>

<div id="Member"></div>
<h1 id="MemberInstructions">Member instructions</h1>

<p>Member instructions (also referred to simply as 'members') are located within an
 <el-kw>interface</el-kw>,
 <el-kw>abstract class</el-kw>,
 (concrete) <el-kw>class</el-kw> or
 <el-kw>record</el-kw>.
The <el-code>new code</el-code> prompt will offer a context appropriate subset of the following member instructions:</p>
<p>
 <a href="#abstract_property"><el-kw>abstract property</el-kw></a>,
 <a href="#abstract_function"><el-kw>abstract function</el-kw></a>,
 <a href="#abstract_procedure"><el-kw>abstract procedure</el-kw></a>,
 <a href="#property"><el-kw>property</el-kw></a>,
 <a href="#function"><el-kw>function</el-kw> method</a>,
 <a href="#procedure_method"><el-kw>procedure</el-kw> method</a> and
 <a href="#constructor"><el-kw>constructor</el-kw></a>,
</p>together with these 'private' versions:<p>
 <a href="#private"><el-kw>private property</el-kw></a>,
 <a href="#private"><el-kw>private function</el-kw></a> and
 <a href="#private"><el-kw>private procedure</el-kw></a>.
</p>

<p>This table shows which kinds of property, function or procedure, and constructor are applicable to the various kinds of class.</p>
<table class="tableType">
 <tr>
  <th></th>
  <th colspan="2">Abstract</th>
  <th colspan="2">Concrete</th>
  <th>notes</th>
 </tr><tr>
  <td width="150"></td>
  <td width="40"><a href="#interface"><br><el-kw>interface</el-kw></a></td>
  <td width="40"><a href="#abstract_class"><el-kw>abstract class</el-kw></a></td>
  <td width="40"><a href="#class"><br><el-kw>class</el-kw></a></td>
  <td width="40"><a href="#record"><br><el-kw>record</el-kw></a></td>
  <td></td>
 </tr><tr>
  <td><a href="#abstract_property"><el-kw>abstract property</el-kw></a></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#abstract_function"><el-kw>abstract function</el-kw></a></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td>prototype for function reference only</td>
 </tr><tr>
  <td><a href="#abstract_procedure"><el-kw>abstract procedure</el-kw></a></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td>prototype for procedure call only</td>
 </tr><tr>
  <td><a href="#property"><el-kw>property</el-kw></a></td>
  <td></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
 </tr><tr>
  <td><a href="#function"><el-kw>function</el-kw> method</a></td>
  <td></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
 </tr><tr>
  <td><a href="#procedure_method"><el-kw>procedure</el-kw> method</a></td>
  <td></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#private"><el-kw>private property</el-kw></a></td>
  <td></td>
  <td></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
 </tr><tr>
  <td><a href="#private"><el-kw>private function</el-kw></a></td>
  <td></td>
  <td></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td></td>
 </tr><tr>
  <td><a href="#private"><el-kw>private procedure</el-kw></a></td>
  <td></td>
  <td></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#constructor"><el-kw>constructor</el-kw></a></td>
  <td></td>
  <td></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
 </tr>
</table>

<h2 id="abstract_property"><el-kw>abstract property</el-kw></h2>
<p>An abstract property may be defined only on an <a href="#abstract_class"><el-code>abstract class</el-code></a>. Any concrete subclass must then implement a concrete (regular) property to match.</p>

<h2 id="abstract_function"><el-kw>abstract function</el-kw></h2>
<p>An abstract function method may be defined only on an <a href="#abstract_class"><el-code>abstract class</el-code></a>. Any concrete subclass must then implement a concrete (regular) function to match.</p>

<h2 id="abstract_procedure"><el-kw>abstract procedure</el-kw></h2>
<p>An abstract procedure method may be defined only on an <a href="#abstract_class"><el-code>abstract class</el-code></a>. Any concrete subclass must then implement a concrete (regular) procedure to match.</p>

<h2 id="property"><el-kw>property</el-kw></h2>
<p>A <el-kw>property</el-kw> is a named value defined on a <el-kw>class</el-kw> with a name conforming to the rules for an <a href="#Identifier">identifier</a>,
 and a Type (which may be another class name), for example:</p>
<pre>
<el-code>property height as Int</el-code>
<el-code>property board as Board</el-code>
<el-code>property head as Square</el-code>
<el-code>property body as [Square]</el-code>
</pre>
<p>It may be given an initial value within a <el-kw>constructor</el-kw> but
if it is not thus initialised, then it will be given the default value <el-kw>empty</el-kw> for its Type. You can test whether a property contains this
default thus:</p>
<pre>
<el-code>property names List</el-code>
<el-code>...</el-code>
<el-code>if names is empty List</el-code>
</pre>
</p>A property may be read, but not written to.
Properties may be modified only from outside the class by means of a <a href="#procedure_method">Procedure method</a>.</p>

<h2 id=functionMethod"><el-kw>function</el-kw> method</h2>
<p>A function method follows the same syntax and rules as a global <a href="#function">function</a>. The differences are:</p>
<ul>
<li>A <el-code>function</el-code> method is always referenced (used) by code outside the class using <a href="#dotSyntax">dot syntax</a> on an instance.</li>
<li>A <el-code>function</el-code> method may directly reference (read only) any <el-kw>property</el-kw> defined on the class as though it were a variable or parameter.</li>
<li>A <el-code>function</el-code> method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then keying <b>Ctrl+p</b>. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
<li><el-method>asString</el-method> method is just a regular function method with the specific name, takes no parameters and and returns  a value of type <el-type>String</el-type>.
 If defined for a class then, if an instance of the class is printed, function method <el-method>asString</el-method> will automatically be used.
  Typically <el-method>asString</el-method> will return a string made up of one or more of the property values, perhaps with additional text, or the results of function calls.</li>
</ul>

<h2 id="procedure_method"><el-kw>procedure</el-kw> method</h2>
<p>A 'procedure method' follows the same syntax and rules as a global <a href="#procedure">procedure</a>. The differences are:</p>
<ul>
<li>A procedure method, like a function method, is always referenced (used) by code outside the class using <a href="#dotSyntax">dot syntax</a> on an instance.</li>
<li>A procedure method may read, or write to, any <el-kw>property</el-kw> defined on the class.</li>
<li>A procedure method may be marked <el-code>private</el-code>, in which case it is visible only to code within the class and, if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by selecting the property frame and then keying <b>Ctrl+p</b>. (Pressing these keys again will remove the <el-code>private</el-code> modifier).</li>
</ul>

<h2 id="private"><el-kw>private</el-kw> (property, function, procedure)</h2>
<p>A <el-kw>property</el-kw> may be marked <el-kw>private</el-kw>, in which case it is visible only to code within the class and,
if defined on an <el-code>abstract class</el-code>, within its subclasses. This is done by using the context menu on the property frame or selecting it and keying <b>Ctrl+p</b>.
This action is a toggle used both to set and to remove the modifier <el-kw>private</el-kw>.</p>
<ul>
 <li></li>
 <li>A property that is not private may be read, but not written to.</li>
 <li>A property that is private may </li>
</ul>

<ul>
<li>Whenever you wish to access a property from within a method (or from within the constructor) on the same class, then the name of the property must be prefixed with the 'qualifier': <el-code>property. </el-code>('property-dot'). This applies whether you are reading or setting the property. By this means you can have a method parameter with the same name as a property, but they are unambiguous, because the property must be prefixed. A common pattern is to use the same name in a 'setter' method, for example:</li>
</ul>
<el-code>constructor(board as Board)</el-code><br>
<el-code>  set property.board to board</el-code><br>
<el-code>end constructor</el-code><br>
<br>
<el-code>procedure setHeight(height as Int)</el-code><br>
<el-code>  set property.height to height</el-code><br>
<el-code>end procedure</el-code><br>

<h2 id="constructor"><el-kw>constructor</el-kw></h2>
<p>A (concrete) class may have an optional <el-kw>constructor</el-kw> so as to:</p>
<ul>
 <li>initialise properties with fixed values</li>
 <li>define parameters which are used to initialise properties</li>
</ul>
<p>If a class does define a constructor, and the constructor defines parameters, then when the class is instantiated (using <el-kw>new</el-kw>) the values of
the correct Type must be provided. For example, if the class <el-type>Square</el-type> has this constructor:</p>

<el-code-block>
  <el-constructor class="ok multiline" id="constructor211" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>constructor</el-kw>(<el-field id="params213" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
    <el-statement class="ok" id="set214" tabindex="0"><el-kw>set </el-kw><el-field id="ident215" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>x</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr216" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="set217" tabindex="0"><el-kw>set </el-kw><el-field id="ident218" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>y</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr219" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-kw>end constructor</el-kw>
  </el-constructor>
</el-code-block>

<p>then it may be instantiated like this:</p>

<el-code>
<el-statement id="let44" tabindex="0"><el-kw>let </el-kw><el-field id="var45" class="ok" tabindex="0"><el-txt><el-id>tail</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Square</el-type>(<el-lit>20</el-lit>, <el-lit>15</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>

<div id="statement"></div>
<h1 id="StatementInstructions">Statement instructions</h1>
<p>Statement instructions (also referred to simply as 'statements') are the imperative keywords used in the methods (procedural logic) of a program, and are:</p>
<p>
 <a href="#assert"><el-kw>assert</el-kw></a>,
 <a href="#call"><el-kw>call</el-kw></a>,
 <a href="#each"><el-kw>each</el-kw></a>,
 <a href="#for"><el-kw>for</el-kw></a>,
 <a href="#if"><el-kw>if</el-kw>..<el-kw>then</el-kw>..<el-kw>else if</el-kw>..<el-kw>else</el-kw></a>,
 <a href="#let">let</a>,
 <a href="#print">print</a>,
 <a href="#repeat">repeat</a>,
 <a href="#set">set</a>,
 <a href="#throw">throw</a>,
 <a href="#try">try</a>,
 <a href="#variable">variable</a>,
 <a href="#while">while</a>.
</p>

<h2 id="assert"><el-kw>assert</el-kw> (test)</h2>
<p>The <el-kw>assert</el-kw> statement is used only within a <a href="#test"><el-kw>test</el-kw></a>,
which is the mechanism for running unit tests during program development, not during program execution.</p>
<p>Some programming languages have a feature for making assertions while your program is running.
 In Elan, you can get equivalent functionality by throwing an <el-kw>exception</el-kw>, as described in <a href="#throw">throw</a> statement.</p>

<h2 id="call"><el-kw>call</el-kw> procedure</h2>
<p>A <el-kw>call</el-kw> statement is used when you want to run a <a href="#procedure">procedure</a>.</p>
<p>The procedure may be:</p>
<ul>
<li>a procedure that you have defined at the global level</li>
  <el-statement><el-kw>call</el-kw> <el-method>fillRandom</el-method>(<el-id>grid</el-id>)</el-statement>
<li>a procedure method on an object of a class that you have defined</li>
  <el-statement><el-kw>call</el-kw> <el-id>apple</el-id>.<el-method>newRandomPosition</el-method>(<el-id>snake</el-id>)</el-statement>
  <el-statement><el-kw>call</el-kw> <el-kw>property</el-kw>.<el-id>hand</el-id>.<el-method>draw</el-method>()</el-statement>
<li>a procedure method that belongs to the same class as the procedure that you are calling from</li>
  <el-statement><el-kw>call</el-kw> <el-method>updateNeighbours</el-method>()</el-statement>
<li>a procedure provided by the standard library</li>
  <el-statement><el-kw>call</el-kw> <el-method>pause</el-method>(<el-lit>2000</el-lit>)</el-statement>
<li>a procedure method on an object of a Type provided by the standard library</li>
  <el-statement><el-kw>call</el-kw> <el-id>vg</el-id>.<el-method>append</el-method>(<el-id>rect</el-id>)</el-statement>
  <el-statement><el-kw>call</el-kw> <el-kw>property</el-kw>.<el-id>cards</el-id>.<el-method>append</el-method>(<el-id>card</el-id>)</el-statement>
</ul>
<p>The arguments provided must match the number and Type of the parameters specified in the definition of the procedure. If there are no parameters, leave the brackets empty.</p>
<p>For procedures that you define yourself, <el-kw>out</el-kw> parameters are allowed.  In this case the corresponding argument must be the name of a <el-kw>variable</el-kw> whose value gets updated by the procedure.</p>
<p>If the parameter is not an <el-kw>out</el-kw> parameter, any expression of the correct Type can be used as an argument.</p>
<p>Procedures may have side effects, for example input/output or changing a data value in an object. They can change the contents of any mutable object passed in as an argument.  For this reason, procedures cannot be called from functions, which are not allowed to have side-effects.  <el-kw>call</el-kw> statements are simply not allowed in functions, to enforce this.</p>
<p>There is a limit to the complexity of a <el-kw>call</el-kw> statement.  Only one dot is allowed in the <el-code>procedure name</el-code> field, or two dots if the first word is <el-kw>property</el-kw>.  If you need anything more complicated, use a <el-kw>let</el-kw> statement on the line above.  See the error message explanation for <a href="#ProcRefField">'procedureName' in a call statement</a>.</p>

<h2 id="each"><el-kw>each</el-kw> (loop)</h2>
<p>The <el-kw>each.</el-kw>..<el-kw>in</el-kw>.. construct specifies looping sequentially over the items in a <el-type>List</el-type> or an <el-type>Array</el-type>, or over the characters in a <el-type>String</el-type>.</p>
<p>The <el-kw>each</el-kw> loop counter variable is of the same Type as the items in the List or Array, or is of Type <el-type>String</el-type> if looping over the characters in a String. The variable does not have to have been previously defined.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-code>each</el-code></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To print a <el-type>List</el-type> and then each item in it</p>
<el-code-block source="each.elan">
<el-statement class="ok" id="var16" tabindex="0"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt>["<el-lit>Tom</el-lit>", "<el-lit>Dick</el-lit>", "<el-lit>Harriet</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print30" tabindex="0"><el-kw>print </el-kw><el-field id="expr31" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-lit>0</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="each19" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>each </el-kw><el-field id="ident21" class="ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> in </el-kw><el-field id="expr22" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>source</i></el-place></el-field></el-top>
<el-statement class="ok" id="print23" tabindex="0"><el-kw>print </el-kw><el-field id="expr24" class="optional ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end each</el-kw>
</el-statement>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Function to reverse a <el-type>String</el-type></p>
<el-code-block source="each.elan">
<el-func class="ok multiline" id="func15" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident17" class="ok" tabindex="-1"><el-txt>reverse</el-txt></el-field></el-method>(<el-field id="params18" class="optional ok" tabindex="-1"><el-txt><el-id>s</el-id> <el-kw>as</el-kw> <el-type>String</el-type></el-txt></el-field>)<el-kw> returns </el-kw><el-field id="type19" class="ok" tabindex="-1"><el-txt><el-type>String</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="var36" tabindex="-1"><el-kw>variable </el-kw><el-field id="var37" class="ok" tabindex="-1"><el-txt><el-id>sReturn</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr38" class="ok" tabindex="-1"><el-txt><el-kw>empty</el-kw> <el-type>String</el-type></el-txt></el-field></el-statement>
<el-statement class="ok multiline" id="each28" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>each </el-kw><el-field id="ident30" class="ok" tabindex="-1"><el-txt><el-id>ch</el-id></el-txt></el-field><el-kw> in </el-kw><el-field id="expr31" class="ok" tabindex="-1"><el-txt><el-id>s</el-id></el-txt></el-field></el-top>
<el-statement class="ok" id="set32" tabindex="-1"><el-kw>set </el-kw><el-field id="ident33" class="ok" tabindex="-1"><el-txt><el-id>sReturn</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr34" class="ok" tabindex="-1"><el-txt><el-id>ch</el-id> + <el-id>sReturn</el-id></el-txt></el-field></el-statement>
<el-kw>end each</el-kw>
</el-statement>
<el-statement class="ok" id="return20" tabindex="-1"><el-kw>return </el-kw><el-field id="expr21" class="ok" tabindex="-1"><el-txt><el-id>sReturn</el-id></el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>
</div></div>
<hr>
<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Technical note about each</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; The <el-kw>each</el-kw> instruction creates its own working copy of the subject values through which to loop sequentially.
So even if the subject value is changed in any way within the <el-kw>each</el-kw> loop, this will not affect the items it refers to and  processes.</p>
</div></div>
<hr>

<h2 id="for"><el-kw>for</el-kw> (loop)</h2>
<div id="step"></div>
<p>The <el-code>for..from..to..step..</el-code> construct specifies looping through a sequence of integer values with a given increment.</p>
<p>The <el-code>for</el-code> loop counter <el-kw>variable</el-kw> (which counts from 0) is of Type <el-type>Int</el-type> and does not have to have been defined in a <el-code>variable</el-code> statement.</p>
<p>The three defining values, <el-code>from</el-code>, <el-code>to</el-code>, and <el-code>step</el-code>, must all be of Type <el-type>Int</el-type>, positive or negative.
and may be defined by literals, <el-kw>variable</el-kw>s or expressions that evaluate to integers.</p>
<p>Note that, if you require a negative step value, then the literal, <el-kw>variable</el-kw>, or expression must start with a negative sign.
This is needed at compile time to determine the nature of the exit condition.
So if you have a <el-kw>variable</el-kw> <el-code>s</el-code> that holds a negative value to be used to step in reverse order, then you would write:</p>
<el-code-block source="forStepNeg.elan">
<el-statement class="ok" id="var16" tabindex="0"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt>["<el-lit>Tom</el-lit>", "<el-lit>Dick</el-lit>", "<el-lit>Harriet</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var40" tabindex="0"><el-kw>variable </el-kw><el-field id="var41" class="ok" tabindex="0"><el-txt><el-id>s</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr42" class="ok" tabindex="0"><el-txt>-<el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="for34" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident36" class="ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr37" class="ok" tabindex="0"><el-txt><el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr39" class="ok" tabindex="0"><el-txt>-(-<el-id>s</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="print43" tabindex="0"><el-kw>print </el-kw><el-field id="expr44" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-id>n</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<div id="if"></div>
<div id="then"></div>
<div id="else"></div>
<div id="elseif"></div>
<h2 id="if_statement"><el-kw>if</el-kw></h2>
<p>The <el-kw>if</el-kw> statement specifies which of several code sequences is to be executed next.</p>
<ul>
 <li> It is structured like this:<br>
 <el-kw>if</el-kw> <el-code>condition</el-code> <el-kw>then</el-kw><br>
 &nbsp;&nbsp;<el-code>statements</el-code><br>
 <el-kw>else if</el-kw> <el-code>condition</el-code> <el-kw>then</el-kw><br>
 &nbsp;&nbsp;<el-code>statements</el-code><br>
 <el-kw>else</el-kw><br>
 &nbsp;&nbsp;<el-code>statements</el-code><br>
 <el-kw>end if</el-kw></li>
 <li>The conditions are Boolean values or expressions.</li>
 <li><el-kw>else if</el-kw> and <el-kw>else</el-kw> clauses are optional.</li>
 <li>You can add as many <el-kw>else if</el-kw> clauses as you wish, but only one unconditional <el-kw>else</el-kw> which, if present, must be last.</li>
</ul>
<p>See also <a href="#if_expression"><el-kw>if</el-kw> expression</a> for using the related <el-kw>if</el-kw>  to return a value.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-kw>if</el-kw> statement</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Simple choice between equality and inequality:</p>
<el-code-block source="if_else">
<el-statement class="ok multiline" id="if71" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr73" class="ok" tabindex="0"><el-txt><el-id>head</el-id><el-kw> is </el-kw><el-id>apple</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="call80" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident81" class="ok" tabindex="0"><el-txt><el-method>setAppleToRandomPosition</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args82" class="optional ok" tabindex="0"><el-txt><el-id>apple</el-id>, <el-id>body</el-id></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok outdent" id="else83" tabindex="0"><el-top>
<el-kw>else </el-kw><el-field id="elif85" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
<el-statement class="ok" id="call86" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident87" class="ok" tabindex="0"><el-txt><el-id>body</el-id>.<el-method>removeAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args88" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Choice between an equality, a Boolean and the alternative:</p>
<el-codeblock source="if_else">
<el-statement class="ok multiline" id="if135" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr137" class="ok" tabindex="0"><el-txt><el-id>item</el-id><el-kw> is </el-kw><el-id>value</el-id></el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="set157" tabindex="0"><el-kw>set </el-kw><el-field id="ident158" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr159" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok outdent" id="else174" tabindex="0"><el-top>
<el-kw>else </el-kw><el-kw>if </el-kw><el-field id="expr175" class="ok" tabindex="0"><el-txt><el-id>item</el-id>.<el-method>isBefore</el-method>(<el-id>value</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top></el-statement>
<el-statement class="ok" id="set195" tabindex="0"><el-kw>set </el-kw><el-field id="ident196" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr197" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>lst</el-id>[..<el-id>mid</el-id>], <el-id>item</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok outdent" id="else198" tabindex="0"><el-top>
    <el-kw>else </el-kw><el-field id="elif200" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
<el-statement class="ok" id="set201" tabindex="0"><el-kw>set </el-kw><el-field id="ident202" class="ok" tabindex="0"><el-txt><el-id>result</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr203" class="ok" tabindex="0"><el-txt><el-method>binarySearch</el-method>(<el-id>lst</el-id>[<el-id>mid</el-id> + <el-lit>1</el-lit>..], <el-id>item</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>
<hr>
</div></div>

<h2 id="let"><el-kw>let</el-kw></h2>
<p>The <el-kw>let</el-kw> statement may be thought of as being between a <el-kw>constant</el-kw> definition and a <el-kw>variable</el-kw>'s <el-kw>set</el-kw> statement..
Like a <el-kw>variable set</el-kw> a <el-kw>let</el-kw> may be used only within a routine, but unlike a variable its value may not be changed with a <el-kw>set</el-kw>.
It is recommended that you always use a <el-kw>let</el-kw> in preference to a <el-kw>variable</el-kw> unless you need to be able to assign a new value to it.
</p>
<p>You can put a <el-kw>let</el-kw> in a loop, so the variable gets a new value each time it is executed, but the value of the variable cannot be changed any other way.</p>

<h2 id="print"><el-kw>print</el-kw></h2>
<p>The <el-kw>print</el-kw> instruction sends text strings to the Display pane. For example:</p>
<ul>
 <li><el-code>
    <el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt>"<el-lit>Hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
   &#x27f6; Hello</el-code></li>
<li><el-code>
    <el-statement class="ok" id="let7" tabindex="0"><el-kw>let </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-lit>4</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id>*<el-id>b</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    &#x27f6; 12</el-code></li>
<li><el-code>
    <el-statement class="ok" id="print15" tabindex="0"><el-kw>print </el-kw><el-field id="expr16" class="optional ok" tabindex="0"><el-txt>"<el-lit></el-lit>{<el-id>a</el-id>}<el-lit> times </el-lit>{<el-id>b</el-id>}<el-lit> equals </el-lit>{<el-id>a</el-id>*<el-id>b</el-id>}<el-lit></el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    &#x27f6; 3 times 4 equals 12</el-code></li>
</ul>

<p>The last example above uses <a href="LibRef.html#InterpolatedString">interpolated strings</a>. Arguments placed within curly braces are evaluated before printing, and these may be separated by literal text and punctuation as needed. This is one recommended way to print more than one value on a line. The other way is to use <a href="LibRef.html#printLine">print procedures</a>.</p>
<p>If the <el-kw>print</el-kw> instruction is used without any following expression, then it prints a newline, i.e. its effect is the same as <el-code>print "\n"</el-code>.</p>

<div id="when">
<h2 id="repeat"><el-kw>repeat</el-kw> (loop)</h2>
<p>The <el-kw>repeat..end repeat when</el-kw> <el-code>condition</el-code> loop is used when you want at least one execution of the enclosed statements followed by a test that chooses either to execute them again or to exit from the loop.</p>
<p><el-code>condition</el-code> is either a <el-type>Boolean</el-type> variable or an expression that evaluates to a Boolean value.</p>
<p>If <el-code>condition</el-code> is <el-code><el-id>true</el-id></el-code> then the loop ends, if <el-code><el-id>false</el-id></el-code> it resumes. For example:</p>

<el-code-block source="repeat.elan">
<el-statement class="ok multiline" id="repeat12" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>repeat</el-kw></el-top>
<el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>writeLine</el-method></el-txt></el-field>(<el-field id="args17" class="optional ok" tabindex="0"><el-txt><el-id>names</el-id>[<el-id>i</el-id>]</el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="set18" tabindex="0"><el-kw>set </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-id>i</el-id> + <el-lit>1</el-lit></el-txt></el-field></el-statement>
<el-kw>end repeat when </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-id>i</el-id><el-kw> is </el-kw><el-id>names</el-id>.<el-method>length</el-method>()</el-txt></el-field>
</el-statement>
</el-code-block>

<h2 id="set"><el-kw>set</el-kw></h2>
<p>
The <el-kw>set</el-kw> statement is used to assign a new value to an existing <el-kw>variable</el-kw>.
The new value must be of the same Type as (or a Type compatible with) that of the <el-kw>variable</el-kw>.
A <el-kw>set</el-kw> statement may not assign a new value to a parameter within a procedure unless it the parameter is preceded by <el-kw>out</el-kw> in the parameter list.</p>

<h2 id="throw"><el-kw>throw</el-kw> (exception)</h2>
<p>You can deliberately generate, or 'throw', an exception when a specific circumstance is identified, using a <el-kw>throw</el-kw> statement
 which defines an explanatory string. An example:</p>
<el-code-block source="throw.elan">
<el-statement class="ok multiline" id="if18" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr20" class="ok" tabindex="-1"><el-txt><el-id>value</el-id> &gt; <el-id>maximum</el-id></el-txt></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="throw8" tabindex="-1"><el-kw>throw exception </el-kw><el-field id="msg9" class="ok" tabindex="-1"><el-txt>"<el-lit>proportion exceeds 100%</el-lit>"</el-txt></el-field></el-statement>
<el-statement class="ok outdent" id="else24" tabindex="-1"><el-top>
    <el-kw>else </el-kw><el-field id="elif26" class="empty optional ok" tabindex="-1"></el-field></el-top></el-statement>
<el-statement class="ok" id="set31" tabindex="-1"><el-kw>set </el-kw><el-field id="ident32" class="ok" tabindex="-1"><el-txt><el-id>r</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr33" class="ok" tabindex="-1"><el-txt><el-id>value</el-id>/<el-id>maximum</el-id>*<el-id>r</el-id></el-txt></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>
<p>At runtime, if the condition is met, execution will stop and the Display will show:</p>
<p>
<el-code>A Runtime error occurred in the Elan code</el-code><br>
<el-code>Error: proportion exceeds 100%</el-code>
</p>
<p>This example that puts current values into the exception message string:</p>
<el-code-block source="throw.elan">
<el-statement class="ok multiline" id="if41" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr43" class="ok" tabindex="-1"><el-txt><el-id>yp</el-id><el-kw> is </el-kw><el-lit>0</el-lit></el-txt></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="throw44" tabindex="-1"><el-kw>throw exception </el-kw><el-field id="msg45" class="ok" tabindex="-1"><el-txt>"<el-lit>yp is zero: </el-lit>{<el-id>xp</el-id>}<el-lit>,</el-lit>{<el-id>yp</el-id>}<el-lit> + </el-lit>{<el-id>xq</el-id>}<el-lit>,</el-lit>{<el-id>yq</el-id>}"</el-txt></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-code-block>

<p>For the program to retain control when an exception is raised, put the code that may cause the exception into a <a href="#try"><el-kw>try</el-kw></a> statement,
where you can <el-kw>catch</el-kw> (i.e. receive) the exception message string, and continue as appropriate.</p>

<div id="catch"></div>
<div id="exception"></div>
<h2 id="try"><el-kw>try</el-kw> (test)</h2>
<p>You can test whether another piece of code might throw an exception by wrapping it in a <el-code>try</el-code> statement. This might arise when calling a <a href="LibRef.html#SystemMethods">System method</a> that is dependent upon external conditions, for example:</p>

<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try18" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call38" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident39" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args40" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print47" tabindex="0"><el-kw>print </el-kw><el-field id="expr48" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch20" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok" id="print64" tabindex="0"><el-kw>print </el-kw><el-field id="expr65" class="optional ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>
The variable holding the exception (by default named <el-code>e</el-code>, but this may be changed by you) is of Type <el-type>String</el-type>. You can compare the exception message to one or more expected messages and, if the message does not match an expected exception, you may choose to throw the exception 'up', as in this example:
<el-code-block source="tryCatch.elan">
<el-statement class="ok multiline" id="try141" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call158" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident159" class="ok" tabindex="0"><el-txt><el-method>foo</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args160" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print177" tabindex="0"><el-kw>print </el-kw><el-field id="expr178" class="optional ok" tabindex="0"><el-txt>"<el-lit>not caught</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline outdent" id="catch143" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident145" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok multiline" id="if211" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr213" class="ok" tabindex="0"><el-txt><el-id>e</el-id><el-kw> isnt </el-kw>"<el-lit>an expected message</el-lit>"</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="throw234" tabindex="0"><el-kw>throw exception </el-kw><el-field id="msg235" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>message</i></el-place></el-field></el-statement>
<el-kw>end if</el-kw>
</el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>

<h2 id="variable"><el-kw>variable</el-kw></h2>
<p>The <el-kw>variable</el-kw> statement defines the name to be used to store mutable (i.e. changeable) data. The name defined must be a valid <a href="#Identifier">identifier</a>,
and the initial value is given by a following expression. For example:</p>

<el-code-block>
<el-statement class="ok" id="var40" tabindex="0"><el-kw>variable </el-kw><el-field id="var41" class="ok" tabindex="0"><el-txt><el-id>note</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr42" class="ok" tabindex="0"><el-txt><el-lit>440</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h2 id="while"><el-kw>while</el-kw> (loop)</h2>
<p>The <el-kw>while condition..end while</el-kw> loop is used when you want execution of the enclosed statements to begin
 only if <el-code>condition</el-code> is <el-code><el-id>true</el-id></el-code>.</p>
<p><el-code>condition</el-code> is either a <el-type>Boolean</el-type> <el-kw>variable</el-kw> or an expression that evaluates to a Boolean value.</p>
<p>When <el-code>condition</el-code> is <el-code><el-id>true</el-id></el-code> the enclosed code is executed;
 when <el-code><el-id>false</el-id></el-code> the loop is bypassed. For example:</p>

<el-code-block source="while.elan">
<el-statement id="while6" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>file</el-id>.<el-method>endOfFile</el-method>()</el-txt></el-field></el-top>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>readLine</el-method>()</el-txt></el-field></el-statement>
<el-kw>end while</el-kw>
</el-statement>
</el-code-block>

<h1 id="Expression">Expressions</h1>
<p>One of the most important constructs in programming is the <b>expression</b>. An expression evaluates and returns a value using the following elements:</p>
<ul>
<li><a href="#literalValue">Literal value</a></li>
<li><a href="#namedValue">Named value</a></li>
<li><a href="#operator">Operator</a> (including brackets)</li>
<li><a href="#functionCall"><el-kw>function</el-kw> reference</a></li>
<li><a href="#lambda"><el-kw>lambda</el-kw></a></li>
</ul>

<h2 id="literalValue">Literal value</h2>
<p>A literal value is where a value is written 'literally' in the code, such as <el-code>3.142</el-code> &ndash; in contrast to a value that is referred to by a name.</p>
<p>Here is a table showing some example literal values.  Follow the links for more information about each Type.</p>
<table>
<tr><th>Type</th><th>Example of literal</th></tr>
<tr><td><a href="LibRef.html#Int">Int</a></td><td><el-code>3</el-code></td></tr>
<tr><td><a href="LibRef.html#Float">Float</a></td><td><el-code>2.0</el-code></td></tr>
<tr><td><a href="LibRef.html#Boolean">Boolean</a></td><td><el-code>true</el-code></td></tr>
<tr><td><a href="LibRef.html#String">String</a></td><td><el-code>"Hello"</el-code></td></tr>
<tr><td><a href="LibRef.html#Tuple">Tuple</a></td><td><el-code>tuple(3, "banana")</el-code></td></tr>
<tr><td><a href="LibRef.html#List">List</a></td><td><el-code>["lemon", "lime", "orange"]</el-code></td></tr>
<tr><td><a href="LibRef.html#Dictionary">Dictionary</a></td><td><el-code>["a":3, "b":5]</el-code></td></tr>
<tr><td><a href="LibRef.html#ListImmutable">ListImmutable</a></td><td><el-code>{"lemon", "lime", "orange"}</el-code></td></tr>
<tr><td><a href="LibRef.html#DictionaryImmutable">DictionaryImmutable</a></td><td><el-code>{"a":3, "b":5}</el-code></td></tr>
</table>
<p>For more about List and Dictionary literals see the <a href="LibRef.html#StandardDataStructures">Standard (mutable) data structures</a> table.<br>
For more about ListImmutable and DictionaryImmutable literals see the <a href="LibRef.html#ImmutableDataStructures">Immutable data structures</a> table.</p>

<div id="range"></div>
<h2 id="IndexedValue">Indexed values</h2>
<p>If a variable is of an indexable Type, then an index or index range may be applied to the variable within an expression. For example:</p>
<pre>
    <el-code>variable a set to "Hello World!"</el-code>
    <el-code>print a[4]</el-code>        &#x27f6; <el-code>o</el-code>
    <el-code>print a[4..]</el-code>    &#x27f6; <el-code>o World!</el-code>
    <el-code>print a[..7]</el-code>    &#x27f6; <el-code>Hello W</el-code>   (since the upper bound of a range is <em>exclusive</em>)
    <el-code>print a[0..4]</el-code>  &#x27f6; <el-code>Hell</el-code>         (for the same reason)
</pre>

<p>In the examples above, the result is of Type <el-type>String</el-type> in all cases.</p>
<p>When using indexing on other Types:</p>
<ul>
<li>with a single index, the result is of the same Type as the elements of the data structure being indexed</li>
<li>with an index range, the result is of the same Type as the data structure itself</li>
</ul>
<p>Indexable Types are <a href="LibRef.html#String"><el-type>String</el-type></a>, <a href="LibRef.html#StandardDataStructures"><el-type>Array</el-type>, <el-type>Array2D</el-type>, <el-type>List</el-type>, <el-type>Dictionary</el-type></a>, <a href="LibRef.html#ImmutableDataStructures"><el-type>ListImmutable</el-type> and <el-type>DictionaryImmutable</el-type></a>.</p>
<p>Index ranges cannot be applied to <el-type>Dictionary</el-type> or <el-type>DictionaryImmutable</el-type>.</p>
<p>If the index values in a range are equal, or the second is smaller than the first,
then an empty data structure of the correct Type is generated.</p>
<p>Unlike in many languages, indexes in Elan (whether, single, multiple, or a range) are only ever used for <em>reading</em> values.
Writing a value to a specific index location is done through a method such as in these examples:</p>
<pre>
    <a href="LibRef.html#put_List"><el-method>put</el-method></a>           on a   <el-type>List</el-type>
    <a href="LibRef.html#withPut_ListImmutable"><el-method>withPut</el-method></a>   on a    <el-type>ListImmutable</el-type>
    <a href="LibRef.html#put_Dictionary"><el-method>put</el-method></a>           on a    <el-type>Dictionary</el-type>
    <a href="lIBrEF.HTML#withPut_DictionaryImmutable"><el-method>withPut</el-method></a>   on a    <el-type>DictionaryImmutable</el-type>
</pre>

<div id="operator"></div>
<h2 id="Operators">Operators</h2>

<h3 class="no-TOC" id="ArithmeticOperators">Arithmetic operators</h3>
<p>Arithmetic operators can be applied to <el-type>Float</el-type> or <el-type>Int</el-type> arguments. The result may be a <el-type>Float</el-type> or an <el-type>Int</el-type> depending on the arguments.</p>
<p>For operators <el-code> ^ + - * </el-code> the result is a <el-type>Float</el-type> if either of the arguments is a <el-type>Float</el-type>, and an <el-type>Int</el-type> if both arguments are <el-type>Int</el-type>.</p>
<p>For <el-code> / </el-code> the result is always a <el-type>Float</el-type>. It can be converted to an <el-type>Int</el-type> using standalone function <a href="LibRef.html#floor"><el-method>floor</el-method></a>.</p>
<p id="mod"><el-kw>mod</el-kw> operates only on <el-type>Int</el-type> arguments, and the result is <el-type>Int</el-type>.</p>
<pre>
    <el-code>2^3</el-code>             &#x27f6;  <el-code>8</el-code>
    <el-code>2/3</el-code>             &#x27f6;  <el-code>0.666..</el-code>
    <el-code>2*3</el-code>             &#x27f6;  <el-code>6</el-code>
    <el-code>2 + 3</el-code>         &#x27f6;  <el-code>5</el-code>
    <el-code>2 &minus; 3</el-code>         &#x27f6;  <el-code>&minus;1</el-code>
    <el-code>11 mod 3</el-code>   &#x27f6;  <el-code>2</el-code> (integer remainder)
    <el-code>11 div 3</el-code>   &#x27f6;  <el-code>3</el-code> (integer division) <b><i>deprecated</i></b> from v1.8.1
</pre>
<p>Arithmetic operators follow the conventional rules for precedence i.e. 'BIDMAS' (or 'BODMAS').</p>
<p>When combining <el-code>mod</el-code> with any other operators within an expression, insert brackets to avoid ambiguity e.g.:</p>
<pre>
    <el-code>(5 + 6) mod 3</el-code>
</pre>
<p>Note that <el-code>mod</el-code> is more of a remainder operator than a modulus operator. The result takes the sign of the first argument.
 If both arguments are positive, there is no difference.</p>
<p>The minus sign may also be used as a unary operator, and this takes precedence over binary operators so:</p>
<pre>
    <el-code>2*&minus;3</el-code>           &#x27f6;  <el-code>&minus;6</el-code>
</pre>

<p>For integer division the operator <el-code>div</el-code> works but its use is <b><i>deprecated</i></b> and it will be removed in the future.
The recommended alternative is to use standalone function <a href="LibRef.html#floor"><el-method>floor</el-method></a>.
Note the result when given a negative argument:</p>
<pre>
    <el-code>(11/3).<el-method>floor</el-method>()</el-code>     &#x27f6;   <el-code>3</el-code>
    <el-code>(-11/3).<el-method>floor</el-method>()</el-code>   &#x27f6; <el-code>&minus;4</el-code>
</pre>

<p>The editor automatically puts spaces around the <el-code>+</el-code> and <el-code>&minus;</el-code> binary operators, but not around <el-code>^</el-code>, <el-code>/</el-code> or <el-code>*</el-code>.
This is just to visually reinforce the precedence.</p>

<p>The <el-code>+</el-code> operator is also used for concatenating <a href="LibRef.html#String"><el-type>String</el-type></a> values.</p>

<div id="and"></div>
<div id="not"></div>
<div id="or"></div>
<h3 class="no-TOC" id="LogicalOperators">Logical operators</h3>
<p>Logical operators are applied to <el-code>Boolean</el-code> arguments and return a <el-type>Boolean</el-type> result.</p>
<p><el-code>and</el-code> and <el-code>or</el-code> are binary operators<br>
<el-code>not</el-code> is a unary operator. </p>
<p>The operator precedence is <el-code>not</el-code> &rarr; <el-code>and</el-code> &rarr; <el-code>or</el-code>, so this
example, which implements an 'exclusive or', need not use brackets and can rely on the operator precedence:</p>

<el-code-block source="xor.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>xor</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type>, <el-id>b</el-id> <el-kw>as</el-kw> <el-type>Boolean</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>a</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>b</el-id><el-kw> or </el-kw><el-id>b</el-id><el-kw> and </el-kw><el-kw>not</el-kw> <el-id>a</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw></el-func>
</el-code-block>

<h3 class="no-TOC" id="EqualityTesting">Equality testing</h3>
<p>Equality testing uses the <el-code>is</el-code> and <el-code>isnt</el-code> keywords with two arguments. The arguments may be of any Type.</p>
<ul>
<li><el-code> a is b</el-code> returns <el-kw><el-id>true</el-id></el-kw>, if <el-code>a</el-code> and <el-code>b</el-code> are both of the same Type and their values are equal. The only exception is that if one argument is of Type <el-type>Float</el-type> and the other is of Type <el-type>Int</el-type>, then <el-code>is</el-code> will return <el-code>true</el-code> if their values are the same, i.e. are the same whole number.</li>
<li><el-code>isnt</el-code> returns the opposite of <el-code>is</el-code>.</li>
<li>Where a binary operator is expected, as soon as you type <el-code>is</el-code> the editor will automatically insert a space after it. To enter <el-code>isnt</el-code> you need to delete the space (using the Backspace key) and then type <el-code>nt</el-code>.</li>
</ul>
<p>Note that in Elan equality testing is always 'equality by value'; there is no such thing as 'equality by reference'.</p>
<p>If the items being compared are composite Types, the elements within them are compared sequentially to see if the objects are equal.  For example two distinct instances of the same class compare equal if the values of all their properties compare equal.  And two Lists compare equal if they contain the same elements in the same order.</p>
<p>The compiler rejects any attempt to compare instances of different classes unless abstract classes and inheritance are involved.  Two instances which are subclasses of the same abstract class compare equal only if they are of the same class (and have the same property values).</p>

<h3 class="no-TOC">Numeric comparison</h3>
<p>The numeric comparison operators are:</p>
<pre>
    <el-code>&gt; </el-code>        for     greater than
    <el-code>&lt; </el-code>        for     less than
    <el-code>&gt;=</el-code>        for     greater than or equal to
    <el-code>&lt;=</el-code>        for     less than or equal to
</pre>
<p>Each is applied to two arguments of Type <el-type>Float</el-type>, but any named value or expression that evaluates to an <el-type>Int</el-type> may always be used where a <el-code>Float</el-code> is expected.</p>
<h4 class="no-TOC">Notes</h4>
<ul>
<li>These operators cannot be applied to strings. Use the dot methods <el-code>isBefore</el-code> and <el-code>isAfter</el-code> to compare strings alphabetically.
 See <a href="LibRef.html#isAfter">Dot methods on a String</a>.</li>
<li>Where a binary operator is expected, as soon as you type <el-code>&lt; </el-code>or <el-code>&gt;</el-code> the editor will automatically insert a space after it. To enter <el-code>&lt;=</el-code> or <el-code>&gt;=</el-code> you need to delete the space (using the Backspace key) and then type <el-code>=</el-code>.</li>
</ul>

<h3 class="no-TOC">Combining operators </h3>
<p>You can combine operators of different kinds, e.g. combining numeric comparison with logical operators in a single expression. However the rules of precedence between operators of different kinds are complex. It is strongly recommend that you always use brackets to disambiguate such expressions, for example:</p>

<el-code-block source="combiningOperators.elan">
<el-field id="expr19" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> &gt; <el-id>b</el-id>)<el-kw> and </el-kw>(<el-id>b</el-id> &lt; <el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
<br>
<el-field id="expr35" class="ok" tabindex="0"><el-txt>(<el-id>a</el-id> + <el-id>b</el-id>) &gt; (<el-id>c</el-id> - <el-id>d</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field>
</el-code-block>

<h2 id="functionCall">Function reference</h2>
An expression may simply be a reference to a  function, or it may include several function references within it. Examples:
<el-code-block source="sinDeg.elan">
<el-statement class="ok" id="print5" tabindex="0"><el-kw>print </el-kw><el-field id="expr6" class="optional ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var7" tabindex="0"><el-kw>variable </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-method>sinDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit> + <el-method>cosDeg</el-method>(<el-lit>30</el-lit>)^<el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var10" tabindex="0"><el-kw>variable </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>name</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>inputString</el-method>("<el-lit>Your name</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print13" tabindex="0"><el-kw>print </el-kw><el-field id="expr14" class="optional ok" tabindex="0"><el-txt><el-id>name</el-id>.<el-method>upperCase</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
<li>The third example above is not strictly a function call, but is a 'system method' call.
System methods may be used only within the <el-code>main</el-code> routine or a <el-code>procedure</el-code>, because they have external dependencies or side effects.</li>
<li>In the fourth example, <el-code>upperCase</el-code> is a dot method that may be applied to any instance (variable or literal) of Type <el-type>String</el-type>.
See <a href="LibRef.html#upperCase">Dot methods on a String</a>.</li>
</ul>

<h2 id="lambda"><el-kw>lambda</el-kw></h2>
<p>A <el-kw>lambda</el-kw> is a lightweight means to define a function 'in line'. You typically define a <el-code>lambda</el-code>:</p>
<ul>
<li>If the functionality it defines is needed in only one location: typically for a particular call to a <a href="LibRef.html#HoFs">Higher-order Function</a> (HoF).</li>
<li>If you need to capture a local variable in the implementation. This is called 'closing around a variable'.</li>
</ul>
<p>The syntax for a <el-kw>lambda</el-kw> is as follows:</p>
<ul>
<li>Start with the keyword <el-kw>lambda</el-kw>.</li>
<li>Parameter definitions, comma-separated, follow the same form as parameter definitions in a function or procedure, but without surrounding brackets.</li>
<li>The <el-code>=&gt;</el-code> symbol, which is usually articulated as 'returns',  'yields' or even 'fat arrow'.</li>
<li>An expression that makes use of the parameters, and may also make use of other variables that are in scope. </li>
</ul>
Example:
<el-code-block source="liveNeighbours.elan">
<el-func class="ok multiline" id="func3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>liveNeighbours</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>cells</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Boolean</el-type>&gt;, <el-id>c</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Int</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="let10" tabindex="0"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-method>neighbourCells</el-method>(<el-id>c</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let13" tabindex="0"><el-kw>let </el-kw><el-field id="var14" class="ok" tabindex="0"><el-txt><el-id>live</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr15" class="ok" tabindex="0"><el-txt><el-id>neighbours</el-id>.<el-method>filter</el-method>(<el-kw>lambda</el-kw> <el-id>i</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>cells</el-id>[<el-id>i</el-id>])</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-id>live</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw> </el-func>
</el-code-block>

Notes:<ul>
<li>Although a <el-kw>lambda</el-kw> is commonly defined 'inline' (as shown above) it is possible to assign a lambda to a variable and hence to reuse it within the scope of that variable.</li>
</ul>

<h2 id="if_expression"><el-kw>if</el-kw> expression</h2>

<p>The <el-kw>if</el-kw> expression has a similar structure to the <a href="#if"><el-kw>if</el-kw> statement</a>, but is an expression that returns a value.</p>
<ul>
 <li>The conditions are Boolean values or expressions.</li>
 <li>It specifies which of several expressions is to be evaluated to give the returned value.</li>
 <li><el-kw>else if</el-kw> and <el-kw>else</el-kw> clauses are optional.</li>
 <li>You can add as many <el-kw>else if</el-kw> clauses as you wish, but only one unconditional <el-kw>else</el-kw> which, if present, must be last.</li>
 <li>Though structured like the <el-kw>if</el-kw> statement, it is edited in one field rather than in separate frames.
 On moving away from editing an <el-kw>if</el-kw> expression, it is automatically reformatted to be similar to an <el-kw>if</el-kw> statement,
 though without indentation. This means that an <el-kw>if</el-kw> expression should usually be kept simple.</li>
 <li>An <el-kw>if</el-kw> expression may be used within an <el-kw>if</el-kw> expression but will be hard to read even if it is enclosed in brackets.</li>
</ul>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-kw>if</el-kw> expression:</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Choice in <el-kw>set</el-kw> and <el-kw>let</el-kw> assignments (the brackets around the first <el-kw>if</el-kw> expression are optional):</p>
<el-code-block source="if_exp_assign.elan">
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>c</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><el-lit>1160</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="set6" tabindex="-1"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-id>c</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr8" class="ok" tabindex="-1"><el-txt>(<el-kw>if </el-kw><el-id>c</el-id> &lt; <el-lit>1160</el-lit><el-kw><br>then </el-kw><el-id>c</el-id> + <el-lit>40</el-lit><el-kw><br>else </el-kw><el-id>c</el-id> - <el-lit>1160</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="let9" tabindex="-1"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="-1"><el-txt><el-id>d</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr11" class="ok" tabindex="-1"><el-txt><el-kw>if </el-kw><el-id>c</el-id> &lt; <el-lit>580</el-lit><el-kw><br>then </el-kw><el-id>c</el-id> - <el-lit>40</el-lit><el-kw><br>else </el-kw><el-id>c</el-id> + <el-lit>60</el-lit></el-txt></el-field></el-statement>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Choice in a <el-kw>return</el-kw> statement:</p>
<el-code-block source="wordle.solver.elan">
<el-statement class="ok" id="return16" tabindex="-1"><el-kw>return </el-kw><el-field id="expr17" class="ok" tabindex="-1"><el-txt><el-kw>if </el-kw><el-method>isGreen</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw><br>then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>*</el-lit>")<el-kw><br>else </el-kw><el-id>attempt</el-id></el-txt></el-field></el-statement>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Using <el-kw>else if</el-kw> clause:</p>
<el-code-block source="wordle.solver.elan">
<el-statement class="ok" id="return46" tabindex="-1"><el-kw>return </el-kw><el-field id="expr47" class="ok" tabindex="-1"><el-txt><el-kw>if </el-kw><el-id>attempt</el-id>[<el-id>n</el-id>]<el-kw> is </el-kw>"<el-lit>*</el-lit>"<el-kw><br>then </el-kw><el-id>attempt</el-id><el-kw><br>else </el-kw><el-kw>if </el-kw><el-method>isYellow</el-method>(<el-id>attempt</el-id>, <el-id>target</el-id>, <el-id>n</el-id>)<el-kw><br>then </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>+</el-lit>")<el-kw><br>else </el-kw><el-method>setChar</el-method>(<el-id>attempt</el-id>, <el-id>n</el-id>, "<el-lit>_</el-lit>")</el-txt></el-field></el-statement>
</el-code-block>
<hr>
</div></div>

<h2 id="new"><el-kw>new</el-kw></h2>
<p>A 'new instance' expression is used to create a new instance of a <a href="LibRef.html#StandardDataStructures">library data structure</a>,
   or a <a href="#class"> user-defined class</a> or <a href="#record">record</a> &ndash; either to assign to a named value, or as part
  of a more complex expression. Example of use from demo program <el-code>snake_PP.elan</el-code>:</p>

<el-code-block>
<el-statement id="var5" tabindex="0"><el-kw>let </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>blocks</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Array2D</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;(<el-lit>40</el-lit>, <el-lit>30</el-lit>, <el-id>white</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>Where the new instance is of a <a href="#class"> user-defined class</a> or <a href="#record">record</a> the expression may optionally
be followed by a <el-kw>with</el-kw> clause in order to specify any property values. Example of this use:</p>

<el-code-block source="dealCard.elan">
<el-func class="ok multiline" id="func302" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident304" class="ok" tabindex="-1"><el-txt><el-method>dealCard</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params305" class="optional ok" tabindex="-1"><el-txt><el-id>random</el-id> <el-kw>as</el-kw> <el-type>Float</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type306" class="ok" tabindex="-1"><el-txt><el-type>Card</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="let309" tabindex="-1"><el-kw>let </el-kw><el-field id="var310" class="ok" tabindex="-1"><el-txt><el-id>number</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr311" class="ok" tabindex="-1"><el-txt>(<el-id>random</el-id>*<el-lit>52</el-lit>).<el-method>floor</el-method>()</el-txt></el-field></el-statement>
<el-statement class="ok" id="let789" tabindex="-1"><el-kw>let </el-kw><el-field id="var790" class="ok" tabindex="-1"><el-txt><el-id>rank</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr791" class="ok" tabindex="-1"><el-txt><el-id>rankValue</el-id>.<el-method>keys</el-method>()[(<el-id>number</el-id>/<el-lit>4</el-lit>).<el-method>floor</el-method>()]</el-txt></el-field></el-statement>
<el-statement class="ok" id="let315" tabindex="-1"><el-kw>let </el-kw><el-field id="var316" class="ok" tabindex="-1"><el-txt><el-id>suit</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr317" class="ok" tabindex="-1"><el-txt><el-id>number</el-id><el-kw> mod </el-kw><el-lit>4</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="return307" tabindex="0"><el-kw>return </el-kw><el-field id="expr308" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Card</el-type>()<el-kw> with </el-kw><br><el-id>rank</el-id><el-kw> set to </el-kw><el-id>rank</el-id>, <br><el-id>suit</el-id><el-kw> set to </el-kw><el-id>suit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<div id="copy"></div>
<div id="with"></div>
<h2 id="copyWith"><el-kw>copy</el-kw>..<el-kw>with</el-kw></h2>
<p>A <el-kw>copy..with</el-kw> expression is used to make a copy of an existing instance, but with a different value for one or more of the properties
  &ndash; either to assign to a named value, or as part of a more complex expression.</p>
<p>It is used extensively within functional programming where you are dealing with <a href="#record">record</a>s or other <i>immutable</i> Types.
Example of use in this manner, taken from demo program <el-code>snake_FP.elan</el-code>:</p>

<el-code-block>
<el-func class="ok multiline" id="func72" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident74" class="ok" tabindex="0"><el-txt>newApple</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params75" class="optional ok" tabindex="0"><el-txt><el-id>g</el-id> <el-kw>as</el-kw> <el-type>Game</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type76" class="ok" tabindex="0"><el-txt><el-type>Game</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
  <el-statement class="ok" id="let79" tabindex="0"><el-kw>let </el-kw><el-field id="var80" class="ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>rnd2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr81" class="ok" tabindex="0"><el-txt><el-id>g</el-id>.<el-id>rnd</el-id>.<el-method>nextInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let82" tabindex="0"><el-kw>let </el-kw><el-field id="var83" class="ok" tabindex="0"><el-txt><el-id>y</el-id>, <el-id>rnd3</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr84" class="ok" tabindex="0"><el-txt><el-id>rnd2</el-id>.<el-method>nextInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let85" tabindex="0"><el-kw>let </el-kw><el-field id="var86" class="ok" tabindex="0"><el-txt><el-id>apple2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr87" class="ok" tabindex="0"><el-txt><el-method>newSquare</el-method>(<el-id>x</el-id>, <el-id>y</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let88" tabindex="0"><el-kw>let </el-kw><el-field id="var89" class="ok" tabindex="0"><el-txt><el-id>g2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr90" class="ok" tabindex="0"><el-txt><el-kw>copy</el-kw> <el-id>g</el-id><el-kw> with </el-kw><br><el-id>apple</el-id><el-kw> set to </el-kw><el-id>apple2</el-id>, <br><el-id>rnd</el-id><el-kw> set to </el-kw><el-id>rnd3</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="return77" tabindex="0"><el-kw>return </el-kw><el-field id="expr78" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-method>bodyOverlaps</el-method>(<el-id>g2</el-id>, <el-id>apple2</el-id>)<el-kw> then </el-kw><el-method>newApple</el-method>(<el-id>g2</el-id>)<el-kw><br>else </el-kw><el-id>g2</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-kw>end function</el-kw>
</el-func>
</el-code-block>

<p><el-kw>copy..with</el-kw> may also be used in object-oriented programming with instances of regular (<i>mutable</i>) classes. Also,
  note that a <el-kw>with</el-kw> clause (following the same syntax as in a <el-kw>copy..with</el-kw> expression), may be used
  within a new instance expression to set up properties for the object not specified in the constructor.</p>

<h2 id="empty"><el-kw>empty</el-kw></h2>
<p>An 'empty of Type' expression is used to make the default (empty) instance of any Type
  &ndash; usually only created for comparing to another instance to test whether that other instance is also empty or default.
  This may arise, for example, if a <a href="#class">class</a> or <a href="#record">record</a> is defined with a property that has never had a value assigned to it.
  The following example is taken from demo program <el-code>pathfinder.elan</el-code>:</p>

<el-code-block>
  <el-proc class="ok multiline" id="proc267" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident269" class="ok" tabindex="0"><el-txt>visitNextPoint</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params270" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place><el-compl><i>parameter definitions</i></el-compl></el-field>)</el-top>
    <el-statement class="ok" id="call271" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident272" class="ok" tabindex="0"><el-txt><el-method>updateNeighbours</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args273" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i></i></el-place></el-field>)</el-top></el-statement>
    <el-statement class="ok" id="set274" tabindex="0"><el-kw>set </el-kw><el-field id="ident275" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>current</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr276" class="ok" tabindex="0"><el-txt><el-method>nextNodeToVisit</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok multiline" id="if277" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr279" class="ok" tabindex="0"><el-txt>(<el-kw>property</el-kw>.<el-id>current</el-id><el-kw> is </el-kw><el-kw>empty</el-kw> <el-type>Node</el-type>)<el-kw> or </el-kw>(<el-kw>property</el-kw>.<el-id>current</el-id>.<el-id>point</el-id><el-kw> is </el-kw><el-kw>property</el-kw>.<el-id>destination</el-id>)</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
    <el-statement class="ok" id="set280" tabindex="0"><el-kw>set </el-kw><el-field id="ident281" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>running</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr282" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok outdent" id="else283" tabindex="0"><el-top>
        <el-kw>else </el-kw><el-field id="elif285" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
    <el-statement class="ok" id="call286" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident287" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>current</el-id>.<el-method>setVisited</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args288" class="optional ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
    <el-kw>end if</el-kw>
    </el-statement>
    <el-kw>end procedure</el-kw>
    </el-proc>
</el-code-block>
<p>It is also possible explicitly to set a property or a named value to an empty instance of the appropriate Type.</p>

<h1 id="Comment">Comments</h1>
<h2># comment</h2>
<p>A comment is not an instruction: it is ignored by the compiler and does not change how the program works.
Rather, a comment contains information <em>about</em> the program, intended to be read by a person seeking to understand or modify the code.</p>
<p>Every comment starts with the hash symbol <el-code>#</el-code> followed by some text or a blank line. The text field in
a comment may contain any text, except that it must not start with the open square bracket symbol <el-code>[</el-code>.</p>
<p>Comments may be inserted at any level: in the <a href="#GlobalInstructions">Global</a>,
<a href="#MemberInstructions">Member</a>, or <a href="#StatementInstructions">Statement</a> instruction levels,
as well as from the <el-code>new code</el-code> prompt &ndash; every prompt provides a <el-code>#</el-code> for entering a comment.</p>
<p> Every Elan program has a single comment at the top of the file, which is generated by the system and cannot be edited or deleted by the user.
  This comment is known as the 'file header' and shows the version of Elan being run.</p>

<h1 id="compile_error">Compile errors and warnings</h1>

 <p>Q: What is the difference between a compile <i>error</i> and a <i>warning</i>.</p>
 <p>A: A warning usually indicates that the fix may involve <i>adding</i> some more code,
 for example adding a definition for an unknown identifier. An error usually indicates
 that you will need to <i>alter</i> code to fix the error.
 But they are similar in that you will not be able to run your program until the issues are fixed. In all programming
 languages it is a good practice 'treat all compile warnings as errors' i.e. fix them as soon as you see them appear.</p>

<h2>Messages</h2>

<h3 id="TypeCompileError" class="no-TOC">Expression must be ...</h3>
 <p>An expression, when evaluated, results in a value of a Type that is not compatible with its 'target',
 for example: if the result of the expression is being assigned to an existing variable, or if an expression is defined 'inline' as
 an argument into a method call.</p>

<h3 id="ThisCompileError" class="no-TOC">Cannot use 'this' outside class context</h3>
 <p>The keyword <el-kw>this</el-kw> may only be used within an instance method on a class to refer to the current instance.</p>

<h3 id="DeclaredAboveCompileError" class="no-TOC">Abstract Class ... must be declared before it is used</h3>
 <p>If a class inherits from one or more abstract classes, then the latter must all have already been declared (defined) earlier in the code file.</p>

<h3 id="MemberTypeCompileError" class="no-TOC">Member ... must be of type ...</h3>
 <p>This error occurs when a class is defined as inheriting from an abstract class,
 and has implemented an inherited member (method or property) with the correct name, but with different Types.</p>

<h3 id="TypesCompileError" class="no-TOC">Incompatible types. Expected: ... Provided: ...</h3>

<h3 id="TernaryCompileError" class="no-TOC">Cannot determine common type between ... and ...</h3>

<h3 id="UndefinedSymbolCompileError" class="no-TOC"> ... is not defined for type ...</h3>
 <p>Arises when 'dot calling' a member (method or property) that does not exist on the Type of the named value or expression before the dot.</p>

<h3 id="CannotCallAFunction" class="no-TOC">Cannot call a function as a procedure</h3>
 <p>A function (or function method) is to be used within an expression, not via a <el-kw>call</el-kw> instruction.</p>

<h3 id="CannotUseSystemMethodInAFunction" class="no-TOC">Cannot use a system method in a function</h3>
 <p>A 'system method' (defined in the Standard Library) returns a value like a function does. However, because a system method
 either makes changes to the system and/or depends on external inputs, it may be used only within a procedure or the main routine.</p>

<h3 id="IsDeprecated" class="no-TOC">Code change required ...</h3>
 <p>Indicates that a library method or class has been changed since the version in which your Elan code was written. The link in the
 message should take you directly to information in the Library Reference documentation on how to update your code to cope with the change.</p>

<h3 id="CannotUseLikeAFunction" class="no-TOC">Cannot call procedure ... within an expression</h3>
 <p>A procedure may be used only within a <el-kw>call</el-kw> instruction.</p>

<h3 id="CannotCallAsAMethod" class="no-TOC">Cannot invoke ... as a method</h3>
 <p>The code is attempting to use a free-standing method (function or procedure) as a 'dot method' on a named value or the result of an expression.</p>

<h3 id="NotIndexableCompileError" class="no-TOC">Cannot ...index ...</h3>
 <p>An index (in square brackets) may be applied only to certain data structure Types: <el-type>String</el-type>, <el-type>Array</el-type>, <el-type>Array2D</el-type>,
 <el-type>List</el-type>, <el-type>ListImmutable</el-type>, <el-type>Dictionary</el-type>, and <el-type>DictionaryImmutable</el-type>.</p>

<h3 id="NotRangeableCompileError" class="no-TOC">Cannot range ...</h3>
 <p>A range may be applied only to certain data structure Types: <el-type>String</el-type>, <el-type>Array</el-type>, <el-type>List</el-type>, and <el-type>ListImmutable</el-type>.</p>

<h3 id="NotNewableCompileError" class="no-TOC">Cannot new ...</h3>
 <p>The Type specified after the <el-kw>call</el-kw> keyword cannot be instantiated. Either the Type is inapplicable,
 or it is an abstract class or interface.</p>

<h3 id="InvalidSourceForEachCompileError" class="no-TOC">Source for 'each' must be an Array, List, or String.</h3>

<h3 id="MustBeAbstractCompileError" class="no-TOC">Superclass ... must be inheritable class</h3>
 <p>A concrete class may inherit from an abstract class, and/or an interface, but not from another concrete class.
 In Elan, all classes must be either abstract or 'final' &ndash; a final class being concrete and not-inheritable.</p>

<h3 id="MustBeInterfaceCompileError" class="no-TOC">Superclass ... must be an interface</h3>
 <p>An interface may inherit from other interfaces, but not from any class.</p>

<h3 id="MustNotBeCircularDependencyCompileError" class="no-TOC">Class/interface ... cannot inherit from itself</h3>
 <p>The message is self explanatory.</p>

<h3 id="MustBeSingleAbstractCompileError" class="no-TOC">There must be only one abstract superclass ...</h3>
 <p>A class may inherit from only one abstract class. However, it may additionally inherit from one or more interfaces.</p>

<h3 id="PrivateMemberCompileError" class="no-TOC">Cannot reference private member ...</h3>
 <p>A private member (method or property) may be accessed only by code within the class, or within subclasses of it.
 It may not be accessed by any code outside the class hierarchy.</p>

<h3 id="MustImplementCompileError" class="no-TOC">... must implement ...</h3>
 <p>If a concrete class inherits from any abstract class or interface(s) it must implement all abstract methods defined in those Types.</p>

<h3 id="MustBeConcreteCompileError" class="no-TOC">... must be concrete to new</h3>
 <p>You cannot create an instance of any abstract class or interface: only of a concrete class.</p>

<h3 id="OutParameterCompileError" class="no-TOC">Cannot pass ... as an out parameter</h3>
 <p>If a parameter of a procedure is marked with <el-kw>out</el-kw> then this means that the parameter may be
 reassigned within the procedure. Therefore you must pass in a variable that can be re-assigned. You cannot pass in: a
 constant, a literal value, or a named value that is defined by a <el-kw>let</el-kw> instruction.</p>

<h3 id="ExtensionCompileError" class="no-TOC">Cannot call extension method directly</h3>
 <p>A method that is defined within the Library as an <b>extension method</b>, such as <el-method>asString</el-method>, may be called on a named
 value or an expression only using <a href="#dotSyntax">dot syntax</a>.</p>

<h3 id="PropertyCompileError" class="no-TOC">Cannot prefix function with 'property'</h3>
 <p>The prefix <el-kw>property.</el-kw> may only be used before a property name: not a function name.</p>

<h3 id="MissingParameterCompileError" class="no-TOC">Missing argument(s) ...</h3>
 <p>The method being called expects more arguments than have been provided.</p>

<h3 id="ExtraParameterCompileError" class="no-TOC">Too many argument(s) ...</h3>
 <p>A method has been passed more arguments than it expects.</p>

<h3 id="ParameterTypesCompileError" class="no-TOC">Argument types ...</h3>
 <p>One or more arguments provided to the method are of the wrong Type.</p>

<h3 id="GenericParametersCompileError" class="no-TOC">...&lt;of Type&gt;...</h3>
 <p>Certain data structure Types, including <el-type>Array</el-type>, <el-type>Array2D</el-type>,
 <el-type>List</el-type> must specify the Type of their members, for example <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;.
 Failure to specify the '&lt;of Type&gt;' on these Types will give an error, as will specifying 'of Type' where it is <i>not</i> required.
 Dictionaries require Types to be specified for both the keys and the values,
 for example: <el-code><el-type>Dictionary</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>Float</el-type>&gt;</el-code>.</p>

<h3 id="MutateCompileError" class="no-TOC">May not re-assign the ...</h3>
 <p>Attempting to re-assign, or mutate, a named value that may not be re-assigned in the current context.</p>

<h3 id="NotUniqueNameCompileError" class="no-TOC">Name ... not unique in scope ...</h3>
 <p>Attempting to create an identifier with the same name as one already defined <i>within the same scope</i>.</p>

<h3 id="ReassignInFunctionCompileError" class="no-TOC">May not set ... in a function</h3>
 <p>A property can be re-assigned only within a procedure method, not within a function, because re-assigning a property is a 'side effect'.</p>

<h3 id="RedefinedCompileError" class="no-TOC">The identifier ... is already used for a ... and cannot be re-defined here.</h3>
 <p>An existing named value may not be defined again within the same scope.</p>

<h3 id="DuplicateKeyCompileError" class="no-TOC">Duplicate Dictionary key(s)</h3>
 <p>Attempting to define a literal <el-type>Dictionary</el-type> or <el-type>DictionaryImmutable</el-type>
 with one or more duplicated keys in the definition.</p>

<!-- This message deleted>
<h3 id="FunctionRefCompileError" class="no-TOC">To evaluate function ... add brackets ...</h3>
 <p>If you intend to <i>evaluate</i> a function, the function name must be followed by brackets even if the function
 defines no parameters. If your intent was to define a <i>reference</i> to the function (a pattern used commonly in
 Functional Programming) then only the name of the function is needed.</p>
<-->

<h3 id="NotGlobalFunctionRefCompileError" class="no-TOC">Library or class function ... cannot be used without brackets</h3>
<!-- this text removed when keyword ref removed>
 The keyword <el-kw>ref</el-kw> may be applied only to functions that you have defined in your own code as a standalone (global) function.
 It may not be applied to a function method defined on a class, nor to a library function.
 You may, however, define your own function that simply <i>delegates</i> its implementation to a library function.
<-->

<h3 id="UnknownCompilerDirectiveCompileError" class="no-TOC">a comment may not start with [ unless it is a recognised compiler directive</h3>
 <p>Compiler directives are a planned future capability. They will look like comments, but begin with an open square bracket.
 To avoid the possibility of ambiguity, you may not start your own comments with an open square bracket.</p>

<h3 id="mustBeBooleanCondition" class="no-TOC">Condition of 'if' expression does not evaluate to a Boolean.</h3>

<h3 id="mustNotHaveConditionalAfterUnconditionalElse" class="no-TOC">Cannot have any clause after unconditional 'else'.</h3>

<h3 id="mustNotBeKeyword" class="no-TOC">... is a keyword, and may not be used as an identifier.</h3>
 <p>An Elan keyword cannot be used to as the name for a value, property, or method. Try shortening the name, lengthening it, or using a different name</p>
<p>For reference, the complete list of keywords is:<br><el-code>#, abstract, and, as, assert, be, call, catch, class, constant, constructor, copy, div,
 each, else, empty, end, enum, exception, for, from, function, global, if, image, in, inherits, interface, is, isnt, lambda, let, library, main, mod,
 new, not, of, or, out, print, private, procedure, property, record, ref, repeat, return, returns, set, step, test, then, this, throw, to, try,
 variable, while, with </el-code></p>

<h3 id="mustNotBeReservedWord" class="no-TOC">...  is a reserved word, and may not be used as an identifier.</h3>
 <p>In addition to Elan keywords there are certain other 'reserved words' that cannot be used to define the name for a
 value, property, or method.If you encounter this error you may eliminate the error simply by adding
  more valid characters to the name &ndash; for example just by changing <el-id>case</el-id> to <el-id>case_</el-id>.</p>
 <p>Why are there any reserved words that are not Elan keywords? There are three kinds of reserved word:</p>
 <ul>
  <li><i>Potential</i> keywords that might be added to Elan in future releases.</li>
  <li>Lowercase versions of Elan Type names, such as <el-code>int, float, string, boolean, array, list, dictionary</el-code>.
  It is not considered good practice to use Type names for identifiers: instead you should give each identifier a name that indicates
  what it does (for a method), or represents (for a named value).</li>
  <li>Words that are keywords in JavaScript (but not in Elan). Elan compiles to JavaScript and
  use of these words as identifiers could cause errors. (If you are asking, 'Why doesn't the Elan compiler
  just obfuscate these?' the answer is that we evaluated that option but concluded that it added a lot of
  complexity &ndash; especially in regard to debugging and interaction with the Elan editor &ndash; just to eliminate
  the minor inconvenience of having to extend the word so as to make your identifier distinct.)</li>
 </ul>
<p>For reference, the complete list of reserved words is:<br><el-code>action, arguments, array, async, await, boolean, break, by, byte, case, char,
 const, continue, curry, debugger, default, delete, dictionary, do, double, eval, export, extends, final, finally, float, goto, ignore, implements,
 import, instanceof, int, into, list, long, match, namespace, native, null, on, optional, otherwise, package, partial, pattern, protected, public,
 short, static, string, super, switch, system, synchronized, throws, todo, transient, typeof, void, volatile, var, when, yield</el-code></p>

<h3 id="mustNotBeNegativeIndex" class="no-TOC">Index cannot be negative.</h3>
 <p>An index into an array or list cannot have a negative value. If a negative is given in literal form e.g.
 <el-code><el-id>a</el-id>[-<el-lit>3</el-lit>]</el-code> then this will generate a compile error.
 If you use a named value for an index and it is negative, then this will cause a runtime error.</p>

<h3 id="CannotCompareProcFunc" class="no-TOC">Cannot do equality operations on Procedures or Functions.</h3>
 <p>It is not possible to apply comparison operations to functions or procedures as themselves.
 It is, however, possible to compare the results of two function evaluations.
 You may see this message because you intended to evaluate a function but forgot to add the brackets after the name.</p>

<h3 id="mustBeImmutableType" class="no-TOC">Property ... is not of an immutable type.</h3>
 <p>Properties on a <a href="#record">record</a> may only be of immutable Types.</p>

<h3 id="mustBeImmutableGenericType" class="no-TOC">... cannot be of mutable type ...</h3>
 <p>Element Type for a <a href="LibRef.html#ListImmutable">ListImmutable</a> must itself be an immutable Type.
 Similarly, for an <a href="LibRef.html#DictionaryImmutable">DictionaryImmutable</a> the Types for both the key and the value must be immutable ones.</p>

<h3 id="mustBeValidKeyType" class="no-TOC">... cannot have key of type ...</h3>
 <p>The Type of the key for any dictionary <a href="LibRef.html#Dictionary">Dictionary</a> must be an immutable Type, and not itself an indexable Type.</p>

<h3 id="invalidPropertyInRecordDeconstruction" class="no-TOC">No such property ... on record ...</h3>
 <p>The property name given in the record deconstruction does not match a property on the given Type of record.</p>

<h3 id="discardInRecordDeconstruction" class="no-TOC">Cannot discard in record deconstruction ...</h3>

<h3 id="mustBeCompatibleDefinitionNode" class="no-TOC">Wrong number of deconstructed variables.</h3>

<h3 id="mustBePropertyPrefixedOnMember" class="no-TOC">referencing a property requires a prefix.</h3>
 <p>If you are referring to a property of a class <i>from code defined within the class</i> then the
 property name must be preceded by <el-kw>property</el-kw>.</p>

<h3 id="mustNotBeOutParameter" class="no-TOC">'out' parameters are only supported on procedures.</h3>
 <p>You cannot defined an <el-kw>out</el-kw> parameter in a function (because that would
 imply the possibility of creating a side effect).</p>

<h3 id="mustNotHaveDuplicateMain" class="no-TOC">There can only be one 'main' in a program.</h3>

<h3 id="mustNotBeTwoUnaryExpressions" class="no-TOC">Unsupported operation.</h3>
 <p>You cannot chain two 'unary' operators (those that apply to a single value), such as <el-code>-</el-code>
 or <el-kw>not</el-kw> successively within an expression.</p>

<h3 id="paramNameNotSameAsItsMethod" class="no-TOC"> Parameter ... may not have the same name as the method in which it is defined.</h3>
 <p>A function or procedure named e.g. 'foo' may not define a parameter with that same name.</p>

<h2>Field help</h2>

<h3 id="ArgListField" class="no-TOC">'arguments' field in a call instruction</h3>
 <p>An argument list passed into a function or procedure call, must consist of one or more arguments separated by commas.
 Each argument may in general be any of:</p>
<ul>
 <li>A literal value</li>
 <li>A named value</li>
 <li>An expression</li>
</ul>
 <p>In certain very specific contexts, however, some options are disallowed by the compiler.</p>

<h3 id="AssertActualField" class="no-TOC">'computed value' field in an assert instruction</h3>
 <p>The 'actual' field should be kept as simple as possible, <i>preferably</i>
 just a named value or a function evaluation. Generally, if you want to use a more
 complex expression, it is better to evaluate it in a preceding <el-kw>let</el-kw>
 instruction and then use the named value in the 'actual' field of the <el-kw>assert</el-kw>
 instruction. Some more complex expressions are permissible, but these two restrictions apply:</p>
 <ul>
  <li>Any expression involving a binary operator such as <el-code>+</el-code>, <el-kw>isnt</el-kw>, etc.,
  must have brackets around it.</li>
  <li>You may <i>not</i> use the <el-kw>is</el-kw> operator within the 'actual' field, because
  the parser will confuse this with the <el-kw>is</el-kw> keyword that is part of the <el-kw>assert</el-kw> instruction.</li>
 </ul>

<h3 id="AssignableField" class="no-TOC">'variable name' field in a set instruction</h3>
 <p>The first field in a <el-kw>set</el-kw> instruction most commonly takes the name of an existing variable.
 It may, however, may also take the following forms:
 <ul>
  <li>Within a <el-kw>class</el-kw> it may take the form <el-kw>property</el-kw><el-code>.</el-code><el-id>name</el-id> to set the property <el-id>name</el-id></li>
  <li>A tuple deconstruction. See <a href="LibRef.html#deconstructTuple">Tuple</a></li>
  <li>A list deconstruction. See <a href="LibRef.html#deconstructList">List</a></li>
 </ul></p>

<h3 id="CommentField" class="no-TOC">'comment' field</h3>

<h3 id="ConstantValueField" class="no-TOC">literal value or data structure in a constant</h3>
 <p>The value of a constant must be a literal value of a Type that is not mutable.
 This can be a simple value (e.g. a number or string), or an <i>immutable</i> List or Dictionary.</p>

<h3 id="EnumValuesField" class="no-TOC">'values' field in an enum definition</h3>
 <p><el-kw>enum</el-kw> values must each be a valid identifier, separated by commas.</p>

<h3 id="ExceptionMessageField" class="no-TOC">'message' field in a throw instruction</h3>
 <p>An exception message must  be either a literal string or a named value holding a string.</p>

<h3 id="ExpressionField" class="no-TOC">expression field - used within multiple instructions</h3>
 <p>This field expects an expression. For the various forms of expression see <a href="#Expression">Expressions</a>.</p>

<h3 id="IdentifierField" class="no-TOC">identifier field - used within multiple instructions</h3>

<h3 id="IfSelectorField" class="no-TOC">'if' field in an else clause</h3>

<h3 id="InheritsFromField" class="no-TOC">'inherits ClassName' field in a class</h3>
 <p>An inheritance clause, if used, must consist of the keyword <el-kw>inherits</el-kw>
 followed by a space and then one or more Type names separated by commas.</p>

<h3 id="MethodNameField" class="no-TOC">'name' field in a function or procedure definition</h3>
 <p>A method name must follow the rules for an <a href="#Identifier">identifier</a>.</p>

<h3 id="ParamListField" class="no-TOC">'parameter definitions' in a function or procedure definition</h3>
 <p>Each parameter definition takes the form:</p>
 <el-code><el-id>name</el-id> <el-kw>as</el-kw> <el-type>Type</el-type></el-code>
 <p>The name must follow the rules for an <a href="#Identifier">identifier</a>.</p>
 <p>The Type must follow the rules for a <a href="#parse_type">Type</a>.</p>
 <p>If more than one parameter is defined, the definitions must be separated by commas.</p>

<h3 id="ProcRefField" class="no-TOC">'procedureName' in a call statement</h3>
 <p>Valid forms for a procedure call are
 <ul>
  <li><el-kw>call</el-kw> <el-method>procedureName</el-method>()</li>
  <li><el-kw>call</el-kw> <el-id>instanceName</el-id>.<el-method>procedureMethodName</el-method>()</li>
  <li><el-kw>call</el-kw> <el-kw>property</el-kw>.<el-id>propertyName</el-id>.<el-method>procedureMethodName</el-method>()</li>
  <li><el-kw>call</el-kw> <el-kw>library</el-kw>.<el-method>procedureName</el-method>()</li>
 </ul>
 The last one is used only if there is a need to disambiguate between a library procedure and a user-defined (global)
 procedure with the same name.</p>

<h3 id="TypeField" class="no-TOC">'Type' field in a function or property definition</h3>
 <p>For certain Types the name may be followed by an <el-kw>of</el-kw> clause, for example:</p>
<el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;<br>
<el-type>Dictionary</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>Int</el-type>&gt;

<h3 id="TypeNameField" class="no-TOC">'Name' field in a class or enum definition</h3>
 <p>Type names always begin with a capital letter, optionally followed by letters of either case, numeric digits,
 or underscore symbols. Nothing else.</p>

<h3 id="ValueDefField" class="no-TOC">'name' field in a let or variable instruction</h3>
 <p>The definition for a variable or for a <el-kw>let</el-kw> statement is most commonly
 a simple name. Less commonly, it may take the form of a dconstruction of a
 <a href="LibRef.html#deconstructList">List</a>,
 <a href="LibRef.html#deconstructListImmutable">ListImmutable</a>,
 <a href="LibRef.html#deconstructTuple">Tuple</a> or
 <a href="#deconstructRecord">Record</a>.</p>

<h2>Advisory</h2>

<h3 id="methodDeprecated" class="no-TOC">Code change suggested. Method was deprecated in v7.1.</h3>

<h3 id="divDeprecated" class="no-TOC">'div' is deprecated. Recommended code for integer division is e.g. (10/3).floor()</h3>

<h1 id="runtime_error">Runtime errors</h1>

<h2>Messages</h2>

<h3 id="TestTimeout" class="no-TOC">Tests timed out and were aborted</h3>
<p>An error or infinite loop found in a test. Refer to <a href="#ignore">ghosting tests</a>.</p>

<h3 id="complexityWarning" class="no-TOC">Overly complex expressions</h3>
<p>Overly complex expressions &ndash; for example involving a sequence of open brackets &ndash; can result in
very slow parsing. We strongly recommend that you you simplify the contents of this field, for example by
breaking out parts of it into separate <el-kw>let</el-kw> statements; otherwise it might become impossible to add more text.</p>

<h3 id="ReferenceError" class="no-TOC">ReferenceError: Cannot access '[name]' before initialization</h3>

<hr>
<p><b>Elan Language Reference</b> go to the <a href="#top">top</a></p>
<script>
  var accordions = document.getElementsByClassName("acc-title");
  for (const item of accordions) {
    item.addEventListener("click", function() {
      item.parentElement.classList.toggle("active");
    });
    item.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        item.parentElement.classList.toggle("active");
      }
    });
  }
</script>
</body>
</html>