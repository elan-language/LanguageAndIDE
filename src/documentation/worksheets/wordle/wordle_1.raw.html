<title>Wordle</title>
<step>
    <h1>Step STEPNUMBER: Introduction</h1>
    <p>We are going to create a working implementation of the Wordle puzzle.
        If you have never previously solved a Wordle puzzle, you should visit the 
        <a href="https://www.nytimes.com/games/wordle/index.html" target="_blank">official Wordle site</a>
        and solve today's puzzle, so you know how it works.</p>
    <ul>
        <li>Click the button to load the starting code into the code editor: 
          <button class="load" value="documentaion/worksheets/wordle/wordle_1begin.elan">Load</button> and then run the program.</li>
        <li>On the <b>Display</b> you will see 
        a facsimile of the puzzle, and if you enter your first guess
        (five letters - using <b>Backspace</b> if you make a mistake - then <b>Enter</b>) each
        letter will be marked green, yellow, or grey. But if you continue with further guesses
        you will quickly discover that it marks <i>every</i> guess word with the same result!
        Though this program has correctly implemented the <i>presentation</i>, and the
        <i>user interactions</i>, of the official puzzle, 
        it hasn't implemented the core logic of how guesses are marked.</li>
        <li>In the code, look at instruction number 12 - the <el-method>markAttempt</el-method>
        function. Comments within the function boydy state that the current implementation is just a 'stub' - the minimum code needed
        to allow the program to compile and run. It returns
        a five-character string, as expected: <code>2</code> for an 'in-place' match (green), 
        <code>1</code> for an 'out-of-place' match (yellow), or <code>0</code> for no match (grey). But
        it always returns the same mark, paying no attention to the two parameters: the 
        #<code>attempt</code> word (your guess) and the <code>target</code> word 
        (selected by the computer but hidden from the user).</li>
        <li>Immediately following the <el-method>markAttempt</el-method> function you will see a <code>test</code>
            which has been 'ghosted'. Select the test and <b>unghost</b> (via the context menu: <b>Ctrl-m</b> or right-mouse-click).
             The tests will automatically run a couple of seconds later.
        <question>How many of the <code>assert</code> instructions within the test have failed?</question>
        </li>
        <li><el-method>markAttempt</el-method> function, change the 'default' value to which the <code>mark</code> string is set, so that it returns a string of five zeroes.</li>
        <question>Which, if any, of the <code>assert</code> instructions within the tests now pass?</question>
        </ul>
</step>

<step>
  <h1>Step STEPNUMBER: Mark 'green' matches correctly</h1>
  <ul>
    <li>If you were telling a person  how to mark an attempt word against a target word <i>manually</i>,
        you would probably tell them to look for any 'green' matches first. (It's more complicated to
        to it any other way.) In the <code>test</code> you can see that the first few (failing) tests are
        all looking just for green matches. So, your first task is to write an implementation that gets the four 
        'Only greens' tests passing.</li>
    <li>The <el-method>markAttempt</el-method> function will need to set individual characters within
        the five-character <code>mark</code> string.</li>
  </ul>
  <question>Before using the first hint, enter any code you have written, ideas that you have, and/or things
    that you don't know or understand.
  </question>
  <hint>Hint HINTNUMBER Key ideas</hint>
  <content>
    <ul>
      <li>You can access an individual character within a string by 'indexing'. Indexes start from 0, 
        you can access just the first character of a string held by the named value <el-id>a</el-id> with
        <code>a[0]</code>.</li>
      <li>Given that you need to check each of the five character positions in turn, this suggests a loop.
        Think about which <i>kind</i> of loop is most suitable.</li>
      <li>You will need a condition for testing whether there is a 'green' match between the character in the attempt word
        and the target word.
      </li>
      <li>When there is a match you will need to change the mark (for that character position) from a
        <el-lit>0</el-lit> to a <el-lit>2</el-lit>. This is the trickiest part of this step, because 
        <code>String</code> is an 'immutable' type in Elan (as it is in most programming languages): 
        so you can't change its contents <i>>directly</i>. Instead,
        you must build a new string out of parts of the input one with necessary changes incorporated.
        Use 'index ranges' to help build this new string from parts of the original.
        If you are not familiar with 'index ranges': look them up in <b>Library Reference - Value Types - String</b> within the <b>Help</b> tab </li>
    </ul>
    <question>Before using another hint, enter any code you have written, ideas that you have, and/or things
      that you don't know or understand.</question>
  </content>
  <hint>Hint HINTNUMBER More detail</hint>
  <content>
    <ul>
      <li>Use a <el-kw>for</el-kw> loop. The <i>suggested</i> name for the counter is 
        <el-id>i</el-id> (short for 'index'). You don't <i>have</i> to use
        this name, but this name is assumed in further hints. 
        Remember that the 'counter' variable needs to start from zero, when used
      for indexing. Think: what value should to count <i>to</i>, in order to include all five character positions in turn?</li>
      <li>Use an <el-kw>if</el-kw> instruction to implement the condition. Remember that to test if two values
      are the same you use the <el-kw>is</el-kw> keyword (separated from the values by a space). You will be comparing
      the same indexed value from the <el-id>attempt</el-id> and <el-id>target</el-id> strings.</li>
      <li>Build the string to be returned from three parts: the existing string up to (but not including) the character to be changed;
        the new character; a copy of the original string <i>following</i> the character being changed.
        Carefully check your ideas against the rules for index ranges in the documentation (<b>help</b> tab).
      </li>
    </ul>
    <question>Before using the another hint, enter any code you have written, ideas that you have, and/or things
      that you don't know or understand.</question>
  </content>
  <hint>Hint HINTNUMBER The instruction to modify the mark</hint>
  <content>
    <ul>
      <li>Use a <el-kw>set</el-kw> instruction to replace the existing value of <el-id>mark</el-id> with a new one.</li>
      <li>The expression for the right hand side of the <el-kw>set</el-kw> instruction looks like this:
      <codeblock>
        mark[something] + "2" + mark[something]
      </codeblock>
      where you need to replace 'something' with a range - different for the two cases. The first range will be for
      the characters <i>up to but not including</i> the current index, the second range will be from the
      character <i>after</i> the current index, onwards.
      </li>
      <li>When you are writing a tricky expression like this, it can be very helpful to write your own test
        <i>just for that expression</i>. Add this code below the function:
        <codeblock>
          test ranges
            let mark be "00000"
            let i be 3
            assert mark[something] + "2" + mark[something] is "00020"
          end testing
        </codeblock>
        again replacing <el-id>something</el-id> with the ranges, until you have the tests passing.
        (Remember that tests will run only if all <i>other</i> code is parsing <i>and</i> compiling - if necessary
        temporarily delete any incomplete instructions until you have this test passing.)
      </li>
      <question>Before using the another hint, enter any code you have written, ideas that you have, and/or things
        that you don't know or understand.</question>
    </ul>
  </content>
  <hint>Hint HINTNUMBER The complete code for the function</hint>
  <content>
    <p>You can delete the comments as they are no longer needed.<p>
    <codeblock>
    function markAttempt(attempt as String, target as String) returns String
      variable mark set to "00000"
      for i from 0 to 4 step 1
        if (attempt[i] is target[i]) then
          set mark to mark[..i] + "2" + mark[i + 1..]
        end if
      end for
      return mark
    end function    
    </codeblock>
  </content>
  <question>When you have completed the Step, paste in your completed <el-method>markAttempt</el-method> function here:</question>
</step>

<step>
  <h1>Step STEPNUMBER</h1>
    <ul>
        <li>Now we will tackle the yellows. Underneath the <code>for</code> loop that you just created,
        create a <i>second</i> loop using the same values. (It might be tempting to try to process the greens and yellows
        within the same loop, but you would find that to be <i>much</i> more difficult in the end.) 
        The new loop can use the same name for the counter, because the previous loop will already have finished using it.</li>
        <li>Within the new loop add an <code>if</code> instruction as before, but for our first stab at this,
        use the condition that the <code>target</code> word <i>contains</i> the character of interest.</li>
        <li>If it does then set the corresponding character in <code>mark</code> using the same expression as in the
        previous ('greens') loop, but setting the character to <el-lit>1</el-lit> instead of <el-lit>2</el-lit>.</li>
        <li>This first stab should get <i>most</i> (but not all) of the 'Yellow only' cases passing.
        However, it will also have caused an unwanted consequence!</li>
    </ul>
    <hint>Hint HINTNUMBER The condition</hint>
    <content>The condition is: <code>target.contains(attempt[n])</code></content>
    <hint>Hint HINTNUMBER Outline for the second loop</hint>
    <content>
        <code>
  for n from 0 to 4 step 1
    if something then
      set something to something
    end if
  end for
</code>
    </content>
    <hint>Hint HINTNUMBER The complete function (so far)</hint>
    <content>
        <code>
function markAttempt(attempt as String, target as String) returns String
  variable mark set to "00000"
  for n from 0 to 4 step 1
    if attempt[n] is target[n] then
      set mark to setChar(mark, n, "2")
    end if
  end for
  for n from 0 to 4 step 1
    if unused.contains(attempt[n]) then
      set mark to setChar(mark, n, "1")
    end if
  end for
  return mark
end function
</code>
    </content>
    <question>What is that unwanted consequence and why do you think this has happened? (Look at the individual cases in the tests).</question>
    <p>We will fix that in the next step.</p>
</step>

<step>
  <h1>Step STEPNUMBER: mark the yellows without over-writing any existing 'green' marks.</h1>
    <ul>
        <li>The problem is: letters that were marked green in the first loop, are being 'overwritten'
            by a yellow. In the second loop we need to exlude any characters that have already been 
            marked green. Attempt it now by modifying the <code>if</code> condition within in the second loop. You should
            get all the 'Green only' cases passing again, and <i>all except one</i> of the 'Yellow only'
         <hint>Hint HINTNUMBER The condition</hint>
         <content><code>(mark[n] isnt "2")</code></content>
         Add this to the existing condition using the <code>and</code> operator. 
         <hint>Hint HINTNUMBER The complete function</hint>
         <content>
            <code>
          function markAttempt(attempt as String, target as String) returns String
            variable mark set to "00000"
            for n from 0 to 4 step 1
              if attempt[n] is target[n] then
                set mark to setChar(mark, n, "2")
              end if
            end for
            for n from 0 to 4 step 1
              if (mark[n] isnt "2") and target.contains(attempt[n]) then
                set mark to setChar(mark, n, "1")
              end if
            end for
            return mark
          end function
        </code>
         </content>
         <question>Try removing the brackets around <code>(mark[n] isnt "2")</code>. 
            What happens. If you can, try to explain <i>why</i> this happens?</question>
         <question>Why is one of the 'Yellow only' cases still failing?</question>
        </li>
    </ul>
</step>
<step>
  <h1>Step STEPNUMBER</h1>
    <ul>
    <li>Answer to the previous two questions: 
    <ul>
        <li>The brackets are needed around <code>(mark[n] isnt "2")</code>
        to specify the priority between the <code>isnt</code> and the <code>and</code> operators. Without
        them the <code>and</code> is applied to the <code>"2"</code> and <code>target.contains(attempt[n])</code>,
        which are not compatible.)</li>
        <li>One of the 'Only yellows' <code>assert</code>s is still failing because the <i>both</i>
        the Xs in the attempt word are being marked yellow even though there is only one X in the target word.</li>
     </ul></li>
     <li>We need to keep a tally of which letters in the <code>target</code> word have already been 'used' (or matched) - for green, and for yellow.
        The easiest way to do this would be to blank out a character in the <code>target</code> word as it is used. However
        <code>target</code> is a parameter, and Elan (deliberately) does not allow you to <code>set</code> a parameter
        in a function. So, instead, at the top of the function, just below the existing definition of the <code>mark</code>
        define another variable named 'unused' and initialise it 
        to the value of <code>target</code>.

        <hint>Hint HINTNUMBER Complete new instruction</hint>
        <content><code>variable unused set to target</code> to be added below <code>variable mark set to "00000"</code></content>
     </li>
     <li>
        Find the <i>two</i> places where <code>target</code> is currently referenced <i>within</i> the
         <el-method>markAttempt</el-method> function and edit them to reference <el-code>unused</el-code>
         instead. Then <i>both</i> places where <code>mark</code> is being set, within the two <code>for</code> loops:
         add a new instruction, underneath each, to set the corresponding character in <code>unused</code> to a single
         empty space. When you have completed this, <i>all</i> tests for <el-method>markAttempt</el-method> should pass.

    <hint>Hint HINTNUMBER Function showing the new instructions in outline</hint>
    <content>
        <code>
            function markAttempt(attempt as String, target as String) returns String
            variable mark set to "00000"
            variable unused set to something
            for n from 0 to 4 step 1
              if attempt[n] is unused[n] then
                set mark to setChar(mark, n, "2")
                set unused to something
              end if
            end for
            for n from 0 to 4 step 1
              if (mark[n] isnt "2") and unused.contains(attempt[n]) then
                set mark to setChar(mark, n, "1")
                set unused to something
              end if
            end for
            return mark
          end function
        </code>
    </content>
    <hint>Hint HINTNUMBER The two new <code>set</code> instructions</hint>
    <content>
        <ul>
            <li>The right-hand-side of both the new <code>set</code> instructions will use the 
            <el-method>setChar</el-method> function (as used to set  <code>mark</code> elsewhere),
            but the first argument in each case will be <code>unused</code>, and the 
            <i>third</i> argument will be <code>" "</code>.</li>
           <li>For one of the <code>set</code> methods the <i>second</i> argument will be just <code>n</code>;
            for the other it will need to find the <i>index</i> of the matched character, from <i>within</i>
            <code>unused</code>, using the dotted-method <el-method>indexOf</el-method></li>
        </ul>
    </content>
    <hint>Hint HINTNUMBER The complete function</hint>
    <content>
        <code>
function markAttempt(attempt as String, target as String) returns String
  variable mark set to "00000"
  variable unused set to target
  for n from 0 to 4 step 1
    if attempt[n] is unused[n] then
      set mark to setChar(mark, n, "2")
      set unused to setChar(unused, n, " ")
    end if
  end for
  for n from 0 to 4 step 1
    if (mark[n] isnt "2") and unused.contains(attempt[n]) then
      set mark to setChar(mark, n, "1")
      set unused to setChar(unused, unused.indexOf(attempt[n]), " ")
    end if
  end for
  return mark
end function
        </code>
        </content>
    </li>
    </ul>
</step>
<step>
    <h3>Mission accomplished</h3>
    <p>Assuming that you have all the tests for <el-method>markAttempt</el-method> passing, you should be
    able to run the program and solve the Wordle puzzle. The computer will pick a different word
    each time you run the program.</p>
    <h3>Optional refinements</h3>
    If you have time, consider making small improvements to the game, for example.
    <ul>
        <li>Create a loop within <code>main</code> to solve a fixed number of puzzles in succession,
        and then allow the user to specify, at the start, how many puzzles.</li>
        <li>Keep track of how many of those puzzles the user solved within six attempts, and how many were unsolved.
            Print this at the end of the run e.g. 'You solved 7 out of 10 puzzles within six attempts'.
        </li>
        <li>For the puzzles successfully solved, keep track of the number of attempts taken and, at the end of the
            run of puzzle, calculate the average number of attempts, displayed to, say, 2 decimal places.
        </li>
        <li>Make it a two player game, where each player must solve the same number of puzzles (with the target
            words being different for each) and then the scores are compared at the end.
        </li>
    </ul>
</step>