<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../styles/colourScheme.css" rel="stylesheet" />
<link href="../styles/documentation.css" rel="stylesheet" />
<link href="../styles/elanStyle.css" rel="stylesheet" />
<title>Elan Library Reference</title>
<script type="text/javascript" src="generated_toc.js"></script>
</head>
<body>
Documents that open in a new tab:<br>
<a href="ElanIndex.html#top" target="_blank">Elan Index and Symbols</a><br>
<a href="LangRef.html#top" target="_blank">Elan Language Reference</a><br>
<a href="IDEguide.html#top" target="_blank">Elan IDE Guide</a>
<div class="docTitle">Elan Library Reference</div>
<div class="docTOC">
<div id="generated-toc" class="generate_from_h1 generate_for_page"></div></div>

<h1 id="ValueTypes">Value Types, with their methods</h1>

<h2 id="Int">Integer</h2>
<p>An integer is a whole number, i.e. one that has no fractional part. It may be represented in decimal, hexadecimal or binary:</p>
<p><el-code>100</el-code> (decimal), <el-code>0x64</el-code> (hexadecimal) and <el-code>0b1100100</el-code> all have the same value.</p>

<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>default value</th>
</tr><tr>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td><el-code>variable maxNumber set to 10</el-code></td>
  <td>0</td>
</tr><tr>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td><el-code>variable flags set to 0b1100100</el-code></td>
  <td>0</td>
</tr>
</table>

<h3 class="no-TOC">Dot methods on an <el-code><el-type>Int</el-type></el-code></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asBinary">
  <td><el-code><el-method>asBinary</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>string of binary digits representing the argument's integer value</td>
 </tr><tr id="asString_Int">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>string of decimal digits representing the argument's integer value</td>
 </tr>
</table>

<h4 class="no-TOC">Notes</h4>
<ul>
<li>A literal integer or a named value of Type <el-code><el-type>Int</el-type></el-code> may
always be passed into a function or procedure that is expecting a <el-code><el-type>Float</el-type></el-code>.</li>
<li>The <el-code><el-type>Int</el-type></el-code> type is <i>intended</i> to represent whole numbers
in the range:</li>
    <ul>
    <li>Maximum: 2<sup>53</sup> &ndash; 1 (which is 9007199254740991)</li>
    <li>Minimum value: &ndash; (2<sup>53</sup> &ndash; 1)</li>
    </ul>
 <li>If you go greater than the limit given above, the number will be accurate to approximately 17 decimal digits.
    Larger numbers will be rounded with zeros at the end, unless they are larger than around 2<sup>70</sup>, when they will automatically be shown
    in exponential (scientific) format, as shown by the output from the following code:</li>
<el-code-block source="bigInt1.elan">
<el-statement class="ok multiline" id="for139" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident141" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr142" class="ok" tabindex="0"><el-txt><el-lit>50</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr143" class="ok" tabindex="0"><el-txt><el-lit>100</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr144" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="call145" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident146" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args147" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit>, <el-id>i</el-id>.<el-method>asString</el-method>()</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call152" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident153" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args154" class="optional ok" tabindex="0"><el-txt><el-lit>10</el-lit>, (<el-lit>2</el-lit>^<el-id>i</el-id>).<el-method>asString</el-method>()</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="print176" tabindex="0"><el-kw>print </el-kw><el-field id="expr177" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>expression</i></el-place><el-compl><i>expression</i></el-compl></el-field></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>
<p>which produces:</p>
<img src="images/Pic88.png">
</ul>

<h2 id="Float">Floating point</h2>
<p>A floating point number is a decimal number that may have both integer and fractional parts.</p>
<p>It may be written using exponential (scientific) notation, e.g.
 <el-code>120.0</el-code> &equals; <el-code>1.20e2</el-code>, and
 <el-code>0.012</el-code> &equals; <el-code>1.20e-2</el-code>.</p>

<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>default value</th>
</tr><tr>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td><el-code>variable phi set to 1.618</el-code></td>
  <td>0.0</td>
</tr><tr>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td><el-code>variable reading set to 1.1e-10</el-code></td>
  <td>0.0</td>
</tr>
</table>

<h3 class="no-TOC">Dot methods on a <el-code><el-type>Float</el-type></el-code></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_Float">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>string representing the argument's floating point value</td>
 </tr><tr>
  <td><el-code><el-method>ceiling</el-method></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the first integer larger than or equal to the argument's floating point value</td>
 </tr><tr>
  <td><el-code><el-method>floor</el-method></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the first integer smaller than or equal to the argument's floating point value</td>
 </tr><tr>
  <td><el-code><el-method>round</el-method></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>the value rounded to the number of decimal places specified in the argument</td>
 </tr>
</table>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>The limits on floating point numbers are:
  <ul>
   <li>Maximum value: just over 1.0 &times; 10<sup>308</sup></li>
   <li>Minimum value: approximately 5.0 &times; 10<sup>-324</sup></li>
  </ul></li>
 <li>A variable that has been defined as being of Type <el-code><el-type>Float</el-type></el-code> may not be passed as an argument into a method that requires an <el-code><el-type>Int</el-type></el-code>,
    nor as an index into a <el-code><el-type>List</el-type></el-code> or an <el-code><el-type>Array</el-type></el-code> even if the variable contains no fractional part.
    It may, however, be converted into an <el-code><el-type>Int</el-type></el-code> before passing, using the function <el-code>floor</el-code> or <el-code>ceiling</el-code>.</li>
 <li>If you wish to define a variable to be of Type <el-code><el-type>Float</el-type></el-code>, but initialise it with an integer value, then add <el-code>.0</el-code> on the end of the whole number, as in:<br>
 <el-code>variable hour set to 3.0</el-code></li>
</ul>

<h2 id="Boolean">Boolean</h2>
<p>A <el-code><el-type>Boolean</el-type></el-code> value is either <el-code><el-id>true</el-id></el-code> or <el-code><el-id>false</el-id></el-code>.</p>
<p>The keywords <el-code><el-id>true</el-id></el-code> and <el-code><el-id>false</el-id></el-code> must be written in lower case.</p>
<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>default value</th>
</tr><tr>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code>variable fact set to true</el-code></td>
  <td><el-code>false</el-code></td>
</tr>
</table>

<h3 class="no-TOC">Dot method on a <el-code><el-type>Boolean</el-type></el-code></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_Boolean">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>string "true" if <el-code>true</el-code>, "false" if <el-code>false</el-code></td>
 </tr>
 </table>

<h2 id="String">String</h2>
<p>A <el-code><el-type>String</el-type></el-code> represents text,  i.e. a sequence of zero or more characters.</p>
<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>default value</th>
</tr><tr>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code>variable greeting set to "hello"</el-code></td>
  <td><el-code>"", i.e. the empty string</el-code></td>
</tr>
</table>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>A <el-code><el-type>String</el-type></el-code> is always delineated by double quotation marks.</li>
 <li>When typing from the keyboard into a literal string all the basic ASCII characters (0x20 to 0x7e) can be input. Similarly you can copy from
 elsewhere into a literal string provided only basic ASCII characters are include. You cannot use Alt-numeric-keypad </li>
 <li>As in most languages, strings are <i>immutable</i>. When you apply any operation or function with the intent of modifying an existing string, the existing string is never modified. Instead, the operation or function will return a new string that is based on the original, but with the specified differences.</li>
 <li>Strings can be built from other strings by concatenation using the plus operator, for example</li>
 <ul><li><el-code>print</el-code> <el-code>"Hello" + " " + "World"</el-code></li></ul>
 <li>A newline may be inserted within a string with <el-code>\n</el-code>, for example:</li>
 <ul><li><el-code>print "Hello\nWorld"</el-code></li></ul>
<li>There are no 'substring' methods in Elan because you can always use an index range to get a substring, e.g. <el-code>s[3..7]</el-code> gives a string containing the fourth character to the seventh character inclusive of <el-code> s</el-code>. Note that the upper bound of the range is <em>exclusive</em>.
 See <a href="LangRef.html#IndexedValue">Indexed Value</a>.</li>
<li>There are, however, many dot methods that can be applied to strings:</li>
</ul>

<h3 class="no-TOC">Dot methods on a <el-code><el-type>String</el-type></el-code></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_String">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td> the string itself</td>
 </tr><tr id="asList_String">
  <td><el-code><el-method>asList</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code> <el-type>List&lt;of String&gt;</el-type></el-code></td>
  <td>a List of the individual characters</td>
 </tr><tr id="asUnicode">
  <td><el-code><el-method>asUnicode</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the Unicode value of the <i>first</i> character of the string<br>
   (To convert a Unicode value into a string, use function <a href="#unicode"><el-code><el-method>unicode</el-method></el-code></a>)</td>
 </tr><tr id="asRegExp">
  <td><el-code><el-method>asRegExp</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>RegExp</el-type></el-code></td>
  <td>a new string that is a a converted to a regular expression:<br>no check is made of whether the result is a valid regular expression</td>
 </tr><tr id="asSet">
  <td><el-code><el-method>asSet</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td> a <el-code><el-type>Set</el-type></el-code>of the <i>unique</i> characters in the string</td>
 </tr><tr id="contains_String">
  <td><el-code><el-method>contains</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the string contains the substring specified as the argument<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="indexOf_String">
  <td><el-code><el-method>indexOf</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>index of the first instance of the argument (substring) within the string<br>If it is not present, -1 is returned</td>
 </tr><tr id="isAfter">
  <td><el-code><el-method>isAfter</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if alphabetic comparison finds the string comes strictly 'after' the argument string<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="isAfterOrSameAs">
  <td><el-code><el-method>isAfterOrSameAs</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if alphabetic comparison finds the string comes 'after' or equals the argument string<br> &ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="isBefore">
  <td><el-code><el-method>isBefore</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if alphabetic comparison finds the string comes strictly 'before' the argument string<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="isBeforeOrSameAs">
  <td><el-code><el-method>isBeforeOrSameAs</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if alphabetic comparison finds the string comes 'before' or equals the argument string<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="length_String">
  <td><el-code><el-method>length</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of characters in the string</td>
 </tr><tr id="lowerCase">
  <td ><el-code><el-method>lowerCase</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a new string with the original rendered in lower case</td>
 </tr><tr id="matchesRegExp">
  <td><el-code><el-method>matchesRegExp</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>RegExp</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the string matches the regular expression<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="replace">
  <td><el-code><el-method>replace</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code>, <el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a new string with <i>all</i> occurrences of the first argument string replaced by the second argument string </td>
 </tr><tr id="split">
  <td><el-code><el-method>split</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>List&lt;of String&gt;</el-type></el-code></td>
  <td>a <el-code><el-type>List</el-type></el-code> of the substrings found between occurrences of the argument string</td>
 </tr><tr id="trim">
  <td><el-code><el-method>trim</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a new string with leading and trailing spaces removed</td>
 </tr><tr id="upperCase">
  <td><el-code><el-method>upperCase</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a new string with the original rendered in upper case</td>
 </tr>
 </table>

<h3 class="no-TOC" id="InterpolatedString">Interpolated strings</h3>
<p>Strings are automatically interpolated, that is you can insert the values of variables or simple expressions within a string by enclosing them in braces.
For example, assuming that the variables <el-code>a</el-code> and <el-code>b</el-code> are already defined as integers:</p>
<p><el-code>print "{a} times {b} equals {a*b}"</el-code></p>
<p>prints the sentence with the values and calculated expression inserted.</p>
<p>If <el-code>velocity</el-code> and <el-code>fuel</el-code> are already defined as <el-code><el-type>Float</el-type></el-code> then:</p>
<p><el-code>set message to "LANDED SAFELY AT SPEED {(velocity*100).floor()} FUEL {fuel.floor()}"</el-code></p>
<p>updates variable <el-code>message</el-code> with calculated (and printable) integer values.</p>

<h3 class="no-TOC" id="SpecialCharacters">Special characters</h3>
<p>You may include single quotation marks <el-code>'</el-code>within a string, but not double quotation marks <el-code>&quot;</el-code>. Nor can you include
the braces <el-code>&lbrace;</el-code> or <el-code>&rbrace;</el-code> within a literal string because of their special meanings.
Instead, you use the constants <el-code><el-id>quotes</el-id></el-code>, <el-code><el-id>openBrace</el-id></el-code> and <el-code><el-id>closeBrace</el-id></el-code> respectively, e.g.</p>
<p><el-code>print "This is a double quotation mark: " + quotes</el-code></p>
<p><el-code>print "Here are the curly braces: {openBrace} and {closeBrace}"</el-code></p>
<p>Alternatively, you can insert their Unicode (codepoint) values (in decimal or hexadecimal) by means of function <a href="#unicode"><el-code><el-method>unicode</el-method></el-code></a>:</p>
<p><el-code>print "Here are the curly braces: {unicode(123)} and {unicode(125)}"</el-code></p>
<p><el-code>print "This is an ASCII double quotation mark: " + unicode(0x22)</el-code></p>

<h2 id="Tuple">Tuple</h2>
A <el-code>tuple</el-code> is a way of holding a small number of values of different Types together as a single reference. It may be considered a lightweight alternative to defining a specific class for some purposes. Tuples are referred to as 2-tuples, 3-tuples, etc. according to the number of values they hold. Common uses include:
<ul>
 <li>Holding a pair of x and y coordinates (each of Type <el-code><el-type>Float</el-type></el-code>) as a single unit.</li>
 <li>Allowing a function to pass back a result comprised of both a message in a <el-code><el-type>String</el-type></el-code> and a <el-code><el-type>Boolean</el-type></el-code> indicating whether the operation was successful.</li>
 <li>Returning both an updated copy of an immutable data structure and the value of an element from it, e.g. from method <el-code><el-method>pop</el-method></el-code> on a Stack.</li>
</ul>

<h3 class="no-TOC">Using a tuple</h3>
<p>You may pass a tuple into a function, or return one from a function, for example:</p>
<el-code>variable d set to distanceBetween(point1, tuple(12.34, 20.0))</el-code>
<p>An existing <el-code>tuple</el-code> (for example <el-code>point1 </el-code>below) may be deconstructed into new variables or named values (where the number of variables or names must match the number of elements in the <el-code>tuple</el-code>): </p>
<el-code>let x, y set to point1</el-code><br>
<el-code>variable x, y set to point1</el-code>
<p>
or into existing variables of the correct Type:</p>
<el-code>variable a set to 3</el-code><br>
<el-code>variable b set to 4</el-code><br>
<el-code>set a, b to point1</el-code>
<p>The 'discard' symbol <el-code>_</el-code> (underscore) may also be used when deconstructing a tuple when there is no need to capture specific elements:</p>
<el-code>variable x, _ set to point1</el-code><br>
<el-code>variable _, y set to point1</el-code>

<h4 class="no-TOC">Notes</h4>
<ul>
<li>As in most languages, an Elan <el-code>tuple</el-code> is immutable. Once defined they are effectively 'read only'. You cannot alter any of the elements in a <el-code>tuple</el-code> nor (unlike a <el-code><el-type>List</el-type></el-code>) can you create a new <el-code>tuple</el-code> from an existing one with specified differences.</li>
<li>You cannot deconstruct a <el-code>tuple</el-code> into a mixture of new and existing variables.</li>
<li>They may be nested: you can define a <el-code>tuple</el-code> within a <el-code>tuple</el-code>.</li>
</ul>

<h1 id="StandardDataStructures">Standard (mutable) data structures</h1>
<table class="tableStructure">
 <tr><th></th><th colspan="4">Standard (mutable) data structures</th></tr>
 <tr>
  <th></th>
  <th>Array</th>
  <th>Array2D</th>
  <th>List</th>
  <th>Dictionary</th>
 </tr><tr>
  <td>Size</td><td>Static</td><td>Static</td><td>Dynamic</td><td>Dynamic</td></tr>
  <tr><td>Type form<br>(example)</td>
  <td><el-code>Array&lt;of String&gt;</el-code><br>of Type <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>, <el-code><el-type>String</el-type></el-code>, or <el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code>Array2D&lt;of String&gt;</el-code><br>of Type <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>, <el-code><el-type>String</el-type></el-code>, or <el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code>List&lt;of String&gt;</el-code><br>of any Type including <el-code><el-type>Array</el-type></el-code><br> &ndash; or <el-code><el-type>List</el-type></el-code> for 'jagged' data</td>
  <td><el-code>Dictionary&lt;of String, Int&gt;</el-code><br>key must be <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>, <el-code><el-type>String</el-type></el-code>, <el-code><el-type>Boolean</el-type></el-code>, or any<el-code>record</el-code>. Value Type may be anything</td>
 </tr><tr>
  <td>literal</td>
  <td>n/a, but can convert literal list:<br><el-code>["a","b","c"].asArray()</el-code></td>
  <td>n/a</td>
  <td><el-code>["a","b","c"]</el-code></td>
  <td><el-code>["a":3, "b":5]</el-code></td>
 </tr><tr>
  <td>create</td>
  <td><el-code>new Array&lt;of String&gt;(10, "")</el-code><br>any initial value of correct Type</td>
  <td><el-code>new Array2D&lt;of String&gt;(5,8, "")</el-code><br>defines 5 arrays each of 8 elements<br>any initial value of correct Type</td>
  <td><el-code>new List&lt;of Int&gt;()</el-code><br>created empty<br>and of any Type</td>
  <td><el-code>new Dictionary&lt;of String, Int&gt;()</el-code><br>Key Type must be simple value or a <el-code>record</el-code><br>Value Type can be any</td>
 </tr><tr>
  <td>read by index</td>
  <td><el-code>a[3]</el-code></td>
  <td><el-code>a2[3, 4]</el-code></td>
  <td><el-code>li[2]</el-code></td>
  <td><el-code>d["b"]</el-code></td>
 </tr><tr>
  <td>read range</td>
  <td><el-code>a[2..5]</el-code><br>lower bound is <em>inclusive</em><br>upper bound is <em>exclusive</em></td>
  <td>n/a</td>
  <td><el-code>li[2..5]</el-code><br>lower bound is <em>inclusive</em><br>upper bound is <em>exclusive</em></td>
  <td> n/a</td>
 </tr><tr>
  <td>procedure methods to mutate contents</td>
  <td>see <a href="#Array_procedures">Procedure methods on an Array</a></td>
  <td>see <a href="#Array2D_procedures">Procedure methods on an Array2D</a></td>
  <td>see <a href="#List_procedures">Procedure methods on a List</a></td>
  <td>see <a href="#Dictionary_procedures">Procedure methods on a Dictionary</a></td>
 </tr><tr>
  <td>function methods</td>
  <td>see <a href="#Array_functions">Function methods on an Array</a></td>
  <td>see <a href="#Array2D_functions">Function methods on an Array2D</a></td>
  <td>see <a href="#List_functions">Function methods on a List</a></td>
  <td>see <a href="#Dictionary_functions">Function methods on a Dictionary</a></td>
 </tr>
</table>
<p>All four are 'mutable' &ndash; meaning that their contents may be changed directly by calling the various <i>procedure</i> dot methods that each
Type defines.
However, since procedure methods may be called only from within the <el-code><el-kw>main</el-kw></el-code> routine,
or from within another <el-code><el-kw>procedure</el-kw></el-code>, it is also possible to make changes via
<el-code><el-kw>function</el-kw></el-code> dot methods &ndash; which return a copy of the data structure,
with the specified changes &ndash; which is why all such methods have names starting <el-code>with...</el-code>.</p>

<p>All four data structures contain values of a single Type, that Type being specified either explicitly &ndash;  as in
    <el-code>of &lt;<el-kw>procedure</el-kw>&gt; <el-type>Int</el-type></el-code> &ndash; or implicitly if the structure
    is created from its literal definition form.</p>
    <p>A <el-type>Dictionary</el-type> is defined with two Types: one for its keys and one for their values.</p>

<h2 id="Array">Array</h2>
<p>An array is a simple data structure containing <i>n</i> elements of a single Type, indexed from <i>0</i> to <i>n-1</i>.</p>
<p>The array elements' Type must be one of <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>, <el-code><el-type>String</el-type></el-code>, or <el-code><el-type>Boolean</el-type></el-code>.</p>
<p>As in most languages, individual elements may be referenced by their index.</p>
<p>To modify an element you may either
<el-code><el-kw>call</el-kw></el-code> the <el-code><el-method>put</el-method></el-code> procedure method, or use the
<el-code><el-method>withPut</el-method></el-code> function method.</p>
<p>An array's size is specified when it is created, along with the single value to which each element is initialised.</p>
<p>It is not possible to append further elements to an array, but you can convert an array to a list using method <el-code><el-method>asList</el-method></el-code> and then extend or reduce the list.</p>

<h3 class="no-TOC" id="Array_procedures">Procedure methods on an Array</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="put_Array">
  <td><el-code><el-method>put</el-method></el-code></td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code>, <br>item of Array element's Type</td>
  <td>puts the item at the (integer) index position in the array</td>
 </tr>
</table>

<h3 class="no-TOC" id="Array_functions">Function methods on an Array</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="withPut_Array">
  <td><el-code><el-method>withPut</el-method></el-code></td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code>,<br>item of Array element's Type</td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td>a new Array with the item at the (integer) index position</td>
 </tr><tr id="asList_Array">
  <td><el-code><el-method>asList</el-method></el-code></td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>the contents of the Array as a List</td>
 </tr><tr id="asString_Array">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a String that is a comma+space-separated list of the Array's elements enclosed in square brackets</td>
 </tr><tr id="contains_Array">
  <td><el-code><el-method>contains</el-method></el-code></td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td>item of Array element's Type</td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the Array contains the value<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="indexOf_Array">
  <td><el-code><el-method>indexOf</el-method></el-code></td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td>item of Array element's Type</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the index position of the first occurrence of the argument value in the array, <br>or -1 if no match is found</td>
 </tr><tr id="length_Array">
  <td><el-code><el-method>length</el-method></el-code></td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of elements in the array</td>
 </tr>
</table>

<h2 id="Array2D">Array2D</h2>
<p>The <el-code><el-type>Array2D</el-type></el-code> Type defines a 2-dimensional array of fixed size. The two
 dimensions, which are specified when the array is created, may be of the same size (a square array)
 or different (a rectangular array). If you want to create a 'jagged' array, you should use a <el-code><el-type>List</el-type></el-code> of Lists.</p>
<p>The convention is to refer to the position of an element in such an array by two index values
<i>(x,y)</i>, where <i>x</i> is the column number and <i>y</i> is the row number of a rectangular grid.</p>
<p>The Type for the elements is also specified when the Array is defined and must be
 one of: <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>,
 <el-code><el-type>String</el-type></el-code>, or <el-code><el-type>Boolean</el-type></el-code>.</p>

<h3 class="no-TOC" id="Array2D_procedures">Procedure methods on an Array2D</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="put_Array2D">
  <td><el-code><el-method>put</el-method></el-code></td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td><el-code><el-type>Int, Int,</el-type></el-code> item of Array2D element's Type</td>
  <td>puts the item at the (two integers) index position in the array</td>
 </tr>
</table>

<h3 class="no-TOC" id="Array2D_functions">Function methods on an Array2D</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="withPut_Array2D">
  <td><el-code><el-method>withPut</el-method></el-code></td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td><el-code><el-type>Int, Int</el-type></el-code>,<br>item of Array2D element's Type</td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td>a new Array2D with the item at the (two integers) index position in the array</td>
 </tr><tr id="asString_Array2D">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a String that is a comma+space-separated list of the Array2D's columns each of which contains a comma+space-separated list of row values enclosed in square brackets, the whole enclosed in square brackets</td>
 </tr><tr id="columns">
  <td><el-code><el-method>columns</el-method></el-code></td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of columns in the array (the maximum <i>x</i> value)</td>
 </tr><tr id="contains_Array2D">
  <td><el-code><el-method>contains</el-method></el-code></td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td>item of Array2D element's Type</td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the Array2D contains the item<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="indexOf_Array2D">
  <td><el-code><el-method>indexOf</el-method></el-code></td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td>item of Array2D element's Type</td>
  <td><el-code><el-type>Int, Int</el-type></el-code></td>
  <td>a Tuple containing the index pair of the first occurrence of the argument's value in the array
      by searching the columns in order, or (-1,-1) if no match is found</td>
 </tr><tr id="row">
  <td><el-code><el-method>rows</el-method></el-code></td>
  <td><el-code><el-type>Array2D</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of rows in the array (the maximum <i>y</i> value)</td>
 </tr>
</table>
Note
<ul>
 <li>Since an <el-code><el-type>Array2D</el-type></el-code> has a known fixed size, methods <el-code><el-method>rows</el-method></el-code> and <el-code><el-method>columns</el-method></el-code> are of use only when passing such an array into a procedure or function that needs to discover its size.</li>
</ul>
<p>You can read individual elements with a double index, for example:</p>
<el-code-block source="col_row.elan">
<el-statement class="ok multiline" id="for13" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident15" class="ok" tabindex="0"><el-txt><el-id>col</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-lit>7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok multiline" id="for19" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident21" class="ok" tabindex="0"><el-txt><el-id>row</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr22" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-lit>7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr24" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="print25" tabindex="0"><el-kw>print </el-kw><el-field id="expr26" class="optional ok" tabindex="0"><el-txt><el-id>board</el-id>[<el-id>col</el-id>, <el-id>row</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end for</el-kw>
</el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<h2 id="List">List</h2>
<p>A List is similar to an Array in that its <i>n</i> elements are all of one Type
 and are indexed from <i>0</i> to <i>n-1</i>, but is more flexible because:</p>
<ul>
 <li>While the elements must all be of one Type, that Type is not limited to the simple value Types:
  the element Type may also be a user-defined Type such as a <i>class</i>, <i>record</i>, another <i>List</i> or an <i>Array</i>.</li>
 <li>A List is created either empty or initialised from a literal definition.</li>
 <li>A List's size can be dynamically changed.</li>
</ul>
<h4 class="no-TOC" id="ListDeconstruction">List Deconstruction</h4>
<p>A List or ListImmutable may be deconstructed into new variables or named values in a similar way to deconstructing a <a href="#Tuple">Tuple</a>, but in this case:</p>
<ul>
 <li>Always use two variable names.</li>
 <li>Use a colon <el-code>:</el-code> to separate the variable names.</li>
 <li>The first item in the list (the head) is assigned to the first variable.</li>
 <li>The rest of the list (the tail) is assigned to the second variable.  If the original list only contains one element, this will be an empty list.</li>
 <li>Like deconstructing a Tuple, you can use an underscore <el-code>_</el-code> as the variable name to discard either the head or the tail.</li>
</ul>
<p><el-code>variable x:xs set to myList</el-code><br>
<el-code>set h:t to myList</el-code><br>
<el-code>set h:myList to myList</el-code></p>
<p>Discarding either the head or tail:</p>
<p><el-code>variable _:tail set to myList</el-code><br>
<el-code>variable head:_ set to myList</el-code></p>
<h3 class="no-TOC" id="List_procedures">Procedure methods on a List</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="append">
  <td><el-code><el-method>append</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>item of List element's Type</td>
  <td>the item is added to the end of the List</td>
 </tr><tr id="appendList">
  <td><el-code><el-method>appendList</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>the argument List is added to the end of the List</td>
 </tr><tr id="insert">
  <td><el-code><el-method>insert</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code>,<br> item of List element's Type</td>
  <td>the item is inserted at the index given.<br>
  If the index is negative it is counted from the end.<br>
  If the index is greater than the list's length, the item is inserted at the end.</td>
 </tr><tr id="prepend">
  <td><el-code><el-method>prepend</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>item of List element's Type</td>
  <td>the item is is added to the start of the List</td>
 </tr><tr id="prependList">
  <td><el-code><el-method>prependList</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>the argument List is added to the start of the List</td>
 </tr><tr id="put_List">
  <td><el-code><el-method>put</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code>,<br> item of List element's Type</td>
  <td>replace the item at the given index with the argument item</td>
 </tr><tr>
  <td><el-code><el-method>removeAll</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td></td>
 </tr><tr id="removeAt">
  <td><el-code><el-method>removeAt</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>delete the item at the argument index</td>
 </tr><tr id="removeFirst">
  <td><el-code><el-method>removeFirst</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td></td>
 </tr>
</table>

<h3 class="no-TOC" id="List_functions">Function methods on a List</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asArray">
  <td><el-code><el-method>asArray</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Array</el-type></el-code></td>
  <td>a new Array containing the same elements</td>
 </tr><tr id="asListImmutable">
  <td><el-code><el-method>asListImmutable</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code> whose elements are<br> of an immutable Type</td>
  <td>(none)</td>
  <td><el-code><el-type>ListImmutable</el-type></el-code></td>
  <td>a new ListImmutable containing the same elements</td>
 </tr><tr id="asSet">
  <td><el-code><el-method>asSet</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>a new Set containing all the <i>unique</i> elements in the List</td>
 </tr><tr id="asString_List">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a string representation of the List</td>
 </tr><tr id="contains_List">
  <td><el-code><el-method>contains</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>List element's Type</td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the List  contains the specified element<br>
  &ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="filter_List">
  <td><el-code><el-method>filter</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-kw>lambda</el-kw></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#filter"><el-code><el-method>filter</el-method></el-code></a> in HoFs</td>
 </tr><tr id="head_List">
  <td><el-code><el-method>head</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>(none)</td>
  <td>List element's Type</td>
  <td>the first element of the List</td>
 </tr><tr id="indexOf_List">
  <td><el-code><el-method>indexOf</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>List element's Type</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>index of the first occurrence of the argument value in the List,<br>or -1 if no match is found</td>
 </tr><tr id="join">
  <td><el-code><el-method>join</el-method></el-code></td>
  <td><el-code><el-type>List&lt;of String&gt;<br></el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a single String that joins all the elements in the list,<br>with the specified String (which can be empty) inserted between the elements</td>
 </tr><tr id="length_List">
  <td><el-code><el-method>length</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of elements in the List</td>
 </tr><tr id="map_List">
  <td><el-code><el-method>map</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-kw>lambda</el-kw></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#map"><el-code><el-method>map</el-method></el-code></a> in HoFs</td>
 </tr><tr id="maxFloat">
  <td><el-code><el-method>maxFloat</el-method></el-code></td>
  <td><el-code><el-type>List&lt;of Float&gt;</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>returns the maximum value found in the List</td>
 </tr><tr id="minFloat">
  <td><el-code><el-method>minFloat</el-method></el-code></td>
  <td><el-code><el-type>List&lt;of Float&gt;</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>returns the minimum value found in the List</td>
 </tr><tr id="maxInt">
  <td><el-code><el-method>maxInt</el-method></el-code></td>
  <td><el-code><el-type>List&lt;of Int&gt;</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>returns the maximum value found in the List</td>
 </tr><tr id="minInt">
  <td><el-code><el-method>minInt</el-method></el-code></td>
  <td><el-code><el-type>List&lt;of Int&gt;</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>returns the minimum value found in the List</td>
 </tr><tr id="maxBy_List">
  <td><el-code><el-method>maxBy</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-kw>lambda</el-kw></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#maxBy"><el-code><el-method>maxBy</el-method></el-code></a> in HoFs</td>
 </tr><tr id="minBy_List">
  <td><el-code><el-method>minBy</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-kw>lambda</el-kw></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#minBy"><el-code><el-method>minBy</el-method></el-code></a> in HoFs</td>
 </tr><tr id="reduce_List">
  <td><el-code><el-method>reduce</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-kw>lambda</el-kw></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#reduce"><el-code><el-method>reduce</el-method></el-code></a> in HoFs</td>
 </tr><tr id="sortBy_List">
  <td><el-code><el-method>sortBy</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-kw>lambda</el-kw></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#sortBy"><el-code><el-method>sortBy</el-method></el-code></a> in HoFs</td>
 </tr><tr id="withAppend">
  <td><el-code><el-method>withAppend</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withAppendList">
  <td><el-code><el-method>withAppendList</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withInsert">
  <td><el-code><el-method>withInsert</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withPrepend">
  <td><el-code><el-method>withPrepend</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withPrependList">
  <td><el-code><el-method>withPrependList</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withPut_List">
  <td><el-code><el-method>withPut</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withRemoveAll">
  <td><el-code><el-method>withRemoveAll</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withRemoveAt">
  <td><el-code><el-method>withRemoveAt</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withRemoveFirst">
  <td><el-code><el-method>withRemoveFirst</el-method></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr>
</table>

<h2 id="Dictionary">Dictionary</h2>
<p>A Dictionary works like an Array, but instead of having a numeric (integer) index, each entry has a <i>key</i>. Each key is associated with a <i>value</i>,
so the Dictionary is a set of <i>key:value</i> pairs.
The key's Type must be one of <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>, <el-code><el-type>String</el-type></el-code> or <el-code><el-type>Boolean</el-type></el-code>,
<i>or</i> it may be a user-defined <i>record</i>. The values may be of any Type, and the Types of both key and value are fixed when the Dictionary is created.</p>

<h3 class="no-TOC" id="Dictionary_procedures">Procedure methods on a Dictionary</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="put_Dictionary">
  <td><el-code><el-method>put</el-method></el-code></td>
  <td><el-code><el-type>Dictionary</el-type></el-code></td>
  <td>key's Type, value's Type</td>
  <td>replace the value at an existing key, or add a key:value pair</td>
 </tr><tr id="RemoveAt">
  <td><el-code><el-method>removeAt</el-method></el-code></td>
  <td><el-code><el-type>Dictionary</el-type></el-code></td>
  <td>key's Type</td>
  <td>delete the key:pair at the given key (if it exists)</td>
 </tr>
</table>

<h3 class="no-TOC" id="Dictionary_functions">Function methods on a Dictionary</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_Dictionary">
    <td><el-code><el-method>asString</el-method></el-code></td>
    <td><el-code><el-type>Dictionary</el-type></el-code></td>
    <td>(none)</td>
    <td><el-code><el-type>String</el-type></el-code></td>
    <td>a string representation of the dictionary (automatically called when printing)</td>
</tr><tr id="leys">
    <td id="keys"><el-code><el-method>keys</el-method></el-code></td>
    <td><el-code><el-type>Dictionary</el-type></el-code></td>
    <td>(none)</td>
    <td><el-code><el-type>List</el-type></el-code></td>
    <td>a List containing the keys</td>
</tr><tr id="values">
    <td><el-code><el-method>values</el-method></el-code></td>
    <td><el-code><el-type>Dictionary</el-type></el-code></td>
    <td>(none)</td>
    <td><el-code><el-type>List</el-type></el-code></td>
    <td>a List containg the values</td>
</tr>
 </table>

<h1 id="ImmutableDataStructures">Immutable data structures</h1>
<p>In contrast to the <a href="#StandardDataStructures">standard (mutable) data structures</a>, <i>immutable</i>
data structures cannot be modified directly &ndash; and hence define no <i>procedure</i> dot methods. Instead,
changes are made by using <i>function</i> dot methods that copy the existing data structure, but with specified
differences. Immutable data structures are intended specifically to facilitate the Functional Programming paradigm,
 but some are also useful within other programming paradigms.</p>

<p>The five immutable data structures defined in the Elan library are summarised in this table. More details on each Type are given below the table.</p>
<table class="tableStructure">
 <tr><th></th><th colspan="5">Immutable data structures</th></tr>
 <tr>
  <th></th>
  <th>ListImmutable</th>
  <th>DictionaryImmutable</th>
  <th>Set</th>
  <th>Stack</th>
  <th>Queue</th>
 </tr><tr>
  <td>Size</td><td>Dynamic</td><td>Dynamic</td><td>Dynamic</td><td>Dynamic</td><td>Dynamic</td>
 </tr><tr>
  <td>Type</td>
  <td><el-code>ListImmutable&lt;of String&gt;</el-code><br>element Type must be immutable</td>
  <td><el-code>DictionaryImmutable&lt;of String, Int&gt;</el-code><br>Key Type must be <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Float</el-type></el-code>, <el-code><el-type>String</el-type></el-code>, <el-code><el-type>Boolean</el-type></el-code> or any <el-code>record</el-code><br>Value Type may be any immutable Type</td>
  <td><el-code>Set&lt;of String&gt;</el-code><br>element Type must be immutable</td>
  <td><el-code>Stack&lt;of String&gt;</el-code><br>element Type must be immutable</td>
  <td><el-code>Queue&lt;of String&gt;</el-code><br>element Type must be immutable</td>
 </tr><tr>
  <td>literal</td>
  <td><el-code>{a","b","c"}</el-code></td>
  <td><el-code>{"a":3, "b":5}</el-code></td>
  <td>None, but can convert literal list:<br><el-code>["a","b","c"].asSet()</el-code></td>
  <td>None</td>
  <td>None</td>
 </tr><tr>
  <td>create</td>
  <td><el-code>new ListImmutable&lt;ofString&gt;()</el-code><br>created empty<br>must be 'of' an immutable Type</td>
  <td><el-code>new DictionaryImmutable&lt;of String, Int&gt;()</el-code><br>created empty <br>Key <em>and</em> Value Types must be immutable</td>
  <td><el-code>new Set&lt;of String&gt;()</el-code><br> created empty<br>must be 'of' an immutable Type</td>
  <td><el-code>new Stack&lt;of String&gt;()</el-code></td>
  <td><el-code>new Queue&lt;of String&gt;()</el-code></td>
 </tr><tr>
  <td>read by Key</td>
  <td><el-code>lim[2]</el-code></td>
  <td><el-code>di["b"]</el-code></td>
  <td>n/a</td>
  <td>n/a</td>
  <td>n/a</td>
 </tr><tr>
  <td>read range</td>
  <td><el-code>lim[2..5]</el-code><br>upper bound <em>exclusive</em></td>
  <td>n/a</td>
  <td>n/a</td>
  <td>n/a</td>
  <td>n/a</td>
 </tr><tr>
  <td>function methods</td>
  <td>see <a href="#ListImmutable_functions">Function methods on a ListImmutable</a></td>
  <td>see <a href="#DictionaryImmutable_functions">Function methods on a DictionaryImmutable</a></td>
  <td>see <a href="#Set_functions">Function methods on a Set</a></td>
  <td>see <a href="#Stack_functions">Function methods on a Stack</a></td>
  <td>see <a href="#Queue_functions">Function methods on a Queue</a></td>
 </tr>
</table>

<h2 id="ListImmutable">ListImmutable</h2>
<p>A <el-code>ListImmutable</el-code> is like a <el-code><el-type>List</el-type></el-code> but is <i>immutable</i> (like a <el-code><el-type>String</el-type></el-code>).
You can still insert, delete or change elements in a <el-code>ListImmutable</el-code>, but the methods for these operations do not modify the input <el-code>ListImmutable</el-code>: they return a new <el-code>ListImmutable</el-code> based on the input <el-code>ListImmutable</el-code> with the specified differences.</p>

<h3 class="no-TOC">Type name</h3>
<p>The Type is specified in the following ways:</p>
<ul>
 <li><el-code>ListImmutable&lt;of String&gt;</el-code> for a ListImmutable of Type <el-code><el-type>String</el-type></el-code></li>
 <li><el-code>ListImmutable&lt;of Int&gt;</el-code> for a ListImmutable  of Type <el-code><el-type>Int</el-type></el-code></li>
 <li><el-code>ListImmutable&lt;of ListImmutable&lt;of Int&gt;&gt;</el-code> for a ListImmutable of such lists each of Type <el-code><el-type>Int</el-type></el-code></li>
</ul>

<h3 class="no-TOC">Creating a ListImmutable</h3>
<p>A <el-code>ListImmutable</el-code> may be defined in 'literal' form, delimited by curly brace with all the required elements separated by commas. The elements may be literal values but must all be of the same Type, for example:</p>
<el-code>variable fruit set to {"apple", "orange", "pear"} </el-code>

<h4 class="no-TOC" id="ListImmutableDeconstruction">ListImmutable Deconstruction</h4>
<p>A <el-code>ListImmutable</el-code> can be <a href="#ListDeconstruction">deconstructed</a> just like a List, using a colon <el-code>:</el-code> to separate two variable names.</p>
<p><el-code>set h:t to myListImmutable</el-code></p>

<h3 class="no-TOC" id="ListImmutable_functions">Function methods on a ListImmutable</h3>
<table>
 <tr>
  <th>function<br>dot method</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="contains_ListImmutable">
  <td><el-code><el-method>contains</el-method></el-code></td>
  <td>item of List element's Type</td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the List contains the item<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="head_ListImmutable">
  <td><el-code><el-method>head</el-method></el-code></td>
  <td>(none)</td>
  <td>item of List element's Type</td>
  <td>the first item in the List</td>
 </tr><tr id="asList_ListImmutable">
  <td><el-code><el-method>asList</el-method></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>ListImmutable</el-type></el-code></td>
  <td>copy of the List</td>
 </tr><tr id="asString_ListImmutable">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a String that is a comma+space-separated list of the List's elements enclosed in braces</td>
 </tr><tr id="length_ListImmutable">
  <td><el-code><el-method>length</el-method></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of elements in the List</td>
 </tr><tr id="insert_ListImmutable">
  <td><el-code><el-method>withInsert</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code>, item of List element's Type</td>
  <td><el-code><el-type>ListImmutable</el-type></el-code></td>
  <td>copy of the List with the item inserted at specified position</td>
 </tr><tr id="withPut_ListImmutable">
  <td><el-code><el-method>withPut</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code>, item of List element's Type</td>
  <td><el-code><el-type>ListImmutable</el-type></el-code></td>
  <td>copy of the List with the item replacing what was at specified position</td>
 </tr><tr id="withRemoveAt_ListImmutable">
  <td><el-code><el-method>withRemoveAt</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td><el-code><el-type>ListImmutable</el-type></el-code></td>
  <td>copy of the List with the item at specified position removed</td>
 </tr><tr id="withRemoveFirst_ListImmutable">
  <td><el-code><el-method>withRemoveFirst</el-method></el-code></td>
  <td>item of List element's Type</td>
  <td><el-code><el-type>ListImmutable</el-type></el-code></td>
  <td>copy of the List with the first occurrence of the item removed</td>
 </tr><tr id="withRemoveAll_ListImmutable">
  <td><el-code><el-method>withRemoveAll</el-method></el-code></td>
  <td>item of List element's Type</td>
  <td><el-code><el-type>ListImmutable</el-type></el-code></td>
  <td>copy of the List with all occurrences of the item removed</td>
 </tr>
</table>

<p>Try these examples:</p>
<el-code-block source="listImmutable.elan">
<el-statement><el-comment class="ok" id="com64" tabindex="0"><el-top><el-kw># </el-kw><el-field id="comment65" class="optional ok" tabindex="0"><el-txt>reusing variable fruit for each new ListImmutable</el-txt><el-place><i>comment</i></el-place></el-field></el-top></el-comment></el-statement>
<el-statement class="ok" id="var5" tabindex="0"><el-kw>variable </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>ListImmutable</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print11" tabindex="0"><el-kw>print </el-kw><el-field id="expr12" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set53" tabindex="0"><el-kw>set </el-kw><el-field id="ident54" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>.<el-method>withAppend</el-method>("<el-lit>apple</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set58" tabindex="0"><el-kw>set </el-kw><el-field id="ident59" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr60" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>.<el-method>withAppend</el-method>("<el-lit>pear</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print61" tabindex="0"><el-kw>print </el-kw><el-field id="expr62" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print66" tabindex="0"><el-kw>print </el-kw><el-field id="expr67" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id>[<el-lit>1</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print68" tabindex="0"><el-kw>print </el-kw><el-field id="expr69" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print70" tabindex="0"><el-kw>print </el-kw><el-field id="expr71" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id>[<el-id>fruit</el-id>.<el-method>length</el-method>() - <el-lit>2</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print76" tabindex="0"><el-kw>print </el-kw><el-field id="expr77" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id>.<el-method>contains</el-method>("<el-lit>banana</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h2 id="DictionaryImmutable">DictionaryImmutable</h2>
<p>A <el-code><el-type>DictionaryImmutable</el-type></el-code> is like a <el-code><el-type>Dictionary</el-type></el-code> but <i>immutable</i>
 (like a <el-code><el-type>String</el-type></el-code>). You can still insert, delete or change elements in a <el-code><el-type>DictionaryImmutable</el-type></el-code>,
 but the methods of these operations do not modify the input <el-code><el-type>DictionaryImmutable</el-type></el-code>: they return a new
 <el-code><el-type>DictionaryImmutable</el-type></el-code> with the specified differences.</p>                                                                     x
<p>A <el-code><el-type>DictionaryImmutable</el-type></el-code> may be defined in a constant.</p>

<h3 class="no-TOC">Type name</h3>
<p>In the following example, the keys are of Type <el-code><el-type>String</el-type></el-code>, and the values associated with the keys are of Type <el-code><el-type>Int</el-type></el-code>:</p>
<el-code>DictionaryImmutable&lt;of String, Int&gt;</el-code>

<h3 class="no-TOC">Defining a literal DictionaryImmutable</h3>
<p>A literal<el-code> DictionaryImmutable</el-code> is defined as a comma-separated list of <i>key:value</i> pairs surrounded by curly braces:</p>
<el-code>variable scrabbleValues set to {"a":1, "b":3, "c":3, "d":2}</el-code>

<h3 class="no-TOC">Using an Immutable Dictionary</h3>
<p>Try this example:</p>
<el-code-block source="dictImmutable.elan">
<el-statement class="ok" id="var27" tabindex="0"><el-kw>variable </el-kw><el-field id="var28" class="ok" tabindex="0"><el-txt><el-id>immD</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr29" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>DictionaryImmutable</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>Int</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print30" tabindex="0"><el-kw>print </el-kw><el-field id="expr31" class="optional ok" tabindex="0"><el-txt><el-id>immD</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set32" tabindex="0"><el-kw>set </el-kw><el-field id="ident33" class="ok" tabindex="0"><el-txt><el-id>immD</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr34" class="ok" tabindex="0"><el-txt><el-id>immD</el-id>.<el-method>withPut</el-method>("<el-lit>a</el-lit>", <el-lit>3</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print35" tabindex="0"><el-kw>print </el-kw><el-field id="expr36" class="optional ok" tabindex="0"><el-txt><el-id>immD</el-id>["<el-lit>a</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set37" tabindex="0"><el-kw>set </el-kw><el-field id="ident38" class="ok" tabindex="0"><el-txt><el-id>immD</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr39" class="ok" tabindex="0"><el-txt><el-id>immD</el-id>.<el-method>withRemoveAt</el-method>("<el-lit>a</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print40" tabindex="0"><el-kw>print </el-kw><el-field id="expr41" class="optional ok" tabindex="0"><el-txt><el-id>immD</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h3 class="no-TOC" id="DictionaryImmutable_functions">Function methods on a DictionaryImmutable</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="hasKey">
  <td><el-code><el-method>hasKey</el-method></el-code></td>
  <td><el-code><el-type>DictionaryImmutable</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withPut_DictionaryImmutable">
  <td><el-code><el-method>withPut</el-method></el-code></td>
  <td><el-code><el-type>DictionaryImmutable</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
 </tr><tr id="withPutKey">
  <td><el-code><el-method>withPutKey</el-method></el-code></td>
  <td><el-code><el-type>DictionaryImmutable</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="withRemoveAtKey">
  <td><el-code><el-method>withRemoveAtKey</el-method></el-code></td>
  <td><el-code><el-type>DictionaryImmutable</el-type></el-code></td>
  <td></td>
  <td><el-code><el-type></el-type></el-code></td>
  <td></td>
 </tr><tr id="asString_DictionaryImmutable">
    <td><el-code><el-method>asString</el-method></el-code></td>
    <td><el-code><el-type>DictionaryImmutable</el-type></el-code></td>
    <td>(none)</td>
    <td><el-code><el-type>String</el-type></el-code></td>
    <td>a string representation of the immutable dictionary (automatically called when printing)</td>
</tr>
 </table>

<h2 id="SetType">Set</h2>
    <p>A set is a standard data structure that works somewhat like a <el-code>ListImmutable</el-code> with the important difference that in a set a given element may appear only once. If an item being added to a <el-code>Set</el-code> is identical to an existing item in the <el-code>Set</el-code> then the <el-code>Set</el-code> remains the same length as before. </p>
    <p>This enables a set to work like a mathematical set so that it is possible to perform standard set operations such as <el-code><el-method>union</el-method></el-code> or <el-code><el-method>intersection</el-method></el-code>. For the same reason, a Set is an immutable data structure: there are no methods modify the set on which they are called, but several of them (including <el-code><el-method>add</el-method></el-code>, <el-code><el-method>remove</el-method></el-code>) return a new set that is based on the original set or sets, with specified differences.</p>
    <p>Example of use:</p>
<el-code-block source="set.elan">
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Set</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set6" tabindex="0"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>addFromList</el-method>([<el-lit>3</el-lit>, <el-lit>5</el-lit>, <el-lit>7</el-lit>])</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set11" tabindex="0"><el-kw>set </el-kw><el-field id="ident12" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr13" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>add</el-method>(<el-lit>7</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print14" tabindex="0"><el-kw>print </el-kw><el-field id="expr15" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set16" tabindex="0"><el-kw>set </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>remove</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print19" tabindex="0"><el-kw>print </el-kw><el-field id="expr20" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set21" tabindex="0"><el-kw>set </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>remove</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print24" tabindex="0"><el-kw>print </el-kw><el-field id="expr25" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print26" tabindex="0"><el-kw>print </el-kw><el-field id="expr27" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
 </el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
    <li> When creating a set, the Type of the elements must be specified in the form
    <el-code>Set&lt;of String&gt;</el-code>. This applies both when creating a new, empty set and when defining the Type of a parameter to be a <el-code>Set</el-code>.</li>
    <li>You can add elements: individually with <el-code><el-method>add</el-method></el-code>, or multiple elements with <el-code>addFromList</el-code> and <el-code>addFromList</el-code>.</li>
    <li>You can create a new set from an existing list or <el-code>ListImmutable</el-code> by calling <el-code>asSet</el-code> on it.</li>
</ul>

<h3 class="no-TOC" id="Set_functions">Function methods on a Set</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="add">
  <td><el-code><el-method>add</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>item of Set element's Type</td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>copy of the Set extended with the item provided it differs from all the Set's current elements</td>
 </tr><tr id="addFromList">
  <td><el-code><el-method>addFromList</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>copy of the Set extended with those items from the List that are not already in the Set</td>
 </tr><tr id="asList_Set">
  <td><el-code><el-method>asList</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>List</el-type></el-code></td>
  <td>a List containing the Set's elements</td>
 </tr><tr id="asString_Set">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a String that is a comma+space-separated list of the Set's elements enclosed in braces</td>
 </tr><tr id="contains_Set">
  <td><el-code><el-method>contains</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>item of Set element's Type</td>
  <td><el-code>Boolean<el-type></el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the Set contains the item<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="difference">
  <td><el-code><el-method>difference</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>a Set containing those elements of the Set that do not occur in the argument Set</td>
 </tr><tr id="intersection">
  <td><el-code><el-method>intersection</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>a Set containing those elements common to both the Set and the argument Set</td>
 </tr><tr id="isDisjointFrom">
  <td><el-code><el-method>isDisjointFrom</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the Set has no items in common with the argument Set<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="isSubsetOf">
  <td><el-code><el-method>isSubsetOf</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if all the Set's items are also in the argument Set<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="isSupersetOf">
  <td><el-code><el-method>isSupersetOf</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><el-code><el-id>true</el-id></el-code> if the Set contains all the  items that are in the argument Set<br>&ndash; <el-code><el-id>false</el-id></el-code> otherwise</td>
 </tr><tr id="length_Set">
  <td><el-code><el-method>length</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of elements in the Set</td>
 </tr><tr id="remove">
  <td><el-code><el-method>remove</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>item of Set element's Type</td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>copy of the Set with the argument item removed (if present)</td>
 </tr><tr id="union">
  <td><el-code><el-method>union</el-method></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td><el-code><el-type>Set</el-type></el-code></td>
  <td>a Set containing all the unique elements of the Set and the argument Set (i.e. no duplicates)</td>
 </tr>
 </table>

<p id="Queue"></p>
<h2 id="Stack">Stack and Queue</h2>
<ul>
    <li><el-code><el-type>Stack</el-type></el-code> and <el-code><el-type>Queue</el-type></el-code> are similar data structures except that <el-code><el-type>Stack</el-type></el-code> is &#8216;LIFO&#8217; (last in, first out), while <el-code><el-type>Queue</el-type></el-code> is FIFO (first in, first out). The names of the methods for adding/removing are different, but there are also common methods.</li>
    <li>Both a <el-code><el-type>Stack</el-type></el-code> and a <el-code><el-type>Queue</el-type></el-code> are defined with the Type of the items that they can contain, similarly to how <el-code><el-type>List</el-type></el-code> and <el-code>ListImmutable</el-code> have a specified item Type, though with different syntax. The Type is specified in the form shown below e.g. <el-code>Stack&lt;of String&gt;, Queue&lt;of Int&gt;, Stack&lt;of (Float, Float)&gt;, Queue&lt;of Square&gt;</el-code>.</li>
    <li>Both <el-code>Stack </el-code>and<el-code> Queue</el-code> are dynamically extensible, like <el-code><el-type>List</el-type></el-code> and <el-code>ListImmutable</el-code>. There is no need (or means) to specify a size limit as they will continue to expand until, eventually, the computer&#8217;s memory limit is reached.</li>
    <li>This same syntax is used to specify the Type if you want to pass a <el-code><el-type>Stack</el-type></el-code> or <el-code><el-type>Queue</el-type></el-code> into a function, or specify it as the <el-code><el-kw>return</el-kw></el-code> Type.</li>
    <li><el-code><el-type>Stack</el-type></el-code> and <el-code><el-type>Queue</el-type></el-code> have two methods in common: <el-code><el-method>length</el-method></el-code> and <el-code><el-method>peek</el-method></el-code>.
    <el-code><el-method>peek</el-method></el-code> returns the next item to be removed, without actually removing it.</li>
    <li>The methods for adding and removing an item are different for <el-code><el-type>Stack</el-type></el-code> and <el-code><el-type>Queue</el-type></el-code>, as shown here:</li>
</ul>

<h3 class="no-TOC" id="StackFunctions">Function methods on a Stack</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Types</th>
  <th>returns</th>
 </tr><tr id="push">
  <td><el-code><el-method>push</el-method></el-code></td>
  <td><el-code><el-type>Stack</el-type></el-code></td>
  <td>item of Stack element's Type</td>
  <td><el-code><el-type>Stack</el-type></el-code></td>
  <td>the Stack with the element added to the top of the Stack</td>
 </tr><tr id="pop">
  <td><el-code><el-method>pop</el-method></el-code></td>
  <td><el-code><el-type>Stack</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Stack element Type,<br>Stack</el-type></el-code></td>
  <td>the topmost element of the Stack, and the Stack with the element removed</td>
 </tr><tr id="peek_Stack">
  <td><el-code><el-method>peek</el-method></el-code></td>
  <td><el-code><el-type>Stack</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Stack element Type</el-type></el-code></td>
  <td>the topmost element of the Stack (without altering the Stack)</td>
 </tr><tr id="length_Stack">
  <td><el-code><el-method>length</el-method></el-code></td>
  <td><el-code><el-type>Stack</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of elements in the Stack</td>
 </tr><tr id="asString_Stack">
    <td><el-code><el-method>asString</el-method></el-code></td>
    <td><el-code><el-type>Stack</el-type></el-code></td>
    <td>(none)</td>
    <td><el-code><el-type>String</el-type></el-code></td>
    <td>a string representation of the stack (automatically called when printing)</td>
</tr>
</table>

<h3 class="no-TOC" id="QueueFunctions">Function methods on a Queue</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Types</th>
  <th>returns</th>
 </tr><tr id="enqueue">
  <td><el-code><el-method>enqueue</el-method></el-code></td>
  <td><el-code><el-type>Queue</el-type></el-code></td>
  <td>item of Queue element's Type</td>
  <td><el-code><el-type>Queue</el-type></el-code></td>
  <td>the Queue with the element added to the end of the Queue</td>
 </tr><tr id="dequeue">
  <td><el-code><el-method>dequeue</el-method></el-code></td>
  <td><el-code><el-type>Queue</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Queue element Type,<br>Queue</el-type></el-code></td>
  <td>the next element of the Queue, and the Queue  with the element removed</td>
 </tr><tr id="peek_Queue">
  <td><el-code><el-method>peek</el-method></el-code></td>
  <td><el-code><el-type>Queue</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Queue elementType</el-type></el-code></td>
  <td>the next element of the Queue (without altering the Queue)</td>
 </tr><tr id="length_Queue">
  <td><el-code><el-method>length</el-method></el-code></td>
  <td><el-code><el-type>Queue</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>the number of elements in the Queue</td>
 </tr><tr id="asString_Queue">
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-type>Queue</el-type></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>a string representation of the queue (automatically called when printing)</td>
</tr>
</table>
<p>Example use of a <el-code><el-type>Stack</el-type></el-code>:</p>
<el-code-block source="stack.elan">
<el-statement class="ok" id="var35" tabindex="0"><el-kw>variable </el-kw><el-field id="var36" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr37" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Stack</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print6" tabindex="0"><el-kw>print </el-kw><el-field id="expr7" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set47" tabindex="0"><el-kw>set </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>push</el-method>("<el-lit>apple</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set52" tabindex="0"><el-kw>set </el-kw><el-field id="ident53" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr54" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>push</el-method>("<el-lit>Pear</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print14" tabindex="0"><el-kw>print </el-kw><el-field id="expr15" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print16" tabindex="0"><el-kw>print </el-kw><el-field id="expr17" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>peek</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var63" tabindex="0"><el-kw>variable </el-kw><el-field id="var64" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr65" class="ok" tabindex="0"><el-txt>""</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set66" tabindex="0"><el-kw>set </el-kw><el-field id="ident67" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr68" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>pop</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print21" tabindex="0"><el-kw>print </el-kw><el-field id="expr22" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set70" tabindex="0"><el-kw>set </el-kw><el-field id="ident71" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr72" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>pop</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print26" tabindex="0"><el-kw>print </el-kw><el-field id="expr27" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print28" tabindex="0"><el-kw>print </el-kw><el-field id="expr29" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
    <p>Example use of a <el-code><el-type>Queue</el-type></el-code>:</p>
<el-code-block source="queue.elan">
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>qu</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Queue</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print6" tabindex="0"><el-kw>print </el-kw><el-field id="expr7" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set8" tabindex="0"><el-kw>set </el-kw><el-field id="ident9" class="ok" tabindex="0"><el-txt><el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr10" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>enqueue</el-method>("<el-lit>apple</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set11" tabindex="0"><el-kw>set </el-kw><el-field id="ident12" class="ok" tabindex="0"><el-txt><el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr13" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>enqueue</el-method>("<el-lit>Pear</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print14" tabindex="0"><el-kw>print </el-kw><el-field id="expr15" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print16" tabindex="0"><el-kw>print </el-kw><el-field id="expr17" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>peek</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var18" tabindex="0"><el-kw>variable </el-kw><el-field id="var19" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt>""</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set21" tabindex="0"><el-kw>set </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>dequeue</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print24" tabindex="0"><el-kw>print </el-kw><el-field id="expr25" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set26" tabindex="0"><el-kw>set </el-kw><el-field id="ident27" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr28" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>dequeue</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print29" tabindex="0"><el-kw>print </el-kw><el-field id="expr30" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print31" tabindex="0"><el-kw>print </el-kw><el-field id="expr32" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<h1 id="CommonDotMethods">Common dot methods</h1>

<h2>Dot methods that work on more than one fundamental Type</h2>
<p>Although all applicable methods are described under each Type, this table lists those which are applicable to several Types.</p>
<p>The method <el-code><el-method>asString</el-method></el-code> is so widely applicable because it enables you to print
most variables and data structures to the Display for debugging purposes.</p>
<p>Click on a Type, or on the <el-id>&#x2714;</el-id> tick to go to the specific method.</p>
<table >
 <tr><th>Type</th><th colspan="8">method</th></tr>
 <tr>
  <td></td>
  <td><el-code><el-method>asList</el-method></el-code></td>
  <td><el-code><el-method>asString</el-method></el-code></td>
  <td><el-code><el-method>contains</el-method></el-code></td>
  <td><el-code><el-method>head</el-method></el-code></td>
  <td><el-code><el-method>indexOf</el-method></el-code></td>
  <td><el-code><el-method>length</el-method></el-code></td>
  <td><el-code><el-method>peek</el-method></el-code></td>
  <td><el-code><el-method>withPut</el-method></el-code></td>
 </tr><tr>
  <td><a href="#Int"><el-code><el-type>Int</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_Int">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#Float"><el-code><el-type>Float</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_Float">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#Boolean"><el-code><el-type>Boolean</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_Boolean">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#String"><el-code><el-type>String</el-type></el-code></a></td>
  <td><a href="#asList_String">&#x2714;</a></td>
  <td><a href="#asString_String">&#x2714;</a></td>
  <td><a href="#contains_String">&#x2714;</a></td>
  <td></td>
  <td><a href="#indexOf_String">&#x2714;</a></td>
  <td><a href="#length_String">&#x2714;</a></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#Array"><el-code><el-type>Array</el-type></el-code></a></td>
  <td><a href="#asList_Array">&#x2714;</a></td>
  <td><a href="#asString_Array">&#x2714;</a></td>
  <td><a href="#contains_Array">&#x2714;</a></td>
  <td></td>
  <td><a href="#indexOf_Array">&#x2714;</a></td>
  <td><a href="#length_Array">&#x2714;</a></td>
  <td></td>
  <td><a href="#withPut_Array">&#x2714;</a></td>
 </tr><tr>
  <td><a href="#Array2D"><el-code><el-type>Array2D</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_Array2D">&#x2714;</a></td>
  <td><a href="#contains_Array2D">&#x2714;</a></td>
  <td></td>
  <td><a href="#indexOf_Array2D">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td><a href="#withPut_Array2D">&#x2714;</a></td>
 </tr><tr>
  <td><a href="#List"><el-code><el-type>List</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_List">&#x2714;</a></td>
  <td><a href="#contains_List">&#x2714;</a></td>
  <td><a href="#head_List">&#x2714;</a></td>
  <td><a href="#indexOf_List">&#x2714;</a></td>
  <td><a href="#length_List">&#x2714;</a></td>
  <td></td>
  <td><a href="#withPut_List">&#x2714;</a></td>
 </tr><tr>
  <td><a href="#Dictionary"><el-code><el-type>Dictionary</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_Dictionary">&#x2714;</a></td>
  <td>see notes</td>
  <td></td>
  <td></td>
  <td>see notes</td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#ListImmutable"><el-code><el-type>ListImmutable</el-type></el-code></a></td>
  <td><a href="#asList_ListImmutable">&#x2714;</a></td>
  <td><a href="#asString_ListImmutable">&#x2714;</a></td>
  <td><a href="#contains_ListImmutable">&#x2714;</a></td>
  <td><a href="#head_ListImmutable">&#x2714;</a></td>
  <td><a href="#indexOf_ListImmutable">&#x2714;</a></td>
  <td><a href="#length_ListImmutable">&#x2714;</a></td>
  <td></td>
  <td><a href="#withPut_ListImmutable">&#x2714;</a></td>
 </tr><tr>
  <td><a href="#DictionaryImmutable"><el-code><el-type>DictionaryImmutable</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_DictionaryImmutable">&#x2714;</a></td>
  <td>see notes</td>
  <td></td>
  <td></td>
  <td>see notes</td>
  <td></td>
  <td><a href="#withPut_DictionaryImmutable">&#x2714;</a></td>
 </tr><tr>
  <td><a href="#SetType"><el-code><el-type>Set</el-type></el-code></a></td>
  <td><a href="#asList_Set">&#x2714;</a></td>
  <td><a href="#asString_Set">&#x2714;</a></td>
  <td><a href="#contains_Set">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td><a href="#length_Set">&#x2714;</a></td>
  <td></td>
  <td></td>
 </tr><tr>
  <td><a href="#Stack"><el-code><el-type>Stack</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_Stack">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#length_Stack">&#x2714;</a></td>
  <td><a href="#peek_Stack">&#x2714;</a></td>
  <td></td>
 </tr><tr>
  <td><a href="#Queue"><el-code><el-type>Queue</el-type></el-code></a></td>
  <td></td>
  <td><a href="#asString_Queue">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#length_Queue">&#x2714;</a></td>
  <td><a href="#peek_Queue">&#x2714;</a></td>
  <td></td>
 </tr>
</table>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>The length of a <el-code><el-type>Dictionary</el-type></el-code> or <el-code><el-type>DictionaryImmutable</el-type></el-code> can be found by applying method <el-code><el-method>length</el-method></el-code> to the list returned by method <el-code><el-method>keys</el-method></el-code> on the dictionary:</li>
  <p><el-code>print dict.keys().length()</el-code> &rarr; 15</p>
 <li>Checking whether an item is contained in a <el-code><el-type>Dictionary</el-type></el-code> or <el-code><el-type>DictionaryImmutable</el-type></el-code> can be
  done by applying method <el-code><el-method>contains</el-method></el-code> to the list returned by methods <el-code><el-method>keys</el-method></el-code> and <el-code><el-method>values</el-method></el-code> on the dictionary:</li>
  <p><el-code>print dict.keys().contains(42)</el-code> &rarr; <el-code><el-id>true</el-id></el-code> or <el-code><el-id>false</el-id></el-code></p>
  <p><el-code>print dict.values().contains("widget")</el-code> &rarr; <<el-code>el-id>true</el-id></el-code> or <el-code><el-id>false</el-id></el-code></p>
</ul>

<h1 id="Input/output">Input/output</h1>

<h2 id="TextFileReader">Reading Text Files</h2>
<p>The <el-code><el-type>TextFileReader</el-type></el-code> class is used to read textual data from a file.</p>
<p>An instance is created by the standalone system method <el-code><el-method>openFileForReading</el-method></el-code>.</p>
<p>The available procedure methods are:</p>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>argument<br>Type</th>
  <th>action</th>
 </tr><tr id="openFileForReading">
  <td><el-code><el-method>openFileForReading</el-method></el-code></td>
  <td><el-code><el-type>(none)</el-type></el-code></td>
  <td>opens a file system dialog to choose the filename to be read, which must have the filetype .txt<br>
  and returns a file handle</td>
 </tr><tr id="file system
  <td><el-code><el-method>readLine</el-method></el-code></td>
  <td><el-code><el-type>(none)</el-type></el-code></td>
  <td>reads the next substring from the file that is terminated with a newline</td>
 </tr><tr id="readWholeFile">
  <td><el-code><el-method>readWholeFile</el-method></el-code></td>
  <td><el-code><el-type>(none)</el-type></el-code></td>
  <td>reads the whole file and closes the file</td>
 </tr><tr id="endOfFile">
  <td><el-code><el-method>endOfFile</el-method></el-code></td>
  <td><el-code><el-type>(none)</el-type></el-code></td>
  <td>returns <el-code><el-id>true</el-id></el-code> after the last line has been read<br>
  &ndash; otherwise <el-code><el-kw>false</el-kw></el-code></td>
 </tr><tr id="close">
  <td><el-code><el-method>close</el-method></el-code></td>
  <td><el-code><el-type>(none)</el-type></el-code></td>
  <td>closes the file</td>
 </tr>
</table>
<p>These methods may be used to read a whole file in one go:</p>
<el-code-block source="TextFileReader_1.elan">
  <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>file</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>openFileForReading</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let6" tabindex="0"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>text</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>readWholeFile</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call9" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>close</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args11" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
  <el-statement class="ok" id="print12" tabindex="0"><el-kw>print </el-kw><el-field id="expr13" class="optional ok" tabindex="0"><el-txt><el-id>text</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<p>or to read a file line by line:</p>
<el-code-block source="TextFileReader_2.elan">
  <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>file</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>openFileForReading</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="var6" tabindex="0"><el-kw>variable </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>lines</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="while9" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr11" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>file</el-id>.<el-method>endOfFile</el-method>()</el-txt><el-place><i>condition</i></el-place></el-field></el-top>
  <el-statement class="ok" id="let12" tabindex="0"><el-kw>let </el-kw><el-field id="var13" class="ok" tabindex="0"><el-txt><el-id>line</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>readLine</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>lines</el-id>.<el-method>append</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args17" class="optional ok" tabindex="0"><el-txt><el-id>line</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-kw>end while</el-kw>
  </el-statement>
  <el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>close</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args20" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
<li><el-code>openFileForReading</el-code> will present the user with a dialog to select the file.</li>
<li><el-code>readWholeFile</el-code> returns a <el-code><el-type>String</el-type></el-code> containing every character in the file, without any trimming. It automatically closes the file after the read.</li>
<li><el-code>readLine</el-code> reads as far as the next newline character (<el-code>\n</el-code>) and then automatically trims the line to remove any spaces and/or carriage-returns (which some file systems insert after the newline automatically) from the resulting line returned as a <el-code><el-type>String</el-type></el-code>. If this behaviour is not desired, you can use <el-code>readWholeFile</el-code>, which does no trimming, and then parse the resulting <el-code><el-type>String</el-type></el-code> into separate lines.</li>
<li>Calling <el-code>file.close</el-code> after reading line by line is strongly recommended to avoid any risk of leaving the file locked. It is not necessary to call it after using <el-code>readWholeFile</el-code> because that method automatically closes the file.</li>
<li>Calling any method on a file that is already closed will result in a runtime error.</li>
</ul>

<h2 id="TextFileWriter">Writing text files</h2>
<p>The <el-code><el-type>TextFileWriter</el-type></el-code> class is used to write textual data to a file.</p>
<p>An instance is created by the standalone system method <el-code><el-method>createFileForWriting</el-method></el-code>.</p>
<p>The available procedure methods are:</p>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>argument<br>Type</th>
  <th>action</th>
 </tr><tr id="createFileForWriting">
  <td><el-code><el-method>creatFileForWriting</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>sets up a buffer for the data to be output, and specifies a filename (or the empty string)<br>
  with or without the default filetype of .txt<br>
  and returns a file handle</td>
 </tr><tr id="writeLine">
  <td><el-code><el-method>writeLine</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>writes the string to the buffer</td>
 </tr><tr id="writeWholeFile">
  <td><el-code><el-method>writeWholeFile</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>writes the string to the buffer and then outputs the buffer to the file sytsem</td>
 </tr><tr id="saveAndClose">
  <td><el-code><el-method>saveAndClose</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>writes the buffer to the file system</td>
 </tr>
</table>
<p>These methods may be used to write a whole file in one go:</p>
<el-code-block source="TextFileWriter_1.elan">
    <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>f</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>createFileForWriting</el-method>("<el-lit>myFile.txt</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>f</el-id>.<el-method>writeWholeFile</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt>"<el-lit>this is\nmyText</el-lit>"</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
</el-code-block>
<p>or to write a file line by line:</p>
<el-code-block source="TextFileWriter_2.elan">
    <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>file</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>createFileForWriting</el-method>("<el-lit>squares.txt</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok multiline" id="for6" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident8" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr10" class="ok" tabindex="0"><el-txt><el-lit>100</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr11" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
    <el-statement class="ok" id="call12" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident13" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>writeLine</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args14" class="optional ok" tabindex="0"><el-txt>"<el-lit></el-lit>{<el-id>i</el-id>}<el-lit> </el-lit>{<el-id>i</el-id>*<el-id>i</el-id>}<el-lit></el-lit>"</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
    <el-kw>end for</el-kw>
    </el-statement>
    <el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>saveAndClose</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args17" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
<li><el-code>writeLine</el-code> adds the string it is passed onto the end of any data previously written, with a newline character (<el-code>\n</el-code>) automatically appended.</li>
<li>When execution reaches <el-code>saveAndClose</el-code> you will be presented with a dialog to confirm (or edit) the given filename and location where it is to be saved. It is not therefore strictly necessary to specify a filename when creating the file, since it can be specified by the user in the dialog so, in that case, you might put the empty string <el-code>""</el-code> into the parameter of <el-code>createFileForWriting</el-code>.</li>
<li><el-code>writeWholeFile</el-code> puts the string it is given into the file and then automatically saves the file, so the user will be presented with the same dialog as if <el-code>saveAndClose</el-code> had been called.</li>
<li>Calling any method on a file that has already been closed (by calling either <el-code>saveAndClose</el-code> or by <el-code>writeWholeFile</el-code>) will result in a runtime error.</li>
<li>If the user were to hit Cancel on the save dialog, then the program will exit with an error. If you want to guard against this possibility (if, for example, it might mean the loss of important data) then you should perform the save and close within a <el-code>try..catch</el-code> like this:</li>

<el-code-block source="TextFileWriter_3.elan">
<el-statement class="ok multiline" id="try35" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>saveAndClose</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args17" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok multiline outdent" id="catch37" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident39" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok" id="print47" tabindex="0"><el-kw>print </el-kw><el-field id="expr48" class="optional ok" tabindex="0"><el-txt>"<el-lit>File save cancelled</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>
<p>or you could make the code offer the user options: to save again, or to continue without saving.</p>
</ul>

div id="DisplayHtml"></div>
<h2 id="Html">Displaying Html</h2>
<p>If you attempt to embed Html in a string and then attempt to print it, you will see the string displayed literally - the Html tags
    will not be recognised - this is for security reasons. However, it <i>is</i> possible to display formatted Html on the <b>Display.</b>
    The following code:</p>

<el-code-block source="Html_1.elan">
    <el-statement class="ok" id="call5" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-method>displayHtml</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args7" class="optional ok" tabindex="0"><el-txt>"<el-lit>&lt;h1 style='color: blue;'&gt;A heading&lt;/h1&gt;&lt;p&gt;some text&lt;/p&gt;</el-lit>"</el-txt><el-place><i>html</i></el-place></el-field>)</el-top></el-statement>
</el-code-block>

<p>will produce:</p>
<img src="images/Html_1.png" width="206" height="211">

<p>This Html forms another 'layer' of the Display. Any plain text that you print
    (using <el-code><el-kw>print</el-kw></el-code> or any of the <el-code><el-method>print...</el-method></el-code> procedures)
    will be overlaid on top of this.</p>

<p>You can programmatically clear just the Html display using the procedure <el-code><el-method>clearDisplay</el-method></el-code>.</p>

<p>For specifying style or other attributes within Html tags, the attribute values should be enclosed in single quotation marks ' as shown above.
    Html will recognise single or double quotation marks, but entering double quotation marks would terminate the Elan string.
    Alternatively, you could use the constant <el-code><el-id>quotes</el-id></el-code> within braces as an interpolated field.</p>

<h3 class="no-TOC">Using an embedded CSS stylesheet</h3>
<p>You can also specify a <el-code><el-method>style</el-method></el-code> tag at the start of your Html string, to apply to the whole Html being displayed:</p>
<el-code-block source="Html_2.elan">
    <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>style</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>"<el-lit>&lt;style&gt; h1 </el-lit>{<el-id>openBrace</el-id>}<el-lit> color: DarkRed; font-size: 24pt; </el-lit>{<el-id>closeBrace</el-id>}<el-lit> p </el-lit>{<el-id>openBrace</el-id>}<el-lit> font-family: Serif;</el-lit>{<el-id>closeBrace</el-id>}<el-lit> &lt;/style&gt;</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-method>displayHtml</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt>"<el-lit></el-lit>{<el-id>style</el-id>}<el-lit>&lt;h1&gt;New heading&lt;/h1&gt;&lt;p&gt;some new text&lt;/p&gt;</el-lit>"</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
</el-code-block>

<p>producing this result:</p>
<img src="images/Html_2.png" width="277" height="219">

<h2 id="image">Displaying images</h2>

<h3 class="no-TOC">Printing an image on the Display</h3>
<p>An image that can be accessed via a URL may be printed on the display using the <el-code><el-kw>image</el-kw></el-code> keyword followed by the URL. Here, the URL is <i>not</i> bounded by quotes:</p>
<el-code>
<el-statement class="ok" id="print3" tabindex="0"><el-kw>print </el-kw><el-field id="expr4" class="selected focused optional ok" tabindex="0"><el-txt><input spellcheck="false" data-cursorstart="88" data-cursorend="88" size="87" style="width: 88ch" value="image https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg"></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>

<p>As soon as you leave the field the text will change to show a thumbnail copy of the image:</p>

<el-code>
<el-statement class="ok" id="print3" tabindex="0"><el-kw>print </el-kw><el-field id="expr4" class="optional ok" tabindex="0"><el-txt><img src="https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg"></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>
<p>If you edit the field again, the keyword and URL will be shown.</p>

<p>Acknowledgement: The idea of displaying an image value as a thumbnail within the code was inspired by
    a similar feature in the language <a href="https://strype.org">Strype</a>. We are
grateful to Prof. Michael K&ouml;lling and the team at King's College, London responsible for Strype,
who showed us this feature in confidence before its release, but nonetheless generously allowed us to mimic it in Elan.</p>

<p>When the code is run the image will be printed on the <b>Display</b>, but still thumbnail sized.
    You can specify dimensions by using a <el-code><el-kw>with</el-kw></el-code> clause like this:</p>

<el-code>
<el-statement class="ok" id="print3" tabindex="0"><el-kw>print </el-kw><el-field id="expr4" class="selected focused optional ok" tabindex="0"><el-txt><input spellcheck="false" data-cursorstart="129" data-cursorend="129" size="128" style="width: 129ch" value="image https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg with width set to 200, height set to 110"></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>

<p>The <el-code><el-kw>with</el-kw></el-code> clause also permits you to specify a title for the image, which shows up as a tooltip on the image. It is good practice to do this for meeting accessibility guidelines.The <el-code><el-kw>with</el-kw></el-code> clause
also offers position properties <el-code><el-id>x</el-id></el-code> and <el-code><el-id>y</el-id></el-code>. These are ignored when <i>printing</i> an image, but are useful in the context of drawing <a href="#VectorGraphics">Vector Graphics</a>.</p>

<p>An image specified in this way may also be assigned to a named value, or defined inline as an argument to a method, for example:</p>

<el-code>
<el-statement class="ok" id="let5" tabindex="0"><el-kw>let </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>shark</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><img src="https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg"></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>

<p>The Type of a named value that holds an image is <el-code><el-type>ImageVG</el-type></el-code> &ndash; the 'VG' indicating that
    this Typeis compatible with <a href="#VectorGraphics">vector graphics</a>, so an image may be added to a <el-code><el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt;</el-code> or displayed
    directly by:</p>

<el-code>
<el-statement class="ok" id="call5" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-method>displayVectorGraphics</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args7" class="selected focused optional ok" tabindex="0"><el-txt><input spellcheck="false" data-cursorstart="1" data-cursorend="1" size="89" style="width: 90ch" value="[image https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg]"></el-txt><el-place><i>listOfVGs</i></el-place></el-field>)</el-top></el-statement>
</el-code>

<p>In this usage the position may be controlled by specifying the <el-code><el-id>x</el-id></el-code> and <el-code><el-id>y</el-id></el-code> coordinates for the top-left corner.</p>

<p>It is also possible to instantiate an <el-code><el-type>ImageVG</el-type></el-code> explicitly, but in this case you must provide
the URL as a <el-code><el-type>String</el-type></el-code>, either as a literal (by surrounding it with quotes) or as a named value, for example:</p>

<el-code-block>
<el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>url</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>"<el-lit>https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let7" tabindex="0"><el-kw>let </el-kw><el-field id="var8" class="ok" tabindex="0"><el-txt><el-id>img1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>ImageVG</el-type>(<el-id>url</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print10" tabindex="0"><el-kw>print </el-kw><el-field id="expr11" class="optional ok" tabindex="0"><el-txt><el-id>img1</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>Various properties can be set on an <el-code><el-type>ImageVG</el-type></el-code>  using a <el-code><el-kw>with</el-kw></el-code> clause, for example:</p>
<el-code>
          <el-statement class="ok" id="let8" tabindex="0"><el-kw>let </el-kw><el-field id="var9" class="ok" tabindex="0"><el-txt><el-id>url</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr10" class="ok" tabindex="0"><el-txt>"<el-lit>https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
        <el-statement class="ok" id="let11" tabindex="0"><el-kw>let </el-kw><el-field id="var12" class="ok" tabindex="0"><el-txt><el-id>img1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr13" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>ImageVG</el-type>(<el-id>url</el-id>)<el-kw> with </el-kw><br><el-id>alt</el-id><el-kw> set to </el-kw>"<el-lit>shark</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code>
<p>The properties are:</p>
<table>
    <tr><th>Property</th><th>Type</th><th>Description</th></tr>
    <tr><td><el-code><el-id>alt</el-id></el-code></td><td><el-code><el-type>String</el-type></el-code></td><td>Alternate textual description (for assessibility)</td></tr>
    <tr><td><el-code><el-id>height</el-id></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>height to render the image</td></tr>
    <tr><td><el-code><el-id>title</el-id></el-code></td><td><el-code><el-type>String</el-type></el-code></td><td>Textual title to be read by user</td></tr>
    <tr><td><el-code><el-id>width</el-id></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>width to render the image</td></tr>
    <tr><td><el-code><el-id>x</el-id></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>Horizontal position within the pane</td></tr>
    <tr><td><el-code><el-id>y</el-id></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>Vertical position within the pane</td></tr>
</table>

<h1>Graphics</h1>

<h2 id="BlockGraphics">Block graphics</h2>
<p>Block graphics<el-code> </el-code>provides a simple way to create low resolution graphics, ideal for simple but engaging games for example.
     The graphics are displayed on a grid that is 40 blocks wide by 30 blocks high.</p>
<p>Each block is be rendered as a solid colour.</p>
<p>An example of block graphics to produce a rapidly changing pattern of coloured blocks:</p>

<el-code-block source="block_graphics.elan">
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>blocks</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Array2D</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;(<el-lit>40</el-lit>, <el-lit>30</el-lit>, <el-id>white</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="while6" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>condition</i></el-place></el-field></el-top>
<el-statement class="ok" id="let9" tabindex="0"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr11" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let12" tabindex="0"><el-kw>let </el-kw><el-field id="var13" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let15" tabindex="0"><el-kw>let </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>colour</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-id>white</el-id> - <el-lit>1</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>blocks</el-id>.<el-method>put</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>y</el-id>, <el-id>colour</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call21" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-method>displayBlocks</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args23" class="optional ok" tabindex="0"><el-txt><el-id>blocks</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-kw>end while</el-kw>
</el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>The <el-code><el-type>Array2D</el-type></el-code> must be of Type<el-code><el-type>Int</el-type></el-code> and of size 40 x 30.</li>
 <li>You may create multiple <el-code><el-type>Array2Ds</el-type></el-code> holding different patterns of blocks, and switch between them
 just by passing the required one as the argument to the <el-code><el-method>displayBlocks</el-method></el-code> method.</li>
 <li>A colour is specified as an <el-code><el-type>Int</el-type></el-code>, as described under <a href="#Colours">Colours</a>.</li>
</ul>

<h2 id="TurtleGraphics">Turtle graphics</h2>
<p>Turtle graphics are implemented in Elan with output to the Display pane on the screen, i.e. the 'paper' on which the Turtle draws.</p>
<p>The area is 100 turtle units wide by 75 turtle units high, but floating point (fractional) values of turtle units can be used.</p>
<p>The origin for turtle units (0,0) is at the top left of the display: positive x rightwards, positive y downwards.</p>

<h3 class="no-TOC" id="List_procedures">Procedure methods on a Turtle</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="hide">
  <td><el-code><el-method>hide</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td>(none)</td>
  <td>makes the turtle invisible in the display</td>
 </tr><tr id="move">
  <td><el-code><el-method>move</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code> or <el-code><el-type>Float</el-type></el-code></td>
  <td>moves the turtle the specified number of turtle units in the direction it is facing or,<br>if negative, in the opposite direction</td>
 </tr><tr id="penColour">
  <td><el-code><el-method>penColour</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>changes the <a href="#Colours">colour</a> of its path in the display to the literal or named value specified</td>
 </tr><tr id="penDown">
  <td><el-code><el-method>penDown</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td>(none)</td>
  <td>makes the turtle's subsequent moves leave a trace of its path in the display</td>
 </tr><tr id="penUp">
  <td><el-code><el-method>penUp</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td>(none)</td>
  <td>makes the turtle's subsequent moves leave no trace of its path in the display</td>
 </tr><tr id="penWidth">
  <td><el-code><el-method>penWidth</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code> or <el-code><el-type>Float</el-type></el-code></td>
  <td>changes the width of the line tracing the turtle's path in the display<br>default, and minimum, is 1 </td>
 </tr><tr id="placeAt">
  <td><el-code><el-method>placeAt</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code> or <el-code><el-type>Float</el-type></el-code>,<br>
      <el-code><el-type>Int</el-type></el-code> or <el-code><el-type>Float</el-type></el-code></td>
  <td>places or repositions the turtle at the x,y position specified</td>
 </tr><tr id="show">
  <td ><el-code><el-method>show</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td>(none)</td>
  <td>makes the turtle visible in the display as a green blob<br>marked with a black radius that indicates the direction it is facing</td>
 </tr><tr id="turn">
  <td><el-code><el-method>turn</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code> or <el-code><el-type>Float</el-type></el-code></td>
  <td>turns the turtle through the specified number of degrees clockwise or,<br>if negative, anticlockwise</td>
 </tr><tr id="turnTo">
  <td><el-code><el-method>turnTo</el-method></el-code></td>
  <td><el-code><el-type>Turtle</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code> or <el-code><el-type>Float</el-type></el-code></td>
  <td>turns the turtle to face in the direction specified in degrees<br>where 0 is upward and increasing values go clockwise from there</td>
 </tr>
</table>
<p>Example:</p>
<el-code-block source="turtle_graphics.elan">
<el-statement class="ok" id="let5" tabindex="0"><el-kw>let </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>t</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Turtle</el-type>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="call8" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident9" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>placeAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args10" class="optional ok" tabindex="0"><el-txt><el-lit>10</el-lit>, <el-lit>10</el-lit></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call17" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident18" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>show</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args19" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok multiline" id="for26" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident28" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr29" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>4</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="call36" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident37" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args38" class="optional ok" tabindex="0"><el-txt><el-lit>90</el-lit></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call48" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident49" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>move</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args50" class="optional ok" tabindex="0"><el-txt><el-lit>40</el-lit></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call63" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident64" class="ok" tabindex="0"><el-txt><el-method>pause</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args65" class="optional ok" tabindex="0"><el-txt><el-lit>500</el-lit></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>
<p>Output:</p>
<img src="images/Pic30.png"  align="MIDDLE" width="277" height="280">

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>If the turtle is placed or moved outside the 100 &times; 75 area boundary, it will not cause an error,
  but the location of the turtle and any lines outside the boundary will not be visible.</li>
 <li>You can move and turn the turtle, causing lines to be drawn, whether or not the turtle is shown.</li>
 <li>The current location and heading of the turtle may be read using the properties
  <el-code><el-id>x</el-id></el-code>, <el-code><el-id>y</el-id></el-code>, and <el-code><el-id>heading</el-id></el-code>.</li>
</ul>
<p>Here is a more sophisticated example, using a procedure and recursion, that produces a fractal snowflake:</p>
<el-code-block source="turtle_snowflake.elan">
<main class="ok multiline" id="main1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw></el-top>
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>t</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Turtle</el-type>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>placeAt</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt><el-lit>20</el-lit>, <el-lit>20</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call9" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args11" class="optional ok" tabindex="0"><el-txt><el-lit>90</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call12" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident13" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>show</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args14" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok multiline" id="for15" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr19" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="call21" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args23" class="optional ok" tabindex="0"><el-txt><el-id>side</el-id>, <el-id>t</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call24" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args26" class="optional ok" tabindex="0"><el-txt><el-lit>120</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
<el-kw>end main</el-kw>
</main>
<el-proc class="ok multiline" id="proc27" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident29" class="ok" tabindex="0"><el-txt>drawSide</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params30" class="optional ok" tabindex="0"><el-txt><el-id>length</el-id> <el-kw>as</el-kw> <el-type>Float</el-type>, <el-id>t</el-id> <el-kw>as</el-kw> <el-type>Turtle</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)</el-top>
<el-statement class="ok multiline" id="if31" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr33" class="ok" tabindex="0"><el-txt>(<el-id>length</el-id> &gt; <el-lit>1</el-lit>)</el-txt><el-place><i>condition</i></el-place></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="let34" tabindex="0"><el-kw>let </el-kw><el-field id="var35" class="ok" tabindex="0"><el-txt><el-id>third</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr36" class="ok" tabindex="0"><el-txt><el-id>length</el-id>/<el-lit>3</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="call37" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident38" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args39" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call40" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident41" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args42" class="optional ok" tabindex="0"><el-txt>-<el-lit>60</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call43" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident44" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args45" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call46" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident47" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args48" class="optional ok" tabindex="0"><el-txt><el-lit>120</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call49" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident50" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args51" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call52" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident53" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args54" class="optional ok" tabindex="0"><el-txt>-<el-lit>60</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call55" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident56" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args57" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok outdent" id="else58" tabindex="0"><el-top>
    <el-kw>else </el-kw><el-field id="elif60" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>if</i></el-place></el-field></el-top></el-statement>
<el-statement class="ok" id="call61" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident62" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>move</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args63" class="optional ok" tabindex="0"><el-txt><el-id>length</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-kw>end if</el-kw>
</el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-const class="ok multiline" id="const64" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident65" class="ok" tabindex="0"><el-txt><el-id>side</el-id></el-txt><el-place><i>name</i></el-place></el-field></el-top><el-kw> set to </el-kw><el-field id="text66" class="ok" tabindex="0"><el-txt><el-lit>60</el-lit></el-txt><el-place><i>literal value or data structure</i></el-place></el-field></el-const>
</el-code-block>
<p><img src="images/Pic31.png"  align="MIDDLE" width="479" height="420" ></p>

<h2 id="VectorGraphics">Vector graphics</h2>
<!-- TODO tabulate VG procedures and their arguments -->
<div id="vectorGraphic"></div>
<div id="append_VG"></div>
<div id="centreX"></div>
<div id="centreY"></div>
<div id="radius"></div>
<div id="fillColour"></div>
<div id="setFillColour"></div>
<div id="strokeColour"></div>
<div id="strokeWidth"></div>
<p>Vector graphics are displayed using SVG (Scalable Vector Graphics) that are a part of the Html specification. The names of the shapes broadly correspond to the names of SVG tags:</p>
<ul>
 <li id="CircleVG"> <el-code>CircleVG</el-code> for &lt;<el-code>circle../&gt;</el-code></li>
 <li id="LineVG"><el-code>LineVG</el-code> for <el-code>&lt;line../&gt;</el-code></li>
 <li id="RectangleVG"><el-code>RectangleVG</el-code> for <el-code>&lt;rect../&gt;</el-code></li>
 <li id="ImageVG"><el-code>ImageVG</el-code> for <el-code>&lt;image../&gt;</el-code></li>
 <li id="TextVG"><el-code>TextVG</el-code> for <el-code>&lt;text../&gt;</el-code></li>
</ul>
<p>The properties of the Elan VG shapes match the names of the attributes used in the SVG tags, except that the <el-code>stroke-width</el-code> attribute is changed to <el-code>strokeWidth</el-code> to make it a valid <a href="LangRef.html#identifier">Identifier</a>.</p>
<p>The &#8216;canvas&#8217; on which vector graphics are drawn (the Display pane in the user interface) is 100 units wide, by 75 units high. All numeric values specified for attributes of vector graphic shapes may be integer or floating point.</p>
<p>Example:</p>
<el-code-block source="VG_circle.elan">
        <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>vg</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
        <el-statement class="ok" id="let6" tabindex="0"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>circ</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>CircleVG</el-type>()<el-kw> with </el-kw><br><el-id>centreX</el-id><el-kw> set to </el-kw><el-lit>20</el-lit>, <br><el-id>centreY</el-id><el-kw> set to </el-kw><el-lit>20</el-lit>, <br><el-id>radius</el-id><el-kw> set to </el-kw><el-lit>5</el-lit>, <br><el-id>fillColour</el-id><el-kw> set to </el-kw><el-id>red</el-id>, <br><el-id>strokeColour</el-id><el-kw> set to </el-kw><el-id>green</el-id>, <br><el-id>strokeWidth</el-id><el-kw> set to </el-kw><el-lit>2</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
        <el-statement class="ok" id="call9" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="0"><el-txt><el-id>vg</el-id>.<el-method>append</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args11" class="optional ok" tabindex="0"><el-txt><el-id>circ</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-statement class="ok" id="call12" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident13" class="ok" tabindex="0"><el-txt><el-method>displayVectorGraphics</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args14" class="optional ok" tabindex="0"><el-txt><el-id>vg</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
</el-code-block>
<p>Output:</p>
<p><img src="images/Pic33.png"  align="MIDDLE" width="343" height="253" ></p>
<p>This example creates a circle that changes between red and green every second:</p>
<p>
</p>
<el-code-block source="VG_2circles.elan">
        <el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>vg</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
        <el-statement class="ok" id="let6" tabindex="0"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>circ</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>CircleVG</el-type>()<el-kw> with </el-kw><br><el-id>centreX</el-id><el-kw> set to </el-kw><el-lit>50</el-lit>, <br><el-id>centreY</el-id><el-kw> set to </el-kw><el-lit>37</el-lit>, <br><el-id>radius</el-id><el-kw> set to </el-kw><el-lit>30</el-lit>, <br><el-id>fillColour</el-id><el-kw> set to </el-kw><el-id>green</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
        <el-statement class="ok" id="call9" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="0"><el-txt><el-id>vg</el-id>.<el-method>append</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args11" class="optional ok" tabindex="0"><el-txt><el-id>circ</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-statement class="ok multiline" id="while12" tabindex="0">
        <el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>condition</i></el-place></el-field></el-top>
        <el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-method>displayVectorGraphics</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args17" class="optional ok" tabindex="0"><el-txt><el-id>vg</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-method>pause</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-lit>700</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-statement class="ok" id="call21" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>circ</el-id>.<el-method>setFillColour</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args23" class="optional ok" tabindex="0"><el-txt><el-id>red</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-statement class="ok" id="call24" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-method>displayVectorGraphics</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args26" class="optional ok" tabindex="0"><el-txt><el-id>vg</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-statement class="ok" id="call27" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident28" class="ok" tabindex="0"><el-txt><el-method>pause</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args29" class="optional ok" tabindex="0"><el-txt><el-lit>700</el-lit></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-statement class="ok" id="call30" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident31" class="ok" tabindex="0"><el-txt><el-id>circ</el-id>.<el-method>setFillColour</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args32" class="optional ok" tabindex="0"><el-txt><el-id>green</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
        <el-kw>end while</el-kw>
        </el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>The constructor for each VG Type requires arguments corresponding the Html attributes for the corresponding SVGType.</li>
 <li>As with <span class="Link">Block</span> graphics the screen is not updated until the <el-code><el-method>displayVectorGraphics</el-method></el-code> method is called,
   allowing you to make multiple changes before updating the screen. Similarly, the method to add a shape returns a new instance of the <el-code>VectorGraphics</el-code> which must be assigned either to an existing variable, or to a new <el-code><el-kw>let</el-kw></el-code>.</li>
 <li>As with the way that SVG works within Html, the shapes are drawn in the order in which they are added into the list of <el-code><el-type>VectorGraphic</el-type></el-code> instances, with later shapes positioned over earlier shapes.</li>
 <li>The <el-code><el-id>fillColour</el-id></el-code> and <el-code><el-id>strokeColour</el-id></el-code> properties may be specified as described under <a href="#Colours">Colours</a>.
  The <el-code><el-id>fillColour</el-id></el-code> only may also be specified as <el-code><el-id>transparent</el-id></el-code> (which has the value <el-code>-1</el-code>).</li>
 <li><el-code><el-type>VectorGraphic</el-type></el-code> is the abstract superclass of all <el-code>...VG</el-code> shapes. You would only use it if you wanted to define a method that could work on any shape (using common elements defined on <el-code>VectorGraphic</el-code>) or that could work with a <el-code><el-type>List</el-type></el-code> holding different types of shape.</li>
 <li>The constructor parameters for <el-code><el-type>CircleVG</el-type></el-code> are: <el-code>centreX, centreY, radius, fillColour, strokeColour, strokeWidth</el-code>.</li>
 <li>The constructor parameters for <el-code><el-type>LineVG</el-type></el-code> are: <el-code>x1, y1, x2, y2, strokeColour, strokeWidth</el-code>, all of Type <el-code><el-type>Int</el-type></el-code>.</li>
 <li>The constructor parameters for <el-code><el-type>LineVG</el-type></el-code> are: <el-code>x, y, width, height, fillColour, strokeColour, strokeWidth</el-code>.</li>
 <li>All parameters for the three constructors above are of Type<el-code><el-type>Int</el-type></el-code>.</li>
 <li>Individual properties of any of the VGTypes may be modified by calling the corresponding <el-code><el-method>set...</el-method></el-code> procedure method
  or, if working within a function, by using the corresponding <el-code><el-method>with...</el-method></el-code> function method.</li>
 <li><el-code><el-method>displayVectorGraphics</el-method></el-code> takes as an argument either a <el-code><el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt;()</el-code>
  or a <el-code><el-type>List</el-type></el-code> of any specific Typeof <el-code><el-type>VectorGraphic</el-type></el-code> such as <el-code><el-type>CircleVG</el-type></el-code>.</li>
</ul>

<h2 id="combiningGraphics">Combining graphic outputs</h2>
<p>Program outputs, whether text or graphical, can be combined in the Display. In particular, Block graphics and text or Html printing can share the Display
 along with <em>either</em> Vector graphics <em>or</em> Turtle graphics (but not both).</p>
<p>If you want to share the Display in this way, remember that both text and Html print outputs appear sequentially down the Display (which can be scrolled), whereas the graphic outputs are positioned in the Display using their own absolute coordinate systems.</p>
<p>The order in which the outputs are displayed (and therefore overwrite) is:</p>
<ol>
 <li>Block graphics</li>
 <li>Vector <em>or</em> Turtle graphics</li>
 <li>Printed text or Html</li>
</ol>
<p>so some care is needed to manage the layout in the Display.</p>

<h1>Other Types</h1>

<h2 id="Func">Func</h2>
<p>A function may be passed as an argument into another function (or a procedure), or returned as the result of calling another function.
This pattern is known as <b>Higher order Function (HoF)</b>, and is a key idea in the Functional Programming.</p>
<p>To define a function that takes in another function as a parameter, or returns a function, you need to specify the Type of the function,
just as you would specify the Type of every parameter and the return Type for the function. </p>

<h3 class="no-TOC">Type name</h3>
<p>The Type of any function starts with the word <el-code><el-type>Func</el-type></el-code> followed by angle brackets defining the Type of each parameter,
    and the return Type for that function, following this syntax:</p>
<el-code>Func&lt;of String, String, Int =&gt; Boolean&gt;</el-code><!-- TODO correct the syntax -->
<p>This example defines the Type for a function that defines three parameters of Type <el-code><el-type>String</el-type></el-code>, <el-code><el-type>String</el-type></el-code>, and <el-code><el-type>Int</el-type></el-code> respectively, and returns a <el-code><el-type>Boolean</el-type></el-code> value. This Type would match that of a function definition that started:</p>
<el-code-block source="functionChars.elan">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>charactersMatchAt</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id> <el-kw>as</el-kw> <el-type>String</el-type>, <el-id>b</el-id> <el-kw>as</el-kw> <el-type>String</el-type>, <el-id>position</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>Boolean</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
</el-code-block>

<h1 id="Constants">Constants</h1>

<h2 id="StringConstants">String constants</h2>
<table class="tableType">
 <tr>
  <th>name</th><th>Type</th><th >value</th>
 </tr><tr id="openBrace">
  <td><el-code><el-id>openBrace</el-id></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code>&nbsp; { </el-code></td>
 </tr><tr id="closeBrace">
  <td><el-code><el-id>closeBrace</el-id></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code>&nbsp; } </el-code></td>
 </tr><tr id="quotes">
  <td><el-code><el-id>quotes</el-id></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code>&nbsp; &quot; </el-code></td>
 </tr>
</table>

<h2 id="BooleanConstants">Boolean constants</h2>
<table class="tableType">
 <tr>
  <th>name</th><th>Type</th><th >value</th>
 </tr><tr id="true">
  <td><el-code><el-id>true</el-id></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><a href="#Boolean"><el-code><el-id>true</el-id></el-code></a></td>
 </tr><tr id="false">
  <td><el-code><el-id>false</el-id></el-code></td>
  <td><el-code><el-type>Boolean</el-type></el-code></td>
  <td><a href="#Boolean"><el-code><el-kw>false</el-kw></el-code></a></td>
 </tr>
</table>

<h2 id="MathsConstant">Maths constant</h2>
<table class="tableType">
 <tr><th>name</th><th>Type</th><th>value</th></tr>
<tr id="pi">
  <td><el-code><el-id>pi</el-id></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>&#x1d70b = 3.141592653589793..</td>
 </tr>
</table>

<h2 id="Colours">Colours</h2>
<table class="tableColours">
<tr><th>colour</th><th></th><th>decimal</th><th>decimal<br></th><th>hexadecimal</th></tr>
<tr><th>name</th><th></th><th>integer</th><th style="font-family:monospace;">&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;&nbsp;&nbsp;&nbsp;B</th><th style="font-family:monospace;">&nbsp;0xrrggbb</th></tr>
    <tr><td><el-code><el-id>black</el-id></el-code></td><td style="color:#000000">&#x25fc;</td><td>0</td><td>&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp0&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0x000000</el-code></td></tr>
    <tr><td><el-code><el-id>white</el-id></el-code></td><td style="color:#ffffff">&#x25fc;</td><td>16777215</td><td>&nbsp;255&nbsp;&nbsp;255&nbsp;&nbsp;255</td><td><el-code>0xffffff</el-code></td></tr>
    <tr><td><el-code><el-id>red</el-id></el-code></td><td style="color:#ff0000">&#x25fc;</td><td>16711680</td><td>&nbsp;255&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0xff0000</el-code></td></tr>
    <tr><td><el-code><el-id>green</el-id></el-code></td><td style="color:#008000">&#x25fc;</td><td>32768</td><td>&nbsp;&nbsp;0&nbsp;&nbsp;128&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0x008000</el-code></td></tr>
    <tr><td><el-code><el-id>blue</el-id></el-code></td><td style="color:#0000ff">&#x25fc;</td><td>255</td><td>&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;255</td><td><el-code>0x0000ff</el-code></td></tr>
    <tr><td><el-code><el-id>yellow</el-id></el-code></td><td style="color:#ffff00">&#x25fc;</td><td>16776960</td><td>&nbsp;255&nbsp;&nbsp;255&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0xffff00</el-code></td></tr>
    <tr><td><el-code><el-id>brown</el-id></el-code></td><td style="color:#a52a2a">&#x25fc;</td><td>10824234</td><td>&nbsp;165&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;42</td><td><el-code>0xa52a2a</el-code></td></tr>
    <tr><td><el-code><el-id>grey</el-id></el-code></td><td style="color:#808080">&#x25fc;</td><td>8421504</td><td>&nbsp;128&nbsp;&nbsp;128&nbsp;&nbsp;128</td><td><el-code>0x808080</el-code></td></tr>
    <tr><td><el-code><el-id>transparent</el-id></el-code></td><td style="color:#000000">&#x25fb;</td><td>-1</td><td>n/a</td><td>n/a</td></tr>
</table>
<p>A colour is specified as an <el-code><el-type>Int</el-type></el-code> value using one of these methods:</p>
<ul>
 <li>the limited colours defined as library constants as in the above table.</li>
 <li>an integer in the decimal range 0 (black) to 2<sup>24-1</sup> (white).</li>
 <li>a six digit hexadecimal value in the range <el-code>0x000000</el-code> &ndash; <el-code>0xffffff</el-code>
    using the same 'RGB' format as used in Html style, for example <el-code>0xff0000</el-code> for red.</li>
</ul>

<h1 id="StandaloneFunctions">Standalone functions</h1>
    <p>Standalone library functions always return a value and are therefore used in contexts that expect a value, such as in the right-hand side of a <el-code><el-kw>variable</el-kw></el-code> declaration or a <el-code><el-kw>set</el-kw></el-code> assignment, either on their own or within a more complex expression. All standalone library functions require at least one argument to be passed in brackets, corresponding to the parameters defined for that function.</p>

<h2 id="unicode">unicode</h2>
<p>Function <el-code><el-method>unicode</el-method></el-code> converts a Unicode (codepoint) value expressed as an integer value in decimal or hexadecimal notation, or as any expression evaluating to an <el-code><el-type>Int</el-type></el-code>, into a string of a single character. For example:</p>
<el-code-block source="unicode_hearts.elan">
<el-func class="ok multiline" id="func3">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>hearts</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-method>unicode</el-method>(<el-lit>0x2665</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h2 id="parseAs">parseAsInt and parseAsFloat</h2>
    <p>Function <el-code><el-method>parseAsInt</el-method></el-code> attempts to parse the input <el-code><el-type>String</el-type></el-code> as an <el-code><el-type>Int</el-type></el-code>, and returns a 2-tuple, the first value of which is Boolean, with <el-code><el-id>true</el-id></el-code> indicating whether or not the parse has succeeded, and the second value being the resulting <el-code><el-type>Int</el-type></el-code>.
        <el-code><el-method>parseAsFloat</el-method></el-code> does the equivalent for floating point. Operation is illustrated with by these tests: </p>
<el-code-block source="test_parse.elan">
<el-test class="ok multiline" id="test88" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment90" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="assert91" tabindex="0"><el-kw>assert </el-kw><el-field id="text92" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>31</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr93" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>31</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert94" tabindex="0"><el-kw>assert </el-kw><el-field id="text95" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>0</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr96" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert97" tabindex="0"><el-kw>assert </el-kw><el-field id="text98" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>thirty one</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr99" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>false</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert100" tabindex="0"><el-kw>assert </el-kw><el-field id="text101" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>3.1</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr102" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>false</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert103" tabindex="0"><el-kw>assert </el-kw><el-field id="text104" class="ok" tabindex="0"><el-txt><el-method>parseAsFloat</el-method>("<el-lit>31</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr105" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>31</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert106" tabindex="0"><el-kw>assert </el-kw><el-field id="text107" class="ok" tabindex="0"><el-txt><el-method>parseAsFloat</el-method>("<el-lit>0</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr108" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert109" tabindex="0"><el-kw>assert </el-kw><el-field id="text110" class="ok" tabindex="0"><el-txt><el-method>parseAsFloat</el-method>("<el-lit>3.1</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr111" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit><el-lit>3</el-lit>.1</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
    <li>Any string that parses as an <el-code><el-type>Int</el-type></el-code> will also parse as a <el-code><el-type>Float</el-type></el-code>.</li>
    <li>If the parse fails, the second value will become zero, so you should always check the first value to see if the second value is a correct parse or just the default.</li>
    <li> You can &#8216;deconstruct&#8217; the tuple into two variables:
<el-code-block source="parse_string.elan">
<el-statement class="ok" id="var5" tabindex="0"><el-kw>variable </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>success</el-id>, <el-id>parsedValue</el-id></el-txt><el-place><i>name</i></el-place><el-compl></el-compl><el-msg></el-msg></el-field><el-kw> set to </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>(<el-id>myString</el-id>)</el-txt><el-place><i>expression</i></el-place><el-compl></el-compl><el-msg></el-msg></el-field><el-msg></el-msg><el-fr>2</el-fr></el-statement>
   </el-code-block></li>
    <li>One use of these parsing methods is for validating user input, but note that an easier way to do this is to use the various <a href="#Input/output">input methods</a>.</li>
</ul>
<div id="floor"></div>
<div id="ceiling"></div>
<div id="round"></div>
<div id="isNaN"></div>
<div id="isInfinite"></div>
<h2>floor, ceiling, round, isNaN, and IsInfinite</h2>
    <p> All of these functions are called as 'dot methods' on a numeric value  of Type <el-code><el-type>Float</el-type></el-code> or <el-code><el-type>Int</el-type></el-code>.
    <el-code>NaN</el-code> is short for 'Not A (Real) Number' Their use is illustrated with the following tests:</p>
<el-code-block source="test_round">
        <el-test class="ok multiline" id="test5" tabindex="0">
            <el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment7" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
            <el-statement class="ok" id="let19" tabindex="0"><el-kw>let </el-kw><el-field id="var20" class="ok" tabindex="0"><el-txt><el-id>n</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr21" class="ok" tabindex="0"><el-txt><el-lit><el-lit>3</el-lit>.14159</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
            <el-statement class="ok" id="assert26" tabindex="0"><el-kw>assert </el-kw><el-field id="text27" class="ok" tabindex="0"><el-txt><el-id>n</el-id>.<el-method>floor</el-method>()</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr28" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
            <el-statement class="ok" id="assert33" tabindex="0"><el-kw>assert </el-kw><el-field id="text34" class="ok" tabindex="0"><el-txt><el-id>n</el-id>.<el-method>ceiling</el-method>()</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-lit>4</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
            <el-statement class="ok" id="assert46" tabindex="0"><el-kw>assert </el-kw><el-field id="text47" class="ok" tabindex="0"><el-txt><el-id>n</el-id>.<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr48" class="ok" tabindex="0"><el-txt><el-lit><el-lit>3</el-lit>.142</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
            <el-statement class="ok" id="assert53" tabindex="0"><el-kw>assert </el-kw><el-field id="text54" class="ok" tabindex="0"><el-txt><el-method>sqrt</el-method>(-<el-lit>1</el-lit>).<el-method>isNaN</el-method>()</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
            <el-statement class="ok" id="let64" tabindex="0"><el-kw>let </el-kw><el-field id="var65" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr66" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit>/<el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
            <el-statement class="ok" id="assert60" tabindex="0"><el-kw>assert </el-kw><el-field id="text61" class="ok" tabindex="0"><el-txt><el-id>x</el-id>.<el-method>isInfinite</el-method>()</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr62" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
            <el-kw>end test</el-kw>
            </el-test>
    </el-code-block>

<h2 class="no-TOC" id="MathsFunctions">Maths functions</h2>
All the maths functions take a <el-code><el-type>Float</el-type></el-code> argument and return a <el-code><el-type>Float</el-type></el-code> value.
<table>
<tr><th>function</th><th>argument<br>Type</th><th>input<br>unit</th><th>returns</th><th>output<br>unit</th></tr>
<tr id="abs"><td><el-code><el-method>abs</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>absolute value of the input</td><td></td></tr>
<tr id="acos"><td><el-code><el-method>acos</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>arccosine of the input</td><td>radians</td></tr>
<tr id="asin"><td><el-code><el-method>asin</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>arcsine of the input</td><td>radians</td></tr>
<tr id="atan"><td><el-code><el-method>atan</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>arctangent of the input</td><td>radians</td></tr>
<tr id="acosDeg"><td><el-code><el-method>acosDeg</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>arccosine of the input</td><td>degrees</td></tr>
<tr id="asinDeg"><td><el-code><el-method>asinDeg</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>arcsine of the input</td><td>degrees</td></tr>
<tr id="atanDeg"><td><el-code><el-method>atanDeg</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>arctangent of the input</td><td>degrees</td></tr>
<tr id="cos"><td><el-code><el-method>cos</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>radians</td><td>cosine of the input</td><td></td></tr>
<tr id="cosDeg"><td><el-code><el-method>cosDeg</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>degrees</td><td>cosine of the input</td><td></td></tr>
<tr>
  <td id="exp"><el-code><el-id><el-method>exp</el-method></el-id></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td></td>
  <td>&#x1d452<sup>&#x1d465</sup> where &#x1d465 is the argument and<br>&#x1d452 is Euler's number 2.718281828459045..<br>the base of natural logarithms</td>
  <td></td>
</tr>

<tr id="logE"><td><el-code><el-method>logE</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>natural logarithm of the input</td><td></td></tr>
<tr id="log10"><td><el-code><el-method>log10</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>base-10 logarithm of the input</td><td></td></tr>
<tr id="log2"><td><el-code><el-method>log2</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>base-2 logarithm of the input</td><td></td></tr>
<tr id="sin"><td><el-code><el-method>sin</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>radians</td><td>sine of the input</td><td></td></tr>
<tr id="sinDeg"><td><el-code><el-method>sinDeg</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>degrees</td><td>sine of the input</td><td></td></tr>
<tr id="sqrt"><td><el-code><el-method>sqrt</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td></td><td>positive square root of the input</td><td></td></tr>
<tr id="tan"><td><el-code><el-method>tan</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>radians</td><td>tangent of the input</td><td></td></tr>
<tr id="tanDeg"><td><el-code><el-method>tanDeg</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>degrees</td><td>tangent of the input</td><td></td></tr>
<tr id="degToRad"><td><el-code><el-method>degToRad</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>degrees</td><td>converts input from degrees to radians</td><td>radians</td></tr>
<tr id="radToDeg"><td><el-code><el-method>radToDeg</el-method></el-code></td><td><el-code><el-type>Float</el-type></el-code></td><td>radians</td><td>converts input from radians to degrees</td><td>degrees</td></tr></table>

<p>Examples of some maths functions and constants being tested:</p>
<el-code-block source="test_maths.elan">
<el-test class="ok multiline" id="test1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="assert28" tabindex="0"><el-kw>assert </el-kw><el-field id="text29" class="ok" tabindex="0"><el-txt><el-id>pi</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit><el-lit>3</el-lit>.141592653589793</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert31" tabindex="0"><el-kw>assert </el-kw><el-field id="text32" class="ok" tabindex="0"><el-txt><el-method>abs</el-method>(-<el-lit><el-lit>3</el-lit>.7</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr33" class="ok" tabindex="0"><el-txt><el-lit><el-lit>3</el-lit>.7</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert37" tabindex="0"><el-kw>assert </el-kw><el-field id="text38" class="ok" tabindex="0"><el-txt><el-method>asin</el-method>(<el-lit><el-lit>0</el-lit>.5</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr39" class="ok" tabindex="0"><el-txt><el-lit><el-lit>0</el-lit>.524</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert34" tabindex="0"><el-kw>assert </el-kw><el-field id="text35" class="ok" tabindex="0"><el-txt><el-method>acos</el-method>(<el-lit><el-lit>0</el-lit>.5</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr36" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.047</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert40" tabindex="0"><el-kw>assert </el-kw><el-field id="text41" class="ok" tabindex="0"><el-txt><el-method>atan</el-method>(<el-lit>1</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr42" class="ok" tabindex="0"><el-txt><el-lit><el-lit>0</el-lit>.79</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert65" tabindex="0"><el-kw>assert </el-kw><el-field id="text66" class="ok" tabindex="0"><el-txt><el-method>sin</el-method>(<el-id>pi</el-id>/<el-lit>6</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr67" class="ok" tabindex="0"><el-txt><el-lit><el-lit>0</el-lit>.5</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert43" tabindex="0"><el-kw>assert </el-kw><el-field id="text44" class="ok" tabindex="0"><el-txt><el-method>cos</el-method>(<el-id>pi</el-id>/<el-lit>4</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr45" class="ok" tabindex="0"><el-txt><el-lit><el-lit>0</el-lit>.707</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert70" tabindex="0"><el-kw>assert </el-kw><el-field id="text71" class="ok" tabindex="0"><el-txt><el-method>tan</el-method>(<el-id>pi</el-id>/<el-lit>4</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr72" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert46" tabindex="0"><el-kw>assert </el-kw><el-field id="text47" class="ok" tabindex="0"><el-txt><el-method>exp</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr48" class="ok" tabindex="0"><el-txt><el-lit><el-lit>7</el-lit>.389</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert49" tabindex="0"><el-kw>assert </el-kw><el-field id="text50" class="ok" tabindex="0"><el-txt><el-method>logE</el-method>(<el-lit><el-lit>7</el-lit>.389</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr51" class="ok" tabindex="0"><el-txt><el-lit>2</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert52" tabindex="0"><el-kw>assert </el-kw><el-field id="text53" class="ok" tabindex="0"><el-txt><el-method>log10</el-method>(<el-lit>1000</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr54" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert55" tabindex="0"><el-kw>assert </el-kw><el-field id="text56" class="ok" tabindex="0"><el-txt><el-method>log2</el-method>(<el-lit>65536</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr57" class="ok" tabindex="0"><el-txt><el-lit>16</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert58" tabindex="0"><el-kw>assert </el-kw><el-field id="text59" class="ok" tabindex="0"><el-txt><el-method>log2</el-method>(<el-lit>0x10000</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr60" class="ok" tabindex="0"><el-txt><el-lit>16</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert61" tabindex="0"><el-kw>assert </el-kw><el-field id="text62" class="ok" tabindex="0"><el-txt><el-method>sqrt</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr63" class="ok" tabindex="0"><el-txt><el-lit><el-lit>1</el-lit>.414</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h2 id="RegExp">Regular expressions</h2>
    <p>Elan's regular expressions are modelled on those of JavaScript, including the syntax for literal regular expressions. See, for example this <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">Guide to Regular Expressions</a>.</p>
    <p>More functions for using regular expressions will be added in a future release of Elan. For now&#8230;</p>
    <p>The method <el-code>matchesRegExp</el-code> is applied to a <el-code><el-type>String</el-type></el-code> using dot syntax and requires a <el-code>RegExp</el-code> parameter specified as a literal or as variable. It returns a Boolean. For example:</p>
<el-code-block source="test_regexp_1.elan">
<el-test class="ok multiline" id="test1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>s1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>"<el-lit>hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let80" tabindex="0"><el-kw>let </el-kw><el-field id="var81" class="ok" tabindex="0"><el-txt><el-id>s2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt>"<el-lit>World</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let83" tabindex="0"><el-kw>let </el-kw><el-field id="var84" class="ok" tabindex="0"><el-txt><el-id>r</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt>/<el-regex>^[a-z]*$</el-regex>/</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-id>s1</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-id>s2</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<p>You can convert a valid <el-code>string</el-code> without <el-code>/../</el-code> delimiters to a <el-code>RegExp</el-code> using function <el-code>asRegExp</el-code>:</p>
<el-code-block source="test_regexp_2.elan">
<el-test class="ok multiline" id="test1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>s1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>"<el-lit>hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let80" tabindex="0"><el-kw>let </el-kw><el-field id="var81" class="ok" tabindex="0"><el-txt><el-id>s2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt>"<el-lit>World</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let83" tabindex="0"><el-kw>let </el-kw><el-field id="var84" class="ok" tabindex="0"><el-txt><el-id>r</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt>"<el-lit>^[a-z]*$</el-lit>".<el-method>asRegExp</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-id>s1</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-id>s2</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
    <p>Although it is recommended that literal regular expressions are written with <el-code>/../</el-code> delimiters, the ability to convert a <el-code>string</el-code> allows you to input a regular expression into a running program.</p>

<h2 id="BitwiseFunctions">Bitwise functions</h2>
    <p>These functions take in an integer value, and manipulate the bit representation of that value.</p>

<table class="tableMethod">
 <tr>
  <th>function</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asBinary">
  <td id="bitAnd"><el-code><el-method>bitAnd</el-method></el-code></td>
  <td><el-code><el-type>Int, Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>integer whose binary representation is the bitwise AND of the inputs</td>
 </tr><tr id="bitOr">
  <td><el-code><el-method>bitOr</el-method></el-code></td>
  <td><el-code><el-type>Int, Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>integer whose binary representation is the bitwise OR of the inputs</td>
 </tr><tr id="bitNot">
  <td><el-code><el-method>bitNot</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>integer whose binary representation is the bitwise complement of the input</td>
 </tr><tr id="bitXor">
  <td><el-code><el-method>bitXor</el-method></el-code></td>
  <td><el-code><el-type>Int, Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>integer whose binary representation is the bitwise XOR of the inputs</td>
 </tr><tr id="bitShiftL">
  <td><el-code><el-method>bitShiftL</el-method></el-code></td>
  <td><el-code><el-type>Int, Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>integer bit shifted to the left by the value of the second argument,<br>i.e. multiplied by 2 to the power of the second argument</td>
 </tr><tr id="bitShiftR">
  <td><el-code><el-method>bitShiftR</el-method></el-code></td>
  <td><el-code><el-type>Int, Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>integer bit shifted to the right by the value of the second argument,<br>i.e.  divided by 2 to the power of the second argument</td>
 </tr>
</table>
<p>Examples of the bitwise functions being tested:</p>
<el-code-block source="test_bitwise.elan">
<el-test class="ok multiline" id="test3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment5" class="optional ok" tabindex="0"><el-txt>bitwise</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="var12" tabindex="0"><el-kw>variable </el-kw><el-field id="var13" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-lit>13</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert15" tabindex="0"><el-kw>assert </el-kw><el-field id="text16" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-lit>0xd</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert18" tabindex="0"><el-kw>assert </el-kw><el-field id="text19" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-lit>0b1101</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert21" tabindex="0"><el-kw>assert </el-kw><el-field id="text22" class="ok" tabindex="0"><el-txt><el-id>a</el-id>.<el-method>asBinary</el-method>()</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt>"<el-lit>1101</el-lit>"</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var24" tabindex="0"><el-kw>variable </el-kw><el-field id="var25" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-lit>30</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert27" tabindex="0"><el-kw>assert </el-kw><el-field id="text28" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr29" class="ok" tabindex="0"><el-txt><el-lit>0b11110</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert30" tabindex="0"><el-kw>assert </el-kw><el-field id="text31" class="ok" tabindex="0"><el-txt><el-method>bitAnd</el-method>(<el-id>a</el-id>, <el-id>b</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>0b1100</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var36" tabindex="0"><el-kw>variable </el-kw><el-field id="var37" class="ok" tabindex="0"><el-txt><el-id>aob</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-method>bitOr</el-method>(<el-id>a</el-id>, <el-id>b</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert33" tabindex="0"><el-kw>assert </el-kw><el-field id="text34" class="ok" tabindex="0"><el-txt><el-id>aob</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-lit>0b11111</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var41" tabindex="0"><el-kw>variable </el-kw><el-field id="var42" class="ok" tabindex="0"><el-txt><el-id>axb</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr43" class="ok" tabindex="0"><el-txt><el-method>bitXor</el-method>(<el-id>a</el-id>, <el-id>b</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert44" tabindex="0"><el-kw>assert </el-kw><el-field id="text45" class="ok" tabindex="0"><el-txt><el-id>axb</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-lit>0b10011</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var47" tabindex="0"><el-kw>variable </el-kw><el-field id="var48" class="ok" tabindex="0"><el-txt><el-id>nota</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-method>bitNot</el-method>(<el-id>a</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert50" tabindex="0"><el-kw>assert </el-kw><el-field id="text51" class="ok" tabindex="0"><el-txt><el-id>nota</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr52" class="ok" tabindex="0"><el-txt>-<el-lit>14</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var53" tabindex="0"><el-kw>variable </el-kw><el-field id="var54" class="ok" tabindex="0"><el-txt><el-id>aL</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-method>bitShiftL</el-method>(<el-id>a</el-id>, <el-lit>2</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert56" tabindex="0"><el-kw>assert </el-kw><el-field id="text57" class="ok" tabindex="0"><el-txt><el-id>aL</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr58" class="ok" tabindex="0"><el-txt><el-lit>0b110100</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert59" tabindex="0"><el-kw>assert </el-kw><el-field id="text60" class="ok" tabindex="0"><el-txt><el-method>bitShiftR</el-method>(<el-id>a</el-id>, <el-lit>2</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr61" class="ok" tabindex="0"><el-txt><el-lit>0b11</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<p>The result of <el-code><el-method>bitNot</el-method>(<el-id>a</el-id>)</el-code> being <el-code>-14</el-code> , when <el-code><el-id>a</el-id></el-code> is <el-code>13</el-code>, might be a surprise. But this is because the bitwise functions assume that the arguments are represented as 32-bit signed binary integers. So 13 is represented as <el-code>00000000000000000000000000001101</el-code>, and applying <el-code><el-method>bitAnd</el-method></el-code> gives <el-code>11111111111111111111111111110010 </el-code>which is the value <el-code>-14 </el-code>in signed two&#8217;s complement format, the left-most bit being the sign (<el-code>0</el-code> positive, <el-code>1</el-code> negative).</p>

<h2 id="sequence">Sequence</h2>
<p>The <el-code><el-method>sequence</el-method></el-code> is used to create a <el-code><el-type>List</el-type></el-code> containing a sequence
of integer values as defined by the two (integer) parameters: <el-code><el-id>start</el-id></el-code> and <el-code><el-id>end</el-id></el-code>
(both being <i>inclusive</i> values), for example:</p>

<h1 id="StandaloneProcedures">Standalone procedures</h1>

<h2 >Standalone procedures</h2>
<p>All <el-code>procedure</el-code>s are accessed via a <a href="LangRef.html#call"><el-code>call</el-code></a> statement.</p>
<table class="tableMethod">
 <tr><th>procedure</th><th>input<br>argument<br>Types</th><th>output<br>argument<br>Types</th><th>action</th>
 </tr><tr id="pause">
  <td><el-code><el-method>pause</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>(none)</td>
  <td>pauses the execution of a program for the specified number of milliseconds,<br> e.g. for a game <el-code>pause(100)</el-code> delays execution for one tenth of a second</td>
 </tr><tr id="clearPrintedText">
  <td><el-code><el-method>clearPrintedText</el-method></el-code></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears the IDE's Display panel</td>
 </tr><tr id="clearKeyBuffer">
  <td><el-code><el-method>clearKeyBuffer</el-method></el-code></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears the IDE's keyboard input</td>
 </tr><tr id="printLine">
  <td><el-code><el-method>printLine</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td>prints the string to the Display followed by a newline.<br>
  This method offers the means to do all printing via methods<br>
  rather than coding a mixture of <el-code>call</el-code> and <el-code>print</el-code> statements</td>
 </tr><tr id="printNoLine">
  <td><el-code><el-method>printNoLine</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>(none)</td>
  <td>prints the string to the Display without appending a newline so<br>
  a following call will output on the same line.<br>
  You can put your own "\n" newlines in the argument string</td>
 </tr><tr id="printTab">
  <td><el-code><el-method>printTab</el-method></el-code></td>
  <td><el-code><el-type>Int, String</el-type></el-code></td>
  <td>(none)</td>
  <td>prints the string to the Display starting at the tab position given (from 0)</td>
 </tr>
</table>
<p>Method <el-code><el-method>printTab</el-method></el-code> helps in the layout of information printed to the Display, in particular, when printing columns of data.
 For example:</p>
<el-code-block source="printTab.elan">
<el-statement class="ok" id="call5" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args7" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit>, "<el-lit>Number</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call11" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident12" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args13" class="optional ok" tabindex="0"><el-txt><el-lit>10</el-lit>, "<el-lit>Square</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-lit>20</el-lit>, "<el-lit>Cube\n</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok multiline" id="for27" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-lit>10</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="call36" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident37" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args38" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit>, <el-id>i</el-id>.<el-method>asString</el-method>()</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call47" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args49" class="optional ok" tabindex="0"><el-txt><el-lit>10</el-lit>, "<el-lit></el-lit>{<el-id>i</el-id>^<el-lit>2</el-lit>}<el-lit></el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call60" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident61" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args62" class="optional ok" tabindex="0"><el-txt><el-lit>20</el-lit>, "<el-lit></el-lit>{<el-id>i</el-id>^<el-lit>3</el-lit>}<el-lit>\n</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>
<p>Right-align numeric output using a lambda function:</p>
<el-code-block source="printTab_R.elan">
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>tab</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-lit>10</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var6" tabindex="0"><el-kw>variable </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok multiline" id="for9" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident11" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr12" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr13" class="ok" tabindex="0"><el-txt>(<el-id>tab</el-id> - <el-lit>1</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="var15" tabindex="0"><el-kw>variable </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>j</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-lit>9</el-lit>^<el-id>i</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var55" tabindex="0"><el-kw>variable </el-kw><el-field id="var56" class="ok" tabindex="0"><el-txt><el-id>f</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr57" class="ok" tabindex="0"><el-txt><el-kw>lambda</el-kw> <el-id>j</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>j</el-id>.<el-method>asString</el-method>().<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-id>tab</el-id> - <el-method>f</el-method>(<el-id>j</el-id>), "<el-lit></el-lit>{<el-id>j</el-id>}<el-lit>\n</el-lit>"</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<h1 id="SystemMethods">System methods</h1>

<h2>System methods</h2>
<p>System methods appear to work like <el-code>functions</el-code>, because:</p>
<ul>
 <li>they may require one or more arguments to be provided.</li>
 <li>they always return a value.</li>
 <li>they are used in expressions.</li>
</ul>
<p>They are not, however, pure functions because:</p>
<ul>
 <li>They may have a dependency on data that is not provided as an argument.</li>
 <li>They may generate side effects, such as changing the screen display or writing to a file.</li>
</ul>
<p>Because of these properties, system methods may be used only within the <el-code>main</el-code> routine or within a <el-code>procedure</el-code>.
 They may not be used inside a <el-code>function</el-code> that you have defined, because to do so would mean that your <el-code>function</el-code> would not be pure.</p>
<p>System methods are all defined within the Elan standard library: you cannot write a system method yourself.</p>
<p>System methods are commonly associated with <a href="#Input/output">Input/output</a>, but note that:</p>
<ul>
 <li>Input/output may be performed in  procedures as well as in <el-code>main</el-code>.</li>
 <li>Some system methods are not concerned with input/output, e.g. some generate random numbers.</li>
</ul>
<p>The reason those are system methods is that they have a dependency on variable data that is not passed into them as arguments.</p>
<table>
 <tr>
  <th>system<br>method</th>
  <th>argument<br>Types</th>
  <th>return<br>Types</th>
  <th>action</th>
 </tr><tr id="clock">
  <td><el-code><el-method>clock</el-method></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>returns the current value (in  milliseconds) of a system clock.<br>Useful for measuring elapsed time by comparing the values returned by two calls</td>
 </tr><tr id="getKey">
  <td><el-code><el-method>getKey</el-method></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>returns the character of the keyboard key pressed</td>
 </tr><tr id="getKeyWithModifier">
  <td><el-code><el-method>getKeyWithModifier</el-method></el-code></td>
  <td>(none)</td>
  <td>2-tuple:<br>(<el-code><el-type>String</el-type></el-code>, <el-code><el-type>String</el-type></el-code>)</td>
  <td>returns both the character of the keyboard key pressed<br>and the modifier key's name if also pressed</td>
 </tr><tr id="inputString">
  <td><el-code><el-method>inputString</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>prints the string as a prompt, and returns the typed input when Enter is pressed</td>
 </tr><tr id="inputStringWithLimits">
  <td><el-code><el-method>inputStringWithLimits</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code>, <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Int</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>prints the string as a prompt and returns the typed input when Enter is pressed<br>
  provided the length of the response is within the minimum and maximum limits specified.<br>
  If it is not, the prompt is repeated with the relevant limit displayed</td>
 </tr><tr id="inputStringFromOptions">
  <td><el-code><el-method>inputStringFromOptions</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code>, <el-code><el-type>List&lt;of String&gt;</el-type></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td>prints the string as a prompt and returns the typed input when Enter is pressed<br>
  provided it is one of the options in the list.<br>
  If it is not, the prompt is repeated with the options displayed</td>
 </tr><tr id="inputInt">
  <td><el-code><el-method>inputInt</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is an integer.<br> If it is not, the prompt is repeated with an error message</td>
 </tr><tr id="inputIntBetween">
  <td><el-code><el-method>inputIntBetween</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code>, <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is an integer with a value in the (inclusive) range.<br> The first range value must be less than or equal to the second</td>
 </tr><tr id="inputFloat">
  <td><el-code><el-method>inputFloat</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is a number.<br> If it is not, the prompt is repeated with an error message</td>
 </tr><tr id="inputFloatBetween">
  <td><el-code><el-method>inputFloatBetween</el-method></el-code></td>
  <td><el-code><el-type>String</el-type></el-code>, <el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Int</el-type></el-code></td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is a number with a value in the (inclusive) range.<br> The first range value must be less than or equal to the second</td>
 </tr><tr id="openFileForReading">
  <td><el-code><el-method>openFileForReading</el-method></el-code></td>
  <td>(none)</td>
  <td><el-class>TextFileReader</el-class></td>
  <td>see <a href="#Input/output">Input/output</a></td>
 </tr><tr id="random">
  <td><el-code><el-method>random</el-method></el-code></td>
  <td>(none)</td>
  <td><el-code><el-type>Float</el-type></el-code></td>
  <td>returns a random number in the range [0..1]</td>
 </tr><tr id="randomInt">
  <td><el-code><el-method>randomInt</el-method></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code>, <el-code><el-type>Int</el-type></el-code></td>
  <td><el-code><el-type>Int</el-type></el-code></td>
  <td>returns a random number in the (inclusive) range between the two arguments</td>
 </tr><tr id="waitForAnyKey">
  <td><el-code><el-method>waitForAnyKey</el-method></el-code></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
</table>

<h1>Library functions that process Lists</h1>

<h2 id="HoFs">Higher order functions (HoFs)</h2>
<p>These dot methods are called on any <el-code>List,</el-code> <el-code>ListImmutable</el-code> or <el-code><el-type>String</el-type></el-code>. As &#8216;higher order functions&#8217; they take either a <el-code><el-kw>lambda</el-kw></el-code> or a function reference as one of their arguments: see <span class="Link">Passing a function as a reference</span>.</p>
<p>Although several of these methods return a <el-code><el-type>ListImmutable</el-type></el-code>, they may be converted to a List using method <el-code><el-method>asList</el-method></el-code>.</p>
<p>These are not yet fully documented but, for readers familiar with HoFs from another programming language, some examples are shown below.</p>

<h3 class="no-TOC" id="filter">filter </h3>
<p>Example function from demo program <el-code>pathfinder.elan</el-code> in which <el-code><el-method>filter</el-method></el-code> applies the <el-code>lambda</el-code> to the <el-id>nodes</el-id> (of class Node) to find one that contains <el-id>p</el-id> (of record Point):</p>
<el-code-block>
<el-func class="ok multiline" id="func333" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident335" class="ok" tabindex="0"><el-txt>getNodeFor</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params336" class="optional ok" tabindex="0"><el-txt><el-id>p</el-id> <el-kw>as</el-kw> <el-type>Point</el-type></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type337" class="ok" tabindex="0"><el-txt><el-type>Node</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="let340" tabindex="0"><el-kw>let </el-kw><el-field id="var341" class="ok" tabindex="0"><el-txt><el-id>matches</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr342" class="ok" tabindex="0"><el-txt><el-kw>property</el-kw>.<el-id>nodes</el-id>.<el-method>filter</el-method>(<el-kw>lambda</el-kw> <el-id>n</el-id> <el-kw>as</el-kw> <el-type>Node</el-type> =&gt; <el-id>n</el-id>.<el-id>point</el-id><el-kw> is </el-kw><el-id>p</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="return338" tabindex="0"><el-kw>return </el-kw><el-field id="expr339" class="ok" tabindex="0"><el-txt><el-kw>if </el-kw><el-id>matches</el-id>.<el-method>length</el-method>()<el-kw> is </el-kw><el-lit>1</el-lit><el-kw> then </el-kw><el-id>matches</el-id>.<el-method>head</el-method>()<el-kw><br>else </el-kw><el-kw>empty</el-kw> <el-type>Node</el-type></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h3 class="no-TOC" id="map">map</h3>
    <p>Usage:</p>
    <el-code>let next be cellRange.map(lambda n as Int =&gt; nextCellValue(cells, n))</el-code>

<h3 class="no-TOC" id="reduce">reduce</h3>
    <p>Usage:</p>
    <el-code>
    let d2 be possibleAnswers.reduce(d, <br>
    &nbsp;&nbsp;lambda dd as Dictionary&lt;of String, Int&gt;, possAnswer as String =&gt;<br>
    &nbsp;&nbsp;incrementCount(dd, possAnswer, attempt))
    </el-code>

<h3 class="no-TOC" id="maxBy">maxBy and minBy</h3><span id="minBy"></span>
    <p><el-code>maxBy</el-code> and <el-code>minBy</el-code> are dot functions of <el-code>List</el-code> and <el-code>ListImmutable</el-code>.  They take a function as an argument, and return the list element corresponding to  maximum or minimum of the values returned by the function.  This prints "89" and "orange":</p>
    <p><el-code>variable a set to {33, 4, 0, 92, 89, 55}</el-code><br>
    <el-code>print a.maxBy(lambda x as Int =&gt; x mod 10)</el-code><br>
    <el-code>variable fruit set to {"apple", "orange", "pear"}</el-code><br>
    <el-code>print fruit.maxBy(lambda x as String =&gt; x.length())</el-code></p>

    <p>For simply finding the maximum or minimum value in a List, you can use
<el-code><el-method>maxFloat</el-method></el-code>,
<el-code><el-method>minFloat</el-method></el-code>,
<el-code><el-method>maxInt</el-method></el-code> or
<el-code><el-method>minInt</el-method></el-code>.</p>

<h3 class="no-TOC" id="sortBy">sortBy</h3>
<p><el-code>sortBy</el-code> takes a <el-code><el-kw>lambda</el-kw></el-code> that takes two arguments (of the same Type as that of the <el-code>ListImmutable</el-code> being sorted) and compares them, returning an integer with one of the values -1, 0, or +1, to indicate whether the first argument should be placed respectively before, adjacent to or after the second argument in the sorted result, where &#8216;adjacent to&#8217; means it does not matter whether before or after):</p>

<el-code-block source="sortBy_Int.elan">
<el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>numbers</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>[<el-lit>27</el-lit>, <el-lit>2</el-lit>, <el-lit>3</el-lit>, <el-lit>5</el-lit>, <el-lit>7</el-lit>, <el-lit>31</el-lit>, <el-lit>37</el-lit>, <el-lit>11</el-lit>, <el-lit>13</el-lit>, <el-lit>17</el-lit>, <el-lit>19</el-lit>, <el-lit>23</el-lit>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let6" tabindex="0"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>sorted</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>numbers</el-id>.<el-method>sortBy</el-method>(<el-kw>lambda</el-kw> <el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-kw>if </el-kw><el-id>x</el-id> &gt; <el-id>y</el-id><el-kw> then </el-kw><el-lit>1</el-lit><el-kw><br>else </el-kw><el-kw>if </el-kw><el-id>x</el-id> &lt; <el-id>y</el-id><el-kw> then </el-kw>-<el-lit>1</el-lit><el-kw><br>else </el-kw><el-lit>0</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>sorted</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<p>And similarly for string comparisons using methods <el-code><el-method>isBefore</el-method></el-code> and <el-code><el-method>isAfter</el-method></el-code>:</p>
<el-code-block source="sortBy_String.elan">
<el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>names</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt>["<el-lit>Simon</el-lit>", "<el-lit>Pauline</el-lit>", "<el-lit>Jason</el-lit>", "<el-lit>Zelda</el-lit>", "<el-lit>Edith</el-lit>", "<el-lit>Lance</el-lit>", "<el-lit>Alice</el-lit>", "<el-lit>Paul</el-lit>"]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let6" tabindex="0"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>sorted</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>names</el-id>.<el-method>sortBy</el-method>(<el-kw>lambda</el-kw> <el-id>x</el-id> <el-kw>as</el-kw> <el-type>String</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>String</el-type> =&gt; <el-kw>if </el-kw><el-id>x</el-id>.<el-method>isAfter</el-method>(<el-id>y</el-id>)<el-kw> then </el-kw><el-lit>1</el-lit><el-kw><br>else </el-kw><el-kw>if </el-kw><el-id>x</el-id>.<el-method>isBefore</el-method>(<el-id>y</el-id>)<el-kw> then </el-kw>-<el-lit>1</el-lit><el-kw><br>else </el-kw><el-lit>0</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>sorted</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>

<hr>
<p><b>Elan Library Reference</b> go to the <a href="#top">top</a></p>
</body>
</html>
