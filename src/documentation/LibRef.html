<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html lang="en-GB">
<head>
<link rel="stylesheet" href="../ide/styles/colourScheme.css">
<link rel="stylesheet" href="../ide/styles/documentation.css">
<link rel="stylesheet" href="../ide/styles/elanStyle.css">
<link rel="icon" href="favicon.ico">
<title>Elan Library Reference</title>
<script type="text/javascript" src="generated_toc.js"></script>
</head>
<body id="top">
<div class="docTitle">Elan Library Reference</div>
<div class="docTOC">
 <div id="generated-toc" class="generate_from_h1 generate_for_page"></div>
</div>

<h1 id="ValueTypes">Value data Types</h1>

<h2 id="Int">Integer</h2>
<p>An integer is a whole number, i.e. one that has no fractional part. It may be represented in decimal, hexadecimal or binary:</p>
<p><el-code>100</el-code> (decimal), <el-code>0x64</el-code> (hexadecimal) and <el-code>0b1100100</el-code> all have the same value.</p>

<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>default value</th>
</tr><tr>
  <td></td>
  <td></td>
  <td><el-kw>empty</el-kw> <el-type>Int</el-type></td>
</tr><tr>
  <td><el-type>Int</el-type></td>
  <td><el-code><el-statement class="ok" id="let28" tabindex="-1"><el-kw>constant </el-kw><el-field id="var29" class="ok" tabindex="-1"><el-txt><el-id>maxNumber</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr30" class="ok" tabindex="-1"><el-txt><el-lit>10</el-lit></el-txt></el-field></el-statement></el-code></td>
  <td><el-code>0</el-code></td>
</tr><tr>
  <td><el-type>Int</el-type></td>
  <td><el-code><el-statement class="ok" id="var16" tabindex="-1"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="-1"><el-txt><el-id>flags</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="-1"><el-txt><el-lit>0b1100100</el-lit></el-txt></el-field></el-statement></el-code></td>
  <td><el-code>0</el-code></td>
</tr>
</table>

<h3 class="no-TOC">Dot methods on an <el-type>Int</el-type></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asBinary">
  <td><el-method>asBinary</el-method></td>
  <td><el-type>Int</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>string of binary digits representing the argument's integer value</td>
 </tr><tr id="asString_Int">
  <td><el-method>asString</el-method></td>
  <td><el-type>Int</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a string of decimal digits representing the argument's integer value</td>
 </tr>
</table>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>A literal integer or a named value of Type <el-type>Int</el-type> may
always be passed into a function or procedure that is expecting a <el-type>Float</el-type>.</li>
 <li>The <el-type>Int</el-type> type is <i>intended</i> to represent whole numbers
in the range:</li>
   <ul>
    <li>Maximum: 2<sup>53</sup> &ndash; 1 (which is 9007199254740991)</li>
    <li>Minimum value: &ndash; (2<sup>53</sup> &ndash; 1)</li>
    </ul>
 <li>If you go greater than the limit given above, the number will be accurate to approximately 17 decimal digits.
    Larger numbers will be rounded with zeros at the end, unless they are larger than around 2<sup>70</sup>, when they will automatically be shown
    in exponential (scientific) format, as shown in the example.</li>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example of large numbers</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; This code calculates 2 raised to the power of 50 through 72, and its output is shown below:</p>
<el-code-block source="bigInt2.elan">
<el-statement class="ok multiline" id="for6" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident8" class="ok" tabindex="-1"><el-txt><el-id>n</el-id></el-txt></el-field><el-kw> from </el-kw><el-field id="expr9" class="ok" tabindex="-1"><el-txt><el-lit>50</el-lit></el-txt></el-field><el-kw> to </el-kw><el-field id="expr10" class="ok" tabindex="-1"><el-txt><el-lit>72</el-lit></el-txt></el-field><el-kw> step </el-kw><el-field id="expr11" class="ok" tabindex="-1"><el-txt><el-lit>1</el-lit></el-txt></el-field></el-top>
<el-statement class="ok" id="var12" tabindex="-1"><el-kw>variable </el-kw><el-field id="var13" class="ok" tabindex="-1"><el-txt><el-id>s</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr14" class="ok" tabindex="-1"><el-txt><el-kw>lambda</el-kw> <el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>n</el-id>.<el-method>asString</el-method>().<el-method>length</el-method>()</el-txt></el-field></el-statement>
<el-statement class="ok" id="var15" tabindex="-1"><el-kw>variable </el-kw><el-field id="var16" class="ok" tabindex="-1"><el-txt><el-id>np</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr17" class="ok" tabindex="-1"><el-txt><el-lit>2</el-lit>^<el-id>n</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="call18" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="-1"><el-txt><el-method>printTab</el-method></el-txt></el-field>(<el-field id="args20" class="optional ok" tabindex="-1"><el-txt>-<el-method>s</el-method>(<el-id>n</el-id>), "{<el-id>n</el-id>}"</el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call21" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="-1"><el-txt><el-method>printTab</el-method></el-txt></el-field>(<el-field id="args23" class="optional ok" tabindex="-1"><el-txt><el-lit>30</el-lit> - <el-method>s</el-method>(<el-id>np</el-id>), "{<el-id>np</el-id>}<el-lit><br></el-lit>"</el-txt></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<img src="images/bigIntegers.png" width="285" height="471">
</ul>
<hr>
</div></div>

<h2 id="Float">Floating point</h2>
<p>A floating point number is a decimal number that may have both integer and fractional parts.</p>
<p>It may be written using exponential (scientific) notation, e.g.
 <el-code>120.0</el-code> &equals; <el-code>1.20e2</el-code>, and
 <el-code>0.012</el-code> &equals; <el-code>1.20e-2</el-code>.</p>

<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>default value</th>
</tr><tr>
  <td></td>
  <td></td>
  <td><el-kw>empty</el-kw> <el-type>Float</el-type></td>
</tr><tr>
  <td><el-type>Float</el-type></td>
  <td><el-code><el-statement class="ok" id="let32" tabindex="-1"><el-kw>constant </el-kw><el-field id="var33" class="ok" tabindex="-1"><el-txt><el-id>phi</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr34" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>1</el-lit>.618033988749895</el-lit></el-txt></el-field></el-statement></el-code></td>
  <td><el-code>0.0</el-code></td>
</tr><tr>
  <td><el-type>Float</el-type></td>
  <td><el-code><el-statement class="ok" id="var22" tabindex="-1"><el-kw>variable </el-kw><el-field id="var23" class="ok" tabindex="-1"><el-txt><el-id>reading</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr24" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>1</el-lit>.1e-10</el-lit></el-txt></el-field></el-statement>
</el-code></td>
  <td><el-code>0.0</el-code></td>
</tr>
</table>

<h3 class="no-TOC">Dot methods on a <el-type>Float</el-type></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_Float">
  <td><el-method>asString</el-method></td>
  <td><el-type>Float</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a string representing the argument's floating point value</td>
 </tr><tr>
  <td><el-method>ceiling</el-method></td>
  <td><el-type>Float</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the first integer larger than or equal to the argument's floating point value</td>
 </tr><tr>
  <td><el-method>floor</el-method></td>
  <td><el-type>Float</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the first integer smaller than or equal to the argument's floating point value</td>
 </tr><tr>
  <td><el-method>round</el-method></td>
  <td><el-type>Float</el-type></td>
  <td><el-type>Int</el-type></td>
  <td><el-type>Float</el-type></td>
  <td>the value rounded to the number of decimal places specified in the argument</td>
 </tr>
</table>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>The limits on floating point numbers are:
  <ul>
   <li>Maximum value: just over 1.0 &times; 10<sup>308</sup></li>
   <li>Minimum value: approximately 5.0 &times; 10<sup>-324</sup></li>
  </ul></li>
 <li>A variable that has been defined as being of Type <el-type>Float</el-type> may not be passed as an argument into a method that requires an <el-type>Int</el-type>,
    nor as an index into a <el-type>List</el-type> or an <el-type>Array2D</el-type> even if the variable contains no fractional part.
    It may, however, be converted into an <el-type>Int</el-type> before passing, using the function <el-method>floor</el-method> or <el-method>ceiling</el-method>.</li>
 <li>If you wish to define a variable to be of Type <el-type>Float</el-type>, but initialise it with an integer value, then add <el-code>.0</el-code> on the end of the whole number, as in:<br>
 <el-code>variable hour set to 3.0</el-code></li>
 <li>Any variable or expression that evaluates to an <el-type>Int</el-type> may always be used where a <el-type>Float</el-type> is expected.</li>
</ul>

<h2 id="Boolean">Boolean</h2>
<p>A <el-type>Boolean</el-type> value is either <el-id>true</el-id> or <el-id>false</el-id>.</p>
<p>The keywords <el-id>true</el-id> and <el-id>false</el-id> must be written in lower case.</p>
<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>default value</th>
</tr><tr>
  <td></td>
  <td></td>
  <td><el-kw>empty</el-kw> <el-type>Boolean</el-type></td>
</tr><tr>
  <td><el-type>Boolean</el-type></td>
  <td><el-code><el-statement class="ok" id="var25" tabindex="-1"><el-kw>variable </el-kw><el-field id="var26" class="ok" tabindex="-1"><el-txt><el-id>done</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr27" class="ok" tabindex="-1"><el-txt><el-id>true</el-id></el-txt></el-field></el-statement></el-code></td>
  <td><el-id>false</el-id></td>
</tr>
</table>

<h3 class="no-TOC">Dot method on a <el-type>Boolean</el-type></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_Boolean">
  <td><el-method>asString</el-method></td>
  <td><el-type>Boolean</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>String "true" if <el-id>true</el-id>,<br>"false" if <el-id>false</el-id></td>
 </tr>
 </table>

<h2 id="String">String</h2>
<p>A <el-type>String</el-type> represents text,  i.e. a sequence of zero or more characters.</p>
<table class="tableType">
 <tr>
  <th>name<br>of Type</th>
  <th>examples of defining<br>a literal value</th>
  <th>details</th>
  <th>default value</th>
</tr><tr>
  <td></td>
  <td></td>
  <td></td>
  <td><el-kw>empty</el-kw> <el-type>String</el-type></td>
</tr><tr>
  <td><el-type>String</el-type></td>
  <td><el-code><el-statement class="ok" id="let28" tabindex="-1"><el-kw>let </el-kw><el-field id="var29" class="ok" tabindex="-1"><el-txt><el-id>title</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr30" class="ok" tabindex="-1"><el-txt>"<el-lit>Ulysses</el-lit>"</el-txt></el-field></el-statement></el-code></td>
  <td>delimited by double quotes<br>characters <el-code>{ }</el-code>
     define an <a href="#InterpolatedString">interpolated field</a>, so may not be included as literal characters</td>
  <td><el-code>""</el-code></td>
</tr><tr>
  <td><el-type>String</el-type></td>
  <td><el-code><el-statement class="ok" id="let31" tabindex="-1"><el-kw>let </el-kw><el-field id="var32" class="ok" tabindex="-1"><el-txt><el-id>title</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr33" class="ok" tabindex="-1"><el-txt>'<el-lit>Iliad</el-lit>'</el-txt></el-field></el-statement></el-code></td>
  <td>delimited by single quotes<br>can contain <el-lit>{</el-lit> or <el-lit>}</el-lit> as literal characters,
    but cannot include <a href="#InterpolatedString">interpolated fields</a></td>
  <td><el-code>''</el-code></td>
</tr><tr>
  <td><el-type>String</el-type></td>
  <td><el-code><el-statement class="ok" id="var34" tabindex="-1"><el-kw>variable </el-kw><el-field id="var35" class="ok" tabindex="-1"><el-txt><el-id>quote</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr36" class="ok" tabindex="-1"><el-txt>'<el-lit>"Hello", she said</el-lit>'</el-txt></el-field></el-statement></el-code></td>
  <td>&quot; may be used in a string delimited by '<br>' may be used in a string delimited by &quot;</td>
  <td></td>
</tr>
</table>

<h3 class="no-TOC" id="CharacterSets">Character sets</h3>
<ul>
  <li>When typing from the keyboard into a literal string all the basic ASCII characters (0x20 to 0x7e) and' &pound;' can be input.
   You cannot use Alt+numeric-keypad to enter accented letters or other special characters in the range 0x80 to 0xff.</li>
 <li>You can, however, copy any text from outside Elan and paste it into a string, whether ASCII, extended ASCII or UTF-8 encoded.</li>
 <li>To insert a character from the full range, you use its Unicode (codepoint) value, in decimal or hexadecimal,
  by means of function <a href="#unicode"><el-method>unicode</el-method></a>:
  <el-code>
  <el-statement class="ok" id="print14" tabindex="-1"><el-kw>print </el-kw><el-field id="expr15" class="optional ok" tabindex="-1"><el-txt>"<el-lit>Spanish syntax introduces a question with a </el-lit>{<el-method>unicode</el-method>(<el-lit>191</el-lit>)}"</el-txt></el-field></el-statement>
  &#x27f6; Spanish syntax introduces a question with a &#191;
  </el-code>
<br>
  <el-code>
  <el-statement class="ok" id="print16" tabindex="-1"><el-kw>print </el-kw><el-field id="expr17" class="optional ok" tabindex="-1"><el-txt>"<el-lit>This is an up arrow: </el-lit>{<el-method>unicode</el-method>(<el-lit>0x2191</el-lit>)}"</el-txt></el-field></el-statement>
  &#x27f6; This is an up arrow: &#x2191;
  </el-code>
  <p>These examples 'interpolate' the output of function <el-method>unicode</el-method> by using curly braces (see <a href="#InterpolatedString">Interpolated fields</a>).</p></li>
</ul>
<h4 class="no-TOC">Notes</h4>
<ul>
 <li>Strings can be built from other strings by concatenation using the plus operator, for example:</li>
  <el-code>
  <el-statement class="ok" id="print19" tabindex="-1"><el-kw>print </el-kw><el-field id="expr20" class="optional ok" tabindex="-1"><el-txt>"<el-lit>Hello </el-lit>" + '<el-lit>world</el-lit>'</el-txt></el-field></el-statement>
  &#x27f6; Hello World</el-code></li>
   <li>A newline may be inserted within a string with <el-lit>\n</el-lit>:
  <el-code>
  <el-statement class="ok" id="print21" tabindex="-1"><el-kw>print </el-kw><el-field id="expr22" class="optional ok" tabindex="-1"><el-txt>"<el-lit>Hello\nworld</el-lit>"</el-txt></el-field></el-statement></el-code>
    &#x27f6; Hello<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;world
  <p>When editing and you leave the field, the newline will be implicitly applied in your code.</p>
</li>
 <li>As in most languages, strings are <i>immutable</i>. When you apply any operation or function with the intent of modifying an existing string, the existing string is never changed. Instead, the operation or function will return a new string that is based on the original, but with the specified differences.</li>
<li id="IndexRange">There are no 'substring' methods in Elan, because you can always use an index range to get a substring, e.g. <el-code>s[3..7]</el-code> gives a string containing the fourth  to the seventh characters inclusive of <el-code> s</el-code>. Note that the upper bound of the range is <i>exclusive</i>.
 See <a href="LangRef.html#IndexedValue">Indexed values</a>.</li>
 <li>You can loop through a string picking each of its characters sequentially using the <a href="LangRef.html#each"><el-kw>each</el-kw></a> loop.
<li>The dot methods that can be applied to strings are shown in the table below.</li>
</ul>

<h3 class="no-TOC" id="InterpolatedString">Interpolated fields in strings</h3>
<p>Strings that are enclosed by &quot; (double quotes) are automatically interpolated, that is you can insert the values of variables
 or simple expressions within the string by enclosing them in curly braces:
<ul>
 <li>If <el-code>a</el-code> and <el-code>b</el-code> are named values of, say, 3 and 17:
   <el-code>
<el-statement class="ok" id="print62" tabindex="-1"><el-kw>print </el-kw><el-field id="expr63" class="optional ok" tabindex="-1"><el-txt>"{<el-id>a</el-id>}<el-lit> times </el-lit>{<el-id>b</el-id>}<el-lit> equals </el-lit>{<el-id>a</el-id>*<el-id>b</el-id>}"</el-txt></el-field></el-statement>
   &#x27f6; 3 times 17 equals 51</el-code></li>
 <li>If <el-code>velocity</el-code> and <el-code>fuel</el-code> are named values of, say, 3.0 and 50.4:
   <el-code>
<el-statement class="ok" id="set40" tabindex="-1"><el-kw>set </el-kw><el-field id="ident41" class="ok" tabindex="-1"><el-txt><el-id>message</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr42" class="ok" tabindex="-1"><el-txt>"<el-lit>LANDED SAFELY AT SPEED </el-lit>{(<el-id>velocity</el-id>*<el-lit>100</el-lit>).<el-method>floor</el-method>()}<el-lit> FUEL </el-lit>{<el-id>fuel</el-id>.<el-method>floor</el-method>()}"</el-txt></el-field></el-statement>
<el-statement class="ok" id="print50" tabindex="-1"><el-kw>print </el-kw><el-field id="expr51" class="optional ok" tabindex="-1"><el-txt><el-id>message</el-id></el-txt></el-field></el-statement>
   &#x27f6; LANDED SAFELY AT SPEED 300 FUEL 50</el-code></li>
  <li>
   <el-code>
<el-statement class="ok" id="let24" tabindex="-1"><el-kw>let </el-kw><el-field id="var25" class="ok" tabindex="-1"><el-txt><el-id>r</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr26" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>2</el-lit>.0</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="print27" tabindex="-1"><el-kw>print </el-kw><el-field id="expr28" class="optional ok" tabindex="-1"><el-txt>"<el-lit>area = </el-lit>{(<el-id>pi</el-id>*<el-id>r</el-id>*<el-id>r</el-id>).<el-method>round</el-method>(<el-lit>2</el-lit>)}"</el-txt></el-field></el-statement>
   &#x27f6; area = 12.57</el-code></li>
</ul>

<p>Strings that are enclosed by ' (single quotes) cannot include interpolated fields.</p>

<h3 class="no-TOC" id="DotMethods_String">Dot methods on a <el-type>String</el-type></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_String">
  <td><el-method>asString</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td> the string itself</td>
 </tr><tr id="asUnicode">
  <td><el-method>asUnicode</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the Unicode value of the <i>first</i> character of the string<br>
   (To convert a Unicode value into a string, use function <a href="#unicode"><el-method>unicode</el-method></a>)</td>
 </tr><tr id="asRegExp">
  <td><el-method>asRegExp</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>RegExp</el-type></td>
  <td>a new string that is a a converted to a regular expression:<br>no check is made of whether the result is a valid regular expression</td>
 </tr><tr id="contains_String">
  <td><el-method>contains</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the string contains the substring specified as the argument<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="indexOf_String">
  <td><el-method>indexOf</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>index of the first instance of the argument (substring) within the string<br>If it is not present, -1 is returned</td>
 </tr><tr id="isAfter">
  <td><el-method>isAfter</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if alphabetic comparison finds the string comes strictly 'after' the argument string<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="isAfterOrSameAs">
  <td><el-method>isAfterOrSameAs</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if alphabetic comparison finds the string comes 'after' or equals the argument string<br> &ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="isBefore">
  <td><el-method>isBefore</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if alphabetic comparison finds the string comes strictly 'before' the argument string<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="isBeforeOrSameAs">
  <td><el-method>isBeforeOrSameAs</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if alphabetic comparison finds the string comes 'before' or equals the argument string<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="length_String">
  <td><el-method>length</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the number of characters in the string</td>
 </tr><tr id="lowerCase">
  <td ><el-method>lowerCase</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a new string with the original rendered in lower case</td>
 </tr><tr id="matchesRegExp">
  <td><el-method>matchesRegExp</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>RegExp</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the string matches the regular expression<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="replace">
  <td><el-method>replace</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type>, <el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td>a new string with <i>all</i> occurrences of the first argument string replaced by the second argument string </td>
 </tr><tr id="split">
  <td><el-method>split</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td><<el-type>List</el-type>&lt;of <el-type>String</el-type>&gt;</td>
  <td>a <el-type>List</el-type> of the substrings found between occurrences of the argument string<br>
  if the argument is the empty string then the list is of all the individual characters</td>
 </tr><tr id="trim">
  <td><el-method>trim</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a new string with leading and trailing spaces removed</td>
 </tr><tr id="upperCase">
  <td><el-method>upperCase</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a new string with the original rendered in upper case</td>
 </tr>
 </table>

<h2 id="Tuple">Tuple</h2>
<p>A <el-code>Tuple</el-code> is a way of holding a small number of values of differing Types together as a single reference.
It may be considered a lightweight alternative to defining a specific class for some purposes.
Tuples are referred to as 2-Tuples, 3-Tuples, etc. according to the number of values they hold.
Common uses include:</p>
<ul>
 <li>Holding a pair of x,y coordinates (each of Type <el-type>Float</el-type>) as a single unit.</li>
 <li>Allowing a function to pass back a result comprised of both a message in a <el-type>String</el-type> and a <el-type>Boolean</el-type> indicating whether the operation was successful.</li>
 <li>Returning both an updated copy of a data structure and the value of an item from it, e.g. from method <el-method>pop</el-method> on a <a href="#Stack"><el-method> Stack</el-method></a>.</li>
</ul>
A Tuple differs from a List in that:
<ul>
 <li>A Tuple may hold items of <i>different</i> Types</li>
 <li>A Tuple is <i>immutable</i> &ndash; you may read, but not modify, the values it contains.</li>
</ul>

<h3 class="no-TOC">Defining a <el-code>Tuple</el-code></h3>
<p>A new Tuple is defined using this syntax:</p>

<elan-code>
<el-statement id="let10" tabindex="-1"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="-1"><el-txt><el-id>t1</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="-1"><el-txt><el-kw>tuple</el-kw>(<el-lit>3</el-lit>, "<el-lit>apple</el-lit>", <el-id>true</el-id>)</el-txt></el-field></el-statement>
</elan-code>

<p>Note that the items may be literal or named values. An item within a Tuple may even be another Tuple.</p>

<h3 class="no-TOC">Passing a <el-code>Tuple</el-code> to or from a function</h3>
<p>You may pass a Tuple into a function, or return one from a function. The Type of a Tuple is specified
  in round brackets, containing the comma-separated Types for each item in order, for example:</p>

<el-code>
<el-kw>function </el-kw><el-method><el-field id="ident19" class="ok" tabindex="-1"><el-txt>distanceBetween</el-txt></el-field></el-method>(<el-field id="params20" class="optional ok" tabindex="-1"><el-txt><el-id>p1</el-id> <el-kw>as</el-kw> (<el-type>Float</el-type>, <el-type>Float</el-type>), <el-id>p2</el-id> <el-kw>as</el-kw> (<el-type>Float</el-type>, <el-type>Float</el-type>)</el-txt></el-field>)<el-kw> returns </el-kw><el-field id="type21" class="ok" tabindex="-1"><el-txt><el-type>Float</el-type></el-txt></el-field>
</el-code>

<h3 class="no-TOC" id="deconstructTuple">Deconstructing a <el-code>Tuple</el-code></h3>

<p>The Tuple <el-code>point</el-code> defined by:</p>
<el-code-block source="tuples1.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>point</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><el-kw>tuple</el-kw>(<el-lit>3</el-lit>, <el-lit>4</el-lit>)</el-txt></el-field></el-statement>
</el-code-block>
<p> may be deconstructed into new or existing named values where the number of names must match the number of items in the Tuple, for example:</p>


<el-code-block source="tuples1.elan">
<el-statement class="ok" id="let6" tabindex="-1"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="-1"><el-txt><el-id>x1</el-id>, <el-id>y1</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="-1"><el-txt><el-id>point</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="var11" tabindex="-1"><el-kw>variable </el-kw><el-field id="var12" class="ok" tabindex="-1"><el-txt><el-id>x2</el-id>, <el-id>y2</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr13" class="ok" tabindex="-1"><el-txt><el-id>point</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="set23" tabindex="-1"><el-kw>set </el-kw><el-field id="ident24" class="ok" tabindex="-1"><el-txt><el-id>x2</el-id>, <el-id>y2</el-id></el-txt></el-field><el-kw> to </el-kw><el-field id="expr25" class="ok" tabindex="-1"><el-txt><el-id>point</el-id></el-txt></el-field></el-statement>
</el-code-block>

<p>The 'discard' symbol <el-code>_</el-code> (underscore) may also be used when deconstructing a Tuple when there is no need to capture some of its items:</p>

<el-code-block source="tuples1.elan">
<el-statement class="ok" id="var16" tabindex="-1"><el-kw>variable </el-kw><el-field id="var17" class="ok" tabindex="-1"><el-txt><el-id>x3</el-id>, _</el-txt></el-field><el-kw> set to </el-kw><el-field id="expr18" class="ok" tabindex="-1"><el-txt><el-id>point</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="var19" tabindex="-1"><el-kw>variable </el-kw><el-field id="var20" class="ok" tabindex="-1"><el-txt>_, <el-id>y3</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr21" class="ok" tabindex="-1"><el-txt><el-id>point</el-id></el-txt></el-field></el-statement>
</el-code-block>

<p id="itemN">Where it is not convenient to use Tuple deconstruction (or not possible, e.g. within a lambda) then individual items
may be accessed using the special properties <el-id>item0</el-id>, <el-id>item1</el-id>, <el-id>item2</el-id>,...  with <a href="LangRef.html#dotSyntax">dot syntax</a>,
for example:</p>

<el-code-block source="tuples1.elan">
<el-func class="ok multiline" id="func17" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident19" class="ok" tabindex="-1"><el-txt>distanceBetween</el-txt></el-field></el-method>(<el-field id="params20" class="optional ok" tabindex="-1"><el-txt><el-id>p1</el-id> <el-kw>as</el-kw> (<el-type>Float</el-type>, <el-type>Float</el-type>), <el-id>p2</el-id> <el-kw>as</el-kw> (<el-type>Float</el-type>, <el-type>Float</el-type>)</el-txt></el-field>)<el-kw> returns </el-kw><el-field id="type21" class="ok" tabindex="-1"><el-txt><el-type>Float</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="return22" tabindex="-1"><el-kw>return </el-kw><el-field id="expr23" class="ok" tabindex="-1"><el-txt><el-method>sqrt</el-method>((<el-id>p2</el-id>.<el-id>item0</el-id> - <el-id>p1</el-id>.<el-id>item0</el-id>)^<el-lit>2</el-lit> - (<el-id>p2</el-id>.<el-id>item1</el-id> - <el-id>p1</el-id>.<el-id>item1</el-id>)^<el-lit>2</el-lit>)</el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<p>Note that the appropriate <el-id>itemN</el-id>s will be listed in the Editor's drop-down menu options for the referenced Tuple.</p>
<h4 class="no-TOC">Notes</h4>
<ul>
<li>As in most languages, an Elan <el-code>Tuple</el-code> is immutable. Once defined, Tuples are effectively read-only. You cannot alter any of the items in a Tuple nor (unlike a <el-type>List</el-type>) can you create a new Tuple from an existing one with specified differences.</li>
<li>You cannot deconstruct a Tuple into a mixture of new and existing named values.</li>
<li>Tuples may be nested: you can define a Tuple within a Tuple.</li>
</ul>

<h1 id="StandardDataStructures">Standard data structures</h1>
<p>Elan has three mutable data structure Types <el-type>List</el-type>, <el-type>Array2D</el-type> and <el-type>Dictionary</el-type>, and
three immutable data structure Types <el-type>Set</el-type>, <el-type>Stack</el-type> and <el-type>Queue</el-type>.</p>
<p>The contents of these structures are referred to as items (or sometimes elements).</p> 
<p>The values of items in a <i>mutable</i> structure may be changed directly by calling the various <i>procedure</i> dot methods defined for each structure Type.</p>
<p>The values of items in an <i>immutable</i> structure cannot be changed directly, and so have no <i>procedure</i> dot methods defined for them:
 rather, the methods called on them create new copies of the structures containing specified changes.</p>
<p>Since procedure methods may be called only from within the <el-kw>main</el-kw> routine or a <el-kw>procedure</el-kw>,
it is also possible to make changes via <el-kw>function</el-kw> dot methods,  which return a copy of the data structure
with specified changes: that is why all such methods have names starting '<el-code>with</el-code>'.</p>
<p>Immutable data structures are intended specifically to facilitate the Functional Programming paradigm,
 but some are also useful within other programming paradigms.</p>
<p id="of">All six  contain values (and keys in the case of a <el-type>Dictionary</el-type>) of only a single Type, that Type being specified either explicitly (as in
<el-code>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;</el-code>), or implicitly if the structure is created using a literal definition.</p>
<p>This table summarises the creation and reference to these structures. Details of their methods follow.</p>

<table class="tableStructure">
 <tr>
  <th></th>
  <th>List</th>
  <th>Array2D</th>
  <th>Dictionary</th>
  <th>Set</th>
  <th>Stack</th>
  <th>Queue</th>
 </tr><tr
 ><td>Mutability</td>
  <td>Mutable</td>
  <td>Mutable</td>
  <td>Mutable</td>
  <td>Immutable</td>
  <td>Immutable</td>
  <td>Immutable</td>
 </tr><tr>
  <td>Type form</td>
  <td><el-type>List</el-type>&lt;of <el-id>Type</el-id>&gt;<br><el-id>Type</el-id> of item can be any, including <el-type>Array2D</el-type> &ndash; or <el-type>List</el-type> for 'jagged' data</td>
  <td><el-type>Array2D</el-type>&lt;of <el-id>Type</el-id>&gt;<br><el-id>Type</el-id> of item is <el-type>Int</el-type>, <el-type>Float</el-type>, <el-type>String</el-type> or <el-type>Boolean</el-type></td>
  <td><el-type>Dictionary&lt;of <el-id>keyType</el-id>, <el-id>valueType</el-id>&gt;<br>
  <el-id>keyType</el-id> is <el-type>Int</el-type>, <el-type>Float</el-type>, <el-type>String</el-type> or <el-type>Boolean</el-type>, or a <el-code>record</el-code>, and<br>
  <el-id>valueType</el-id> may be any Type</td>
  <td><el-type>Set</el-type>&lt;of <el-id>Type</el-id>&gt;<br><el-id>Type</el-id> of item must be immutable</td>
  <td><el-type>Stack</el-type>&lt;of <el-id>Type</el-id>&gt;<br><el-id>Type</el-id> of item must be immutable</td>
  <td><el-type>Queue</el-type>&lt;of <el-id>Type</el-id>&gt;<br><el-id>Type</el-id> of item must be immutable</td>
 </tr><tr>
  <td>size</td><td>Dynamic</td><td>Static</td><td>Dynamic</td><td>Dynamic</td><td>Dynamic</td><td>Dynamic</td></tr>
  <td>literal definition</td>
  <td><el-code>["a","b","c"]</el-code></td>
  <td>not available</td>
  <td><el-code>["a":3, "b":5]</el-code></td>
  <td>Only as converted from a literal <el-type>List</el-type> e.g.:<br><el-code>["a","b","c"].<el-method>asSet</el-method>()</el-code></td>
  <td>Not available</td>
  <td>Not available</td>
 </tr><tr>
  <td>create empty</td>
  <td><el-code>empty</el-code> <el-type>List&lt;of <el-id>Type</el-id>&gt;</el-type> or<br>
  <el-code>new <el-type>List</el-type>&lt;of <el-id>Type&gt;</el-id>()</el-code></td>
  <td><el-code>empty</el-code> <el-type>Array2D&lt;of <el-id>Type</el-id>&gt;</el-type></td>
  <td><el-code>empty</el-code> <el-type>Dictionary&lt;of <el-id>keyType</el-id>&gt;, <el-id>valueType</el-id>&gt;</el-type> or<br>
  <el-code>new <el-type>Dictionary</el-type>&lt;of <el-id>keyType</el-id>, <el-id>valueType&gt;</el-id>()</el-code></td>
  <td><el-code>empty</el-code> <el-type>Set</el-type>&lt;of <el-id>Type</el-id>&gt; or<br>
  <el-code>new <el-type>Set</el-type>&lt;of <el-id>Type</el-id>&gt;()</el-code></td>
  <td><el-code>empty</el-code> <el-type>Stack</el-type>&lt;of <el-id>Type</el-id>&gt; or<br>
  <el-code>new <el-type>Stack</el-type>&lt;of <el-id>Type</el-id>&gt;()</el-code></td>
  <td><el-code>empty</el-code> <el-type>Queue</el-type>&lt;of <el-id>Type</el-id>&gt; or<br>
  <el-code>new <el-type>Queue</el-type>&lt;of <el-id>Type</el-id>&gt;()</el-code></td>
 </tr><tr>
  <td>create initialised</td>
  <td>not available</td>
  <td><el-code>new <el-type>Array2D</el-type>&lt;of <el-id>Type</el-id>&gt;(<el-id>cols</el-id>, <el-id>rows</el-id>, <el-id>value</el-id>)<br>
  <el-id>Type</el-id> of item is <el-type>Int</el-type>, <el-type>Float</el-type>, <el-type>String</el-type> or <el-type>Boolean</el-type>,<br>
  <el-id>cols</el-id> is the number of columns,<el-id><br>rows</el-id> is the number of rows</el-code>, and<br>
  <el-id>value</el-id> is the initial value of every item<br>(all are named values or literals)</td>
  <td>not available</td>
  <td>not available</td>
  <td>not available</td>
  <td>not available</td>
 </tr><tr>
  <td>read by index</td>
  <td><el-code>li[2]</el-code></td>
  <td><el-code>a2[3, 4]</el-code></td>
  <td><el-code>d["b"]</el-code></td>
  <td>not available</td>
  <td>not available</td>
  <td>not available</td>
 </tr><tr>
  <td>read by index range</td>
  <td><el-code>li[2..5]</el-code><br>lower bound is <i>inclusive</i> from 0<br>upper bound is <i>exclusive</i></td>
  <td>not available</td>
  <td>not available</td>
  <td>not available</td>
  <td>not available</td>
  <td>not available</td>
 </tr><tr>
  <td>procedure methods to mutate contents</td>
  <td>see <a href="#List_procedures">Procedure methods on a List</a></td>
  <td>see <a href="#Array2D_procedures">Procedure methods on an Array2D</a></td>
  <td>see <a href="#Dictionary_procedures">Procedure methods on a Dictionary</a></td>
  <td>not available</td>
  <td>not available</td>
  <td>not available</td>
 </tr><tr>
  <td>function dot methods</td>
  <td>see <a href="#List_functions">Function dot methods on a List</a></td>
  <td>see <a href="#Array2D_functions">Function dot methods on an Array2D</a></td>
  <td>see <a href="#Dictionary_functions">Function dot methods on a Dictionary</a></td>
  <td>see <a href="#Set_functions">Function dot methods on a Set</a></td>
  <td>see <a href="#Stack_functions">Function dot methods on a Stack</a></td>
  <td>see <a href="#Queue_functions">Function dot methods on a Queue</a></td>
 </tr>
</table>

<h2 id="List">List</h2>
<p>The <el-type>List</el-type> Type defines a data structure containing <i>n</i> items of any single Type,
 including fundamental value Types, structure Types such we <el-type>List</el-type> or <el-type>Array2D</el-type>,
 and also user-defined Types such as a class.</p>
<p>Items in a List of <i>n</i> items are indexed from <i>0</i> to <i>n-1</i>,</p>
<p>A List is created either empty or initialised from a literal definition.</p>
<p>A List's size can be dynamically changed.</p>

<div id="tail"></div>
<h3 class="no-TOC" id="deconstructList">Deconstructing a List</h3>
<p>A <el-type>List</el-type> may be split (deconstructed) into
 new named values in a similar way to deconstructing a <a href="#deconstructTuple">Tuple</a>, but in this case:</p>
<ul>
 <li>Deconstruction is into just two named values separated by a colon</li>
 <li>The first item in the list (the head) is assigned to the first named value.</li>
 <li>The remainder of the list (the tail) is assigned to the second named value.  If the original list contains only one item, the tail will be an empty List.</li>
 <li>Like deconstructing a Tuple, you can use an underscore <el-code>_</el-code> instead of one of the named values in order to discard either the head or the tail.</li>
</ul>
<p><el-code>variable x:xs set to myList</el-code><br>
<el-code>set h:t to myList</el-code><br>
<el-code>set h:myList to myList</el-code></p>
<p>Discarding either the head or tail:</p>
<p><el-code>variable _:tail set to myList</el-code><br>
<el-code>variable head:_ set to myList</el-code></p>

<h3 class="no-TOC" id="ListsOfLists">Lists of lists</h3>
<h4 class="no-TOC">Two dimensional arrays</h4>
<p>To create a 2D array that holds a value in every cell, you can define a list of lists like this:</p>
<el-code>variable a2d set to new List&lt;of List&lt;of Int&gt;&gt;()</el-code>
<p>You then refer to an individual cell (x,y) by its two coorinates in square brackets: a2d[x][y]</p>
<p>.. to set the value of the item at (x,y)</p>
<p>.. to retrieve the value of the item at (x,y)</p>

<p>This approach is used for the fixed 2D array used in <a href="#BlockGraphics">Block graphics</a> described below.
In this case, x refers to the columns in the display, and y to the rows.</p>

<h4 class="no-TOC">Higher dimensional arrays</h4>
<p>For a 3D array, you can define, for example:</p>
<el-code>variable a3d set to new List&lt;of List&lt;of List&lt;of Float&gt;&gt;&gt;()</el-code>
<p>and refer to a cell using three indexes.</p>
<p>In principle arrays of higher dimension can be defined.</p>

<h3 class="no-TOC" id="List_procedures">Procedure methods on a List</h3>
<p>Where an argument provides a new value for an item in a List, that value must be of the same Type as defined for the List's items.</p>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>arguments</th>
  <th>action</th>
 </tr><tr id="append">
  <td><el-method>append</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td>the item is added to the end of the List</td>
 </tr><tr id="appendList">
  <td><el-method>appendList</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>List</el-type></td>
  <td>the argument List is added to the end of the List</td>
 </tr><tr id="initialise">
  <td><el-method>initialise</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>Int</el-type>,<br>value of <el-type>List</el-type> items' Type</td>
  <td>specify the number (&gt; 0) of items in the List,<br>and an initial value for every item.<br>
      May be called at any time to redefine the List's size and initial values.</td>
 </tr><tr id="insert">
  <td><el-method>insert</el-method></td>
  <td><el-type>List</el-type></td>                  
  <td><el-type>Int</el-type>,<br>value of <el-type>List</el-type> items' Type</td>
  <td>the item is inserted at the index given.<br>
  If the index is negative it is counted from the end<br>
  If the index is greater than the list's length, the item is inserted at the end</td>
 </tr><tr id="prepend">
  <td><el-method>prepend</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td>the item is is added to the start of the List</td>
 </tr><tr id="prependList">
  <td><el-method>prependList</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>List</el-type></td>
  <td>the argument List is added to the start of the List</td>
 </tr><tr id="put_List">
  <td><el-method>put</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>Int</el-type>,<br>value of <el-type>List</el-type> items' Type</td>
  <td>replace the item at the given index with the new value</td>
 </tr><tr id="removeAll">
  <td><el-method>removeAll</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td>delete all items equal to the given item</td>
 </tr><tr id="removeAt_List">
  <td><el-method>removeAt</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>delete the item at the argument index</td>
 </tr><tr id="removeFirst">
  <td><el-method>removeFirst</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td>delete the first item equal to the given value</td>
 </tr>
</table>

<h3 class="no-TOC" id="List_functions">Function dot methods on a List</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>arguments</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asSet_List">
  <td><el-method>asSet</el-method></td>
  <td><el-type>List</el-type></td>
  <td>(none)</td>
  <td><el-type>Set</el-type></td>
  <td>a new Set containing all the <i>unique</i> items in the List</td>
 </tr><tr id="asString_List">
  <td><el-method>asString</el-method></td>
  <td><el-type>List</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a String that is a comma+space-separated list of the List's items, enclosed in square brackets</td>
 </tr><tr id="contains_List">
  <td><el-method>contains</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value</td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the List contains the specified item<br>
  &ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="filter_List">
  <td><el-method>filter</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-kw>lambda</el-kw></td>
  <td><el-type>List</el-type></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#filter"><el-method>filter</el-method></a> in <a href="#HoFs">HoFs</a></td>
 </tr><tr id="head_List">
  <td><el-method>head</el-method></td>
  <td><el-type>List</el-type></td>
  <td>(none)</td>
  <td><el-type>List</el-type> items' Type</td>
  <td>the first item of the List</td>
 </tr><tr id="indexOf_List">
  <td><el-method>indexOf</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td><el-type>Int</el-type></td>
  <td>the index of the first occurrence of the argument value in the List,<br>or -1 if no match is found</td>
 </tr><tr id="join">
  <td><el-method>join</el-method></td>
  <td><el-code><el-type>List</el-type>&lt;of <el-type>String</el-type>&gt;</el-code></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td>a single String that joins all the items in the list,<br>with the specified String (which can be empty) inserted between the items</td>
 </tr><tr id="length_List">
  <td><el-method>length</el-method></td>             
  <td><el-type>List</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the number of items in the List</td>
 </tr><tr id="map_List">
  <td><el-method>map</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-kw>lambda</el-kw></td>
  <td><el-type>List</el-type></td>
  <td>a new List obtained from applying a lambda to the input List<br>
  see <a href="#map"><el-method>map</el-method></a> in <a href="#HoFs">HoFs</a></td>
 </tr><tr id="maxFloat">
  <td><el-method>maxFloat</el-method></td>
  <td>(not a dot method)</td>
  <td><el-code><el-type>List</el-type>&lt;of <el-type>Float</el-type>&gt;</el-code></td>
  <td><el-type>Float</el-type></td>
  <td>the maximum value found in the List</td>
 </tr><tr id="minFloat">
  <td><el-method>minFloat</el-method></td>
  <td>(not a dot method)</td>
  <td><el-code><el-type>List</el-type>&lt;of <el-type>Float</el-type>&gt;</el-code></td>
  <td><el-type>Float</el-type></td>
  <td>the minimum value found in the List</td>
 </tr><tr id="maxInt">
  <td><el-method>maxInt</el-method></td>
  <td>(not a dot method)</td>
  <td><el-code><el-type>List</el-type>&lt;of <el-type>Int</el-type>&gt;</el-code></td>
  <td><el-type>Int</el-type></td>
  <td>the maximum value found in the List</td>
 </tr><tr id="minInt">
  <td><el-method>minInt</el-method></td>
  <td>(not a dot method)</td>
  <td><el-code><el-type>List</el-type>&lt;of <el-type>Int</el-type>&gt;</el-code></td>
  <td><el-type>Int</el-type></td>
  <td>the minimum value found in the List</td>
 </tr><tr id="maxBy_List">
  <td><el-method>maxBy</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-kw>lambda</el-kw></td>
  <td><el-type>List</el-type> items' Type</td>
  <td>the list item corresponding to the maximum of the values returned by a lambda<br>
  see <a href="#maxBy"><el-method>maxBy</el-method></a> in <a href="#HoFs">HoFs</a></td>
 </tr><tr id="minBy_List">
  <td><el-method>minBy</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-kw>lambda</el-kw></td>
  <td><el-type>List</el-type> items' Type</td>
  <td>the list item corresponding to the minimum of the values returned by a lambda<br>
  see <a href="#minBy"><el-method>minBy</el-method></a> in <a href="#HoFs">HoFs</a></td>
 </tr><tr id="orderBy_List">
  <td><el-method>orderBy</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-kw>lambda</el-kw></td>
  <td><el-type>List</el-type></td>
  <td>a new list with the items ordered according to the value returned by a lambda</td>
 </tr><tr id="reduce_List">
  <td><el-method>reduce</el-method></td>
  <td><el-type>List</el-type></td>
  <td>item of <el-type>List</el-type> of items' Type,<br><el-kw>lambda</el-kw></td>
  <td>return Type of lambda</td>
  <td>the final value obtained by applying a lambda cumulatively to each item in the input List<br>
  taking account of the first argument as an initial (and default return) value<br>
  see <a href="#reduce"><el-method>reduce</el-method></a> in <a href="#HoFs">HoFs</a></td>
 </tr><tr id="withAppend">
  <td><el-method>withAppend</el-method></td>
  <td><el-type>List</el-type></td>
  <td>item of <el-type>List</el-type> items' Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List lengthened with the item added after the end</td>
 </tr><tr id="withAppend_List">
  <td><el-method>withAppendList</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>List</el-type> of same Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List lengthened by appending the given List</td>
 </tr><tr id="withInsert">
  <td><el-method>withInsert</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>Int</el-type>,<br>value of <el-type>List</el-type> items' Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List with the item inserted after the item at the given index position</td>
</tr><tr id="withPrepend">
  <td><el-method>withPrepend</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List lengthened with the item added before the beginning</td>
 </tr><tr id="withPrepend_List">
  <td><el-method>withPrependList</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>List</el-type> of same Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List lengthened by prepending the given List</td>
 </tr><tr id="withPut_List">
  <td><el-method>withPut</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>Int</el-type>,<br>value of <el-type>List</el-type> items' Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List with the item replacing that at the given index</td>
 </tr><tr id="withRemoveAll">
  <td><el-method>withRemoveAll</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List with items equal to the given item removed</td>
 </tr><tr id="withRemoveAt_List">
  <td><el-method>withRemoveAt</el-method></td>
  <td><el-type>List</el-type></td>
  <td><el-type>Int</el-type></td>
  <td><el-type>List</el-type></td>
  <td>a new List with the item at the given index removed</td>
 </tr><tr id="withRemoveFirst">
  <td><el-method>withRemoveFirst</el-method></td>
  <td><el-type>List</el-type></td>
  <td>value of <el-type>List</el-type> items' Type</td>
  <td><el-type>List</el-type></td>
  <td>a new List with the first item equal to the given item removed</td>
 </tr>
</table>

<h2 id="Array2D">Array2D</h2>

<p>The <el-type>Array2D</el-type> Type defines a 2-dimensional aray data structure of fixed size containing items of a single Type.
 The items' Type must be one of <el-type>Int</el-type>, <el-type>Float</el-type>, <el-type>String</el-type>, or <el-type>Boolean</el-type>.</p>
<p>The extents of its two dimensions are specified when the array is created. They may be of the same size (giving a square array)
 or different (a rectangular array).
 (If you want to create a 'jagged' array, you should instead use a <el-type>List</el-type> of <el-type>List</el-type>s).</p>
<p>You refer to the position of an item in such an array by two <el-type>Int</el-type> index values <i>(x,y)</i>, where <i>x</i> is the column number
 and <i>y</i> is the row number of a rectangular grid.
Each index runs from <i>0</i> to <i>n-1</i>, where <i>n</i> is the specified <i>x</i> or <i>y</i> extent.</p>  
<p>The single initial item value at every <i>(x,y)</i> position is specified at the creation of the array.</p>
<p>To modify an item you may either <el-kw>call</el-kw> the <el-method>put</el-method> procedure method, or use the
<el-method>withPut</el-method> function dot method.</p>
<p>It is not possible to change the dimensions of an array.
(If you want to vary an array's dimensions, you should instead use a <el-type>List</el-type> of <el-type>List</el-type>s).</p>

<h3 class="no-TOC" id="Array2D_procedures">Procedure methods on an <el-type>Array2D</el-type></h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="put_Array2D">
  <td><el-method>put</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td><el-type>Int, Int</el-type>, value</td>
  <td>puts the value at the (two integers) index position in the array</td>
 </tr>
</table>

<h3 class="no-TOC" id="Array2D_functions">Function dot methods on an <el-type>Array2D</el-type></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_Array2D">
  <td><el-method>asString</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a String that is a comma+space-separated list of the array's columns each of which contains a comma+space-separated list
    of row values enclosed in square brackets, the whole enclosed in square brackets</td>
 </tr><tr id="blocksAsHtml">
  <td><el-method>blocksAsHtml</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr id="columns">
  <td><el-method>columns</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the number of columns in the array (the maximum <i>x</i> value)</td>
 </tr><tr id="contains_Array2D">
  <td><el-method>contains</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td>value</td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the array contains the item<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="indexOf_Array2D">
  <td><el-method>indexOf</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td>value</td>
  <td><el-type>Int, Int</el-type></td>
  <td>a Tuple containing the index pair of the first occurrence of the argument's value in the array
      by searching the columns in order, or (-1,-1) if no match is found</td>
 </tr><tr id="isSameReferenceAs_Array2D">
  <td><el-method>isSameReferenceAs</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr id="isSameValueAs_Array2D">
  <td><el-method>isSameValueAs</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr id="row">
  <td><el-method>rows</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the number of rows in the array (the maximum <i>y</i> value)</td>
 </tr><tr id="withPut_Array2D">
  <td><el-method>withPut</el-method></td>
  <td><el-type>Array2D</el-type></td>
  <td><el-type>Int, Int</el-type>, value</td>
  <td><el-type>Array2D</el-type></td>
  <td>a new <el-type>Array2D</el-type> with the item at the (two integers) index position in the array</td>
 </tr>
</table>

<p>Since an <el-type>Array2D</el-type> has a known fixed size, methods <el-method>rows</el-method> and <el-method>columns</el-method> are of use only when passing such an array into a procedure or function that needs to discover its size.</p>
<p>You can read individual items with a double index, for example:</p>
<el-code-block source="col_row.elan">
<el-statement class="ok multiline" id="for13" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident15" class="ok" tabindex="0"><el-txt><el-id>col</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-lit>7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok multiline" id="for19" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident21" class="ok" tabindex="0"><el-txt><el-id>row</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr22" class="ok" tabindex="0"><el-txt><el-lit>0</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-lit>7</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr24" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="print25" tabindex="0"><el-kw>print </el-kw><el-field id="expr26" class="optional ok" tabindex="0"><el-txt><el-id>board</el-id>[<el-id>col</el-id>, <el-id>row</el-id>]</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end for</el-kw>
</el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<h2 id="Dictionary">Dictionary</h2>
<p>A Dictionary works like an Array, but instead of having a numeric (integer) index, each entry has a <i>key</i>. Each key is associated with a <i>value</i>,
so the Dictionary is a set of <i>key:value</i> pairs.
The key's Type must be one of <el-type>Int</el-type>, <el-type>Float</el-type>, <el-type>String</el-type> or <el-type>Boolean</el-type>,
<i>or</i> it may be a user-defined <el-code>record</el-code>. The values may be of any Type, and the Types of both key and value are fixed when the Dictionary is created.</p>

<h3 class="no-TOC" id="Dictionary_procedures">Procedure methods on a Dictionary</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="put_Dictionary">
  <td><el-method>put</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>key's Type, value's Type</td>
  <td>replace the value at an existing key, or add a <i>key:value</i> pair</td>
 </tr><tr id="removeAt_Dictionary">
  <td><el-method>removeAt</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>key's Type</td>
  <td>delete the key:pair at the given key (if it exists)</td>
 </tr>
</table>

<h3 class="no-TOC" id="Dictionary_functions">Function dot methods on a Dictionary</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asString_Dictionary">
  <td><el-method>asString</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a string that is a comma+space-separated list of the Dictionary's <i>key:value</i> pairs, enclosed in square brackets</td>
 </tr><tr id="hasKey_Dictionary">
  <td><el-method>hasKey</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>item of <el-type>Dictionary key's Type</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the Dictionary contains the given key<br>&ndash; <el-id>false</el-id> otherwise</td>
</tr><tr id="keys_Dictionary">
  <td><el-method>keys</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>(none)</td>
  <td><el-type>List</el-type></td>
  <td>a List containing the keys</td>
</tr><tr id="values_Dictionary">
  <td><el-method>values</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>(none)</td>
  <td><el-type>List</el-type></td>
  <td>a List containing the values</td>
</tr><tr id="withPut_Dictionary">
  <td><el-method>withPut</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>item of <el-type>Dictionary key's Type</el-type>,<br>item of <el-type>Dictionary value's Type</el-type></td>
  <td><el-type>Dictionary</el-type></td>
  <td>a new Dictionary with the value replacing what was at the specified key</td>
 </tr><tr id="withRemoveAt_Dictionary">
  <td><el-method>withRemoveAt</el-method></td>
  <td><el-type>Dictionary</el-type></td>
  <td>item of <el-type>Dictionary key's Type</el-type></td>
  <td><el-type>Dictionary</el-type></td>
  <td>a new Dictionary with the <i>key:value</i> pair removed from the specified key</td>
 </tr>
</table>

<h2 id="SetType">Set</h2>
    <p>A <el-type>Set</el-type> is a standard data structure containing set members, that works somewhat like a <el-type>List</el-type> with the important difference that the value of a set member may appear only once.
     If a member being added to a <el-type>Set</el-type> has the same value as an existing member in the Set then the Set remains the same length as before.</p>
    <p>This enables a Set to work like a mathematical set so that it is possible to perform standard set operations such as <el-method>union</el-method> and <el-method>intersection</el-method>.
     For the same reason, a Set is an immutable data structure: there are no methods that modify an existing Set, but several (including <el-method>add</el-method>, <el-method>remove</el-method>)
      return a new Set that is based on the original Set or Sets, with specified differences.</p>
    <p>Example of use:</p>
<el-code-block source="set.elan">
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Set</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set6" tabindex="0"><el-kw>set </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>addFromList</el-method>([<el-lit>3</el-lit>, <el-lit>5</el-lit>, <el-lit>7</el-lit>])</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print9" tabindex="0"><el-kw>print </el-kw><el-field id="expr10" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set11" tabindex="0"><el-kw>set </el-kw><el-field id="ident12" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr13" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>add</el-method>(<el-lit>7</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print14" tabindex="0"><el-kw>print </el-kw><el-field id="expr15" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set16" tabindex="0"><el-kw>set </el-kw><el-field id="ident17" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr18" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>remove</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print19" tabindex="0"><el-kw>print </el-kw><el-field id="expr20" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set21" tabindex="0"><el-kw>set </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>remove</el-method>(<el-lit>3</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print24" tabindex="0"><el-kw>print </el-kw><el-field id="expr25" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print26" tabindex="0"><el-kw>print </el-kw><el-field id="expr27" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
 </el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
    <li> When creating a Set, the Type of its members must be specified in the form
    <el-code><el-type>Set</el-type>&lt;of <el-type>String</el-type>&gt;</el-code>. This applies both when creating a new, empty set and when defining the Type of a parameter to be a <el-code>Set</el-code>.</li>
    <li>You can add members: individually with <el-method>add</el-method>, or multiple members with <el-code>addFromList</el-code>.</li>
    <li>You can create a new Set from an existing <el-type>List</el-type> by calling <el-code>asSet</el-code> on it.</li>
</ul>

<h3 class="no-TOC" id="Set_functions">Function dot methods on a Set</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="add">
  <td><el-method>add</el-method></td>
  <td><el-type>Set</el-type></td>
  <td>value (of <el-type>Set</el-type> members' Type)</td>
  <td><el-type>Set</el-type></td>
  <td>a new Set extended with the item, provided it differs from all the Set's current members</td>
 </tr><tr id="addFromList">
  <td><el-method>addFromList</el-method></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>List</el-type></td>
  <td><el-type>Set</el-type></td>
  <td>a new Set extended with those items from the List that are not already in the Set</td>
 </tr><tr id="asList_Set">
  <td><el-method>asList</el-method></td>
  <td><el-type>Set</el-type></td>
  <td>(none)</td>
  <td><el-type>List</el-type></td>
  <td>a List containing the Set's members as List items</td>
 </tr><tr id="asString_Set">
  <td><el-method>asString</el-method></td>
  <td><el-type>Set</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a string that is a comma+space-separated list of the Set's members, enclosed in curly braces</td>
 </tr><tr id="contains_Set">
  <td><el-method>contains</el-method></td>
  <td><el-type>Set</el-type></td>
  <td>value (of <el-type>Set</el-type> members' Type)</td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the Set contains the item<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="difference">
  <td><el-method>difference</el-method></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td>a Set containing those members of the Set that do not occur in the argument Set</td>
 </tr><tr id="intersection">
  <td><el-method>intersection</el-method></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td>a Set containing those members common to both the Set and the argument Set</td>
 </tr><tr id="isDisjointFrom">
  <td><el-method>isDisjointFrom</el-method></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the Set has no items in common with the argument Set<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="isSubsetOf">
  <td><el-method>isSubsetOf</el-method></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if all the Set's items are also in the argument Set<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="isSupersetOf">
  <td><el-method>isSupersetOf</el-method></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Boolean</el-type></td>
  <td><el-id>true</el-id> if the Set contains all the  items that are in the argument Set<br>&ndash; <el-id>false</el-id> otherwise</td>
 </tr><tr id="length_Set">
  <td><el-method>length</el-method></td>
  <td><el-type>Set</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the number of members of the Set</td>
 </tr><tr id="remove">
  <td><el-method>remove</el-method></td>
  <td><el-type>Set</el-type></td>
  <td>value (of <el-type>Set</el-type> members' Type)</td>
  <td><el-type>Set</el-type></td>
  <td>a new Set with the argument item removed (if present)</td>
 </tr><tr id="union">
  <td><el-method>union</el-method></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td><el-type>Set</el-type></td>
  <td>a Set containing all the unique members of the Set and the argument Set (i.e. no duplicates)</td>
 </tr>
 </table>

<div id="Queue"></div>
<h2 id="Stack">Stack and Queue</h2>
<ul>
    <li><el-type>Stack</el-type> and <el-type>Queue</el-type> are similar data structures except that <el-type>Stack</el-type> is 'LIFO' (last in, first out), while <el-type>Queue</el-type> is FIFO (first in, first out). The names of the methods for adding/removing are different, but there are also common methods.</li>
    <li>Both a <el-type>Stack</el-type> and a <el-type>Queue</el-type> are defined with the Type of the items that they can contain, similarly to how <el-type>List</el-type> has a specified item Type, though with different syntax. The Type is specified in the form shown below e.g. <el-code><el-type>Stack</el-type>&lt;of <el-type><el-type>String</el-type></el-type>&gt;, <el-type>Queue</el-type>&lt;of <el-type>Int</el-type>&gt;, <el-type>Stack</el-type>&lt;of (<el-type>Float</el-type>, <el-type>Float</el-type>)&gt;, <el-type>Queue</el-type>&lt;of <el-type>Square</el-type>&gt;</el-code>.</li>
    <li>Both <el-type>Stack </el-type>and<el-type> Queue</el-type> are dynamically extensible, like a <el-type>List</el-type>. There is no need (or means) to specify a size limit as they will continue to expand until, eventually, the computer's memory limit is reached.</li>
    <li>This same syntax is used to specify the Type if you want to pass a <el-type>Stack</el-type> or <el-type>Queue</el-type> into a function, or specify it as the <el-kw>return</el-kw> Type.</li>
    <li><el-type>Stack</el-type> and <el-type>Queue</el-type> have two methods in common: <el-method>length</el-method> and <el-method>peek</el-method>.
    <el-method>peek</el-method> returns the next item to be removed, without actually removing it.</li>
    <li>The methods for adding and removing an item are different for <el-type>Stack</el-type> and <el-type>Queue</el-type>, as shown here:</li>
</ul>

<h3 class="no-TOC" id="Stack_functions">Function dot methods on a Stack</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Types</th>
  <th>returns</th>
 </tr><tr id="push">
  <td><el-method>push</el-method></td>
  <td><el-type>Stack</el-type></td>
  <td>value (of <el-type>Stack</el-type> items' Type)</td>
  <td><el-type>Stack</el-type></td>
  <td>the Stack with the value added to its top</td>
 </tr><tr id="pop">
  <td><el-method>pop</el-method></td>
  <td><el-type>Stack</el-type></td>
  <td>(none)</td>
  <td><el-type>Stack</el-type> item,<br><el-type>Stack</el-type></td>
  <td>the topmost item of the Stack, and the Stack with the item removed</td>
 </tr><tr id="peek_Stack">
  <td><el-method>peek</el-method></td>
  <td><el-type>Stack</el-type></td>
  <td>(none)</td>
  <td><el-type>Stack</el-type> item</td>
  <td>the topmost item on the Stack (without altering the Stack)</td>
 </tr><tr id="length_Stack">
  <td><el-method>length</el-method></td>
  <td><el-type>Stack</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the number of items in the Stack</td>
 </tr><tr id="asString_Stack">
  <td><el-method>asString</el-method></td>
  <td><el-type>Stack</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a String that is a comma+space-separated list of the Stack's items, enclosed in square brackets,<br>
   the last item pushed being the first in the String</td>
 </tr>
</table>

<h3 class="no-TOC" id="Queue_functions">Function dot methods on a Queue</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Types</th>
  <th>returns</th>
 </tr><tr id="enqueue">
  <td><el-method>enqueue</el-method></td>
  <td><el-type>Queue</el-type></td>
  <td>value (of <el-type>Queue</el-type> items' Type)</td>
  <td><el-type>Queue</el-type></td>
  <td>the Queue with the item added to the end of the Queue</td>
 </tr><tr id="dequeue">
  <td><el-method>dequeue</el-method></td>
  <td><el-type>Queue</el-type></td>
  <td>(none)</td>
  <td><el-type>Queue</el-type> item,<br><el-type>Queue</el-type></td>
  <td>the next item in the Queue, and the Queue  with the item removed</td>
 </tr><tr id="peek_Queue">
  <td><el-method>peek</el-method></td>
  <td><el-type>Queue</el-type></td>
  <td>(none)</td>
  <td><el-type>Queue</el-type> item</td>
  <td>the next item in the Queue (without altering the Queue)</td>
 </tr><tr id="length_Queue">
  <td><el-method>length</el-method></td>
  <td><el-type>Queue</el-type></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>the number of items in the Queue</td>
 </tr><tr id="asString_Queue">
  <td><el-method>asString</el-method></td>
  <td><el-type>Queue</el-type></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>a String that is a comma+space-separated list of the Queue's items, enclosed in square brackets,<br>
   the first item enqueued being the first in the String</td>
</tr>
</table>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-type>Stack</el-type> and <el-type>Queue</el-type></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To push and pop strings:</p>
<el-code-block source="stack.elan">
<el-statement class="ok" id="var35" tabindex="0"><el-kw>variable </el-kw><el-field id="var36" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr37" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Stack</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print6" tabindex="0"><el-kw>print </el-kw><el-field id="expr7" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set47" tabindex="0"><el-kw>set </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>push</el-method>("<el-lit>apple</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set52" tabindex="0"><el-kw>set </el-kw><el-field id="ident53" class="ok" tabindex="0"><el-txt><el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr54" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>push</el-method>("<el-lit>Pear</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print14" tabindex="0"><el-kw>print </el-kw><el-field id="expr15" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print16" tabindex="0"><el-kw>print </el-kw><el-field id="expr17" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>peek</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var63" tabindex="0"><el-kw>variable </el-kw><el-field id="var64" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr65" class="ok" tabindex="0"><el-txt>""</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set66" tabindex="0"><el-kw>set </el-kw><el-field id="ident67" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr68" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>pop</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print21" tabindex="0"><el-kw>print </el-kw><el-field id="expr22" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set70" tabindex="0"><el-kw>set </el-kw><el-field id="ident71" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>st</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr72" class="ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>pop</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print26" tabindex="0"><el-kw>print </el-kw><el-field id="expr27" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print28" tabindex="0"><el-kw>print </el-kw><el-field id="expr29" class="optional ok" tabindex="0"><el-txt><el-id>st</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; To enqueue and dequeue strings:</p>
<el-code-block source="queue.elan">
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>qu</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Queue</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print6" tabindex="0"><el-kw>print </el-kw><el-field id="expr7" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set8" tabindex="0"><el-kw>set </el-kw><el-field id="ident9" class="ok" tabindex="0"><el-txt><el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr10" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>enqueue</el-method>("<el-lit>apple</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set11" tabindex="0"><el-kw>set </el-kw><el-field id="ident12" class="ok" tabindex="0"><el-txt><el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr13" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>enqueue</el-method>("<el-lit>Pear</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print14" tabindex="0"><el-kw>print </el-kw><el-field id="expr15" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print16" tabindex="0"><el-kw>print </el-kw><el-field id="expr17" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>peek</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="var18" tabindex="0"><el-kw>variable </el-kw><el-field id="var19" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt>""</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set21" tabindex="0"><el-kw>set </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>dequeue</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print24" tabindex="0"><el-kw>print </el-kw><el-field id="expr25" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="set26" tabindex="0"><el-kw>set </el-kw><el-field id="ident27" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id>, <el-id>qu</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr28" class="ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>dequeue</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print29" tabindex="0"><el-kw>print </el-kw><el-field id="expr30" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="print31" tabindex="0"><el-kw>print </el-kw><el-field id="expr32" class="optional ok" tabindex="0"><el-txt><el-id>qu</el-id>.<el-method>length</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<hr>
</div></div>

<h1 id="CommonDotMethods">Common dot methods</h1>

<h2>Dot methods that work on more than one fundamental Type</h2>
<p>Although all applicable methods are described in earlier sections under each Type, this table lists those which are applicable to several Types.</p>
<p>Click on a Type to go to the Type's dot methods, or on the <el-id>&#x2714;</el-id> tick to go to the specific method on that Type.</p>

<table >
 <tr>
  <th>Method</th>
  <th colspan="13">Type</th>
 </tr><tr><!---->
  <td></td>
  <td><a href="#Int"><el-type>Int</el-type></a></td>
  <td><a href="#Float"><el-type>Float</el-type></a></td>
  <td><a href="#Boolean"><el-type>Boolean</el-type></a></td>
  <td><a href="#String"><el-type>String</el-type></a></td>
  <td><a href="#List"><el-type>List</el-type></a></td>
  <td><a href="#Array2D"><el-type>Array2D</el-type></a></td>
  <td><a href="#Dictionary"><el-type>Dictionary</el-type></a></td>
  <td><a href="#SetType"><el-type>Set</el-type></a></td>
  <td><a href="#Stack"><el-type>Stack</el-type></a></td>
  <td><a href="#Queue"><el-type>Queue</el-type></a></td>
 </tr><tr><!---->
  <td id="asList"><el-method>asList</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#asList_Set">&#x2714;</a></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="asSet"><el-method>asSet</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#asSet_List">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="asString"><el-method>asString</el-method></td>
  <td><a href="#asString_Int">&#x2714;</a></td>
  <td><a href="#asString_Float">&#x2714;</a></td>
  <td><a href="#asString_Boolean">&#x2714;</a></td>
  <td><a href="#asString_String">&#x2714;</a></td>
  <td><a href="#asString_List">&#x2714;</a></td>
  <td><a href="#asString_Array2D">&#x2714;</a></td>
  <td><a href="#asString_Dictionary">&#x2714;</a></td>
  <td><a href="#asString_Set">&#x2714;</a></td>
  <td><a href="#asString_Stack">&#x2714;</a></td>
  <td><a href="#asString_Queue">&#x2714;</a></td>
 </tr><tr><!---->
  <td id="contains"><el-method>contains</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#contains_String">&#x2714;</a></td>
  <td><a href="#contains_List">&#x2714;</a></td>
  <td><a href="#contains_Array2D">&#x2714;</a></td>
  <td>see notes</td>
  <td><a href="#contains_Set">&#x2714;</a></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="hasKey"><el-method>hasKey</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#hasKey_Dictionary">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="head"><el-method>head</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#head_List">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="indexOf"><el-method>indexOf</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#indexOf_String">&#x2714;</a></td>
  <td><a href="#indexOf_List">&#x2714;</a></td>
  <td><a href="#indexOf_Array2D">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="keys"><el-method>keys</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#keys_Dictionary">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="length"><el-method>length</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#length_String">&#x2714;</a></td>
  <td><a href="#length_List">&#x2714;</a></td>
  <td></td>
  <td>see notes</td>
  <td><a href="#length_Set">&#x2714;</a></td>
  <td><a href="#length_Stack">&#x2714;</a></td>
  <td><a href="#length_Queue">&#x2714;</a></td>
 </tr><tr><!---->
  <td id="peek"><el-method>peek</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#peek_Stack">&#x2714;</a></td>
  <td><a href="#peek_Queue">&#x2714;</a></td>
 </tr><tr><!---->
  <td id="values"><el-method>values</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#values_Dictionary">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="withPut"><el-method>withPut</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#withPut_List">&#x2714;</a></td>
  <td><a href="#withPut_Array2D">&#x2714;</a></td>
  <td><a href="#withPut_Dictionary">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
 </tr><tr><!---->
  <td id="withRemoveAt"><el-method>withRemoveAt</el-method></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td><a href="#withRemoveAt_List">&#x2714;</a></td>
  <td></td>
  <td><a href="#withRemoveAt_Dictionary">&#x2714;</a></td>
  <td></td>
  <td></td>
  <td></td>
 </tr>
</table>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>The method <el-method>asString</el-method> is so widely applicable because it enables you to print
 most variables and data structures to the IDE's display pane for debugging purposes.</li>
 <li>The length of a <el-type>Dictionary</el-type> can be found by applying method <el-method>length</el-method> to the list returned by method <el-method>keys</el-method> on the dictionary:</li>
  <p><el-code>print dict.keys().length()</el-code> &#x27f6; 15</p>
 <li>Checking whether an item is contained in a <el-type>Dictionary</el-type> can be
  done by applying method <el-method>contains</el-method> to the list returned by methods <el-method>keys</el-method> and <el-method>values</el-method> on the dictionary:</li>
  <p><el-code>print dict.keys().contains(42)</el-code> &#x27f6; <el-id>true</el-id> or <el-id>false</el-id></p>
  <p><el-code>print dict.values().contains("widget")</el-code> &#x27f6; <el-id>true</el-id> or <el-id>false</el-id></p>
</ul>

<h1 id="Graphics">Graphics</h1>

<h2 id="BlockGraphics">Block graphics</h2>
<p>Block graphics provides a simple way to create low resolution graphics, ideal for simple but engaging games for example.</p>
<p>The graphics are defined and displayed on a grid that is 40 blocks wide by 30 blocks high.</p>
<p>Each block is be rendered as a solid colour.</p>
<p>An example of block graphics to produce a rapidly changing pattern of coloured blocks:</p>

<el-code-block source="block_graphics.elan">
<el-statement class="ok" id="var3" tabindex="0"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>blocks</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Array2D</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;(<el-lit>40</el-lit>, <el-lit>30</el-lit>, <el-id>white</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok multiline" id="while6" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt></el-field></el-top>
<el-statement class="ok" id="let9" tabindex="0"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="0"><el-txt><el-id>x</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr11" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>39</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="let12" tabindex="0"><el-kw>let </el-kw><el-field id="var13" class="ok" tabindex="0"><el-txt><el-id>y</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-lit>29</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="let15" tabindex="0"><el-kw>let </el-kw><el-field id="var16" class="ok" tabindex="0"><el-txt><el-id>colour</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-method>randomInt</el-method>(<el-lit>0</el-lit>, <el-id>white</el-id> - <el-lit>1</el-lit>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>blocks</el-id>.<el-method>put</el-method></el-txt></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-id>x</el-id>, <el-id>y</el-id>, <el-id>colour</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call21" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-method>displayBlocks</el-method></el-txt></el-field>(<el-field id="args23" class="optional ok" tabindex="0"><el-txt><el-id>blocks</el-id></el-txt></el-field>)</el-top></el-statement>
<el-kw>end while</el-kw>
</el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
 <li>The definition of the grid must be an <el-type>Array2D</el-type> of Type <el-type>Int</el-type> and of size 40 x 30.</li>
 <li>Each cell of the grid is referenced by integers <i>x</i>,<i>y</i> where <i>x</i> is in [0..39] and <i>y</i> is in [0..29].</li>
 <li><i>x</i>,<i>y</i> is 0,0 at the top left cell of the grid, positive <i>x</i> to the right, positive <i>y</i> downwards.</li>
 <li>You may create multiple <el-type>Array2Ds</el-type> holding different patterns of blocks, and switch between them
 just by passing the required one as the argument to the <el-method>displayBlocks</el-method> method.</li>
 <li>A colour is specified as an <el-type>Int</el-type>, as described under <a href="#Colours">Colours</a>.</li>
</ul>

<h2 id="TurtleGraphics">Turtle graphics</h2>
<p>Turtle graphics are implemented with output to the IDE's display pane, i.e. the 'paper' on which the turtle draws.</p>
<p>The area is 200 turtle units wide by 150 turtle units high, and both integer and floating point values of turtle units can be used.
 If a turtle is placed or moved outside the 200 &times; 150 area boundary, it will not cause an error,
 but the turtle and any lines drawn outside the boundary will not be visible.</p>
<p>The origin for turtle units (0,0) is at the centre of the area: positive <i>x</i> rightwards, positive <i>y</i> upwards.
So the top left corner of the display is at (-100,75).</p>
<p>A new turtle's default starting position is at (0,0) facing upwards (<el-id>heading</el-id> is 0), from where a <el-method>move</el-method>  will be  in the <i>y</i> direction.</p>
<p>You can move and turn a turtle, causing lines to be drawn, whether or not the turtle is showing.</p>
<h3 class="no-TOC" id="Turtle_procedures">Procedure methods on a Turtle</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>action</th>
 </tr><tr id="clearAndReset">
  <td><el-method>clearAndReset</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td>(none)</td>
  <td>clears the turtle display and moves the turtle to its starting position and heading</td>
 </tr><tr id="hide">
  <td><el-method>hide</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td>(none)</td>
  <td>makes the turtle invisible in the display</td>
 </tr><tr id="move">
  <td><el-method>move</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td><el-type>Int</el-type> or <el-type>Float</el-type></td>
  <td>moves the turtle the specified number of turtle units in the direction of its heading or,<br>if negative, in the opposite direction</td>
 </tr><tr id="moveTo">
  <td><el-method>moveTo</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td><el-type>Int</el-type> or <el-type>Float</el-type>,<br>
      <el-type>Int</el-type> or <el-type>Float</el-type></td>
  <td>moves the turtle to the specified <i> x,y</i> position, drawing its path if its pen is down</td>
 </tr><tr id="penColour">
  <td><el-method>penColour</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>changes the <a href="#Colours">colour</a> of its path in the display to the literal or named value specified</td>
 </tr><tr id="penDown">
  <td><el-method>penDown</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td>(none)</td>
  <td>makes the turtle's subsequent moves leave a trace of its path in the display</td>
 </tr><tr id="penUp">
  <td><el-method>penUp</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td>(none)</td>
  <td>makes the turtle's subsequent moves leave no trace of its path in the display</td>
 </tr><tr id="penWidth">
  <td><el-method>penWidth</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td><el-type>Int</el-type> or <el-type>Float</el-type></td>
  <td>changes the width of the line tracing the turtle's path in the display<br>default (and minimum) is 1 </td>
 </tr><tr id="placeAt">
  <td><el-method>placeAt</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td><el-type>Int</el-type> or <el-type>Float</el-type>,<br>
      <el-type>Int</el-type> or <el-type>Float</el-type></td>
  <td>places or repositions the turtle at the <i>x,y</i> position specified without drawing a path</td>
 </tr><tr id="show">
  <td ><el-method>show</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td>(none)</td>
  <td>makes the turtle visible in the display as a green blob<br>marked with a black radius that indicates its heading</td>
 </tr><tr id="turn">
  <td><el-method>turn</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td><el-type>Int</el-type> or <el-type>Float</el-type></td>
  <td>turns the turtle through the specified number of degrees clockwise or,<br>if negative, anticlockwise</td>
 </tr><tr id="turnToHeading">
  <td><el-method>turnToHeading</el-method></td>
  <td><el-type>Turtle</el-type></td>
  <td><el-type>Int</el-type> or <el-type>Float</el-type></td>
  <td>turns the turtle to face in the direction specified in degrees<br>where 0 is upward and increasing values go clockwise from there</td>
 </tr>
</table>
<h3 class="no-TOC" id="Turtle_properties">Properties of a Turtle</h3>
<p>The current location and heading of the turtle may be read using the properties
  <el-id>x</el-id>, <el-id>y</el-id>, and <el-id>heading</el-id>.</p>
<table class="tableMethod">
 <tr>
  <th colspan="2">Property</th>
  <th colspan="2"></th>
 </tr><tr>
  <th>name</th>
  <th>Type</th>
  <th>description</th>
  <th>default</th>
 </tr><tr id="heading">
  <td><el-id>heading</el-id></td>
  <td><el-type>Float</el-type></td>
  <td>the direction in which the turtle is pointing<br>in degrees clockwise from North</td>
  <td>0.0 degrees,<br>i.e. upward in the display</td>
 </tr><tr id="xy_Turtle">
  <td><el-id>x</el-id>, <el-id>y</el-id></td>
  <td><el-type>Float</el-type>, <el-type>Float</el-type></td>
  <td>the <i>x,y</i> coordinates of the turtle's current position</td>
  <td>0.0, 0.0</td>
 </tr>
</table>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using turtle graphics</h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To draw a square:</p>
<el-code-block source="turtleSquare.elan">
<el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>t</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Turtle</el-type>()</el-txt></el-field></el-statement>
<el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>placeAt</el-method></el-txt></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt>-<el-lit>75</el-lit>, <el-lit>50</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call9" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>show</el-method></el-txt></el-field>(<el-field id="args11" class="empty optional ok" tabindex="0"><el-txt></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok multiline" id="for12" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident14" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> from </el-kw><el-field id="expr15" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt></el-field><el-kw> to </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit>4</el-lit></el-txt></el-field><el-kw> step </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt></el-field></el-top>
<el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-lit>90</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call21" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>move</el-method></el-txt></el-field>(<el-field id="args23" class="optional ok" tabindex="0"><el-txt><el-lit>80</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call24" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident25" class="ok" tabindex="0"><el-txt><el-method>pause</el-method></el-txt></el-field>(<el-field id="args26" class="optional ok" tabindex="0"><el-txt><el-lit>500</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>
<img src="images/turtleSquare.png" width="270" height="290">
<hr>
<p>&nbsp;&nbsp;&nbsp;&#x25b6; To draw a fractal snowflake, using a procedure and recursion:</p>
<el-code-block source="turtle_snowflake.elan">
<main class="ok multiline" id="main1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw></el-top>
<el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>t</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-kw>new</el-kw> <el-type>Turtle</el-type>()</el-txt></el-field></el-statement>
<el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>placeAt</el-method></el-txt></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt>-<el-lit>50</el-lit>, <el-lit>30</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call9" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt></el-field>(<el-field id="args11" class="optional ok" tabindex="0"><el-txt><el-lit>90</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok multiline" id="for12" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident14" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> from </el-kw><el-field id="expr15" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt></el-field><el-kw> to </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt><el-lit>3</el-lit></el-txt></el-field><el-kw> step </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt></el-field></el-top>
<el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-id>side</el-id>, <el-id>t</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call21" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt></el-field>(<el-field id="args23" class="optional ok" tabindex="0"><el-txt><el-lit>120</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
<el-kw>end main</el-kw>
</main>
<el-proc class="ok multiline" id="proc24" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>procedure </el-kw><el-method><el-field id="ident26" class="ok" tabindex="0"><el-txt>drawSide</el-txt></el-field></el-method>(<el-field id="params27" class="optional ok" tabindex="0"><el-txt><el-id>length</el-id> <el-kw>as</el-kw> <el-type>Float</el-type>, <el-id>t</el-id> <el-kw>as</el-kw> <el-type>Turtle</el-type></el-txt></el-field>)</el-top>
<el-statement class="ok multiline" id="if28" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>if </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt>(<el-id>length</el-id> &gt; <el-lit>1</el-lit>)</el-txt></el-field><el-kw> then</el-kw></el-top>
<el-statement class="ok" id="let31" tabindex="0"><el-kw>let </el-kw><el-field id="var32" class="ok" tabindex="0"><el-txt><el-id>third</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr33" class="ok" tabindex="0"><el-txt><el-id>length</el-id>/<el-lit>3</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="call34" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident35" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt></el-field>(<el-field id="args36" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call37" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident38" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt></el-field>(<el-field id="args39" class="optional ok" tabindex="0"><el-txt>-<el-lit>60</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call40" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident41" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt></el-field>(<el-field id="args42" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call43" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident44" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt></el-field>(<el-field id="args45" class="optional ok" tabindex="0"><el-txt><el-lit>120</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call46" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident47" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt></el-field>(<el-field id="args48" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call49" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident50" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>turn</el-method></el-txt></el-field>(<el-field id="args51" class="optional ok" tabindex="0"><el-txt>-<el-lit>60</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call52" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident53" class="ok" tabindex="0"><el-txt><el-method>drawSide</el-method></el-txt></el-field>(<el-field id="args54" class="optional ok" tabindex="0"><el-txt><el-id>third</el-id>, <el-id>t</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok outdent" id="else55" tabindex="0"><el-top>
    <el-kw>else </el-kw><el-field id="elif57" class="empty optional ok" tabindex="0"><el-txt></el-txt></el-field></el-top></el-statement>
<el-statement class="ok" id="call58" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident59" class="ok" tabindex="0"><el-txt><el-id>t</el-id>.<el-method>move</el-method></el-txt></el-field>(<el-field id="args60" class="optional ok" tabindex="0"><el-txt><el-id>length</el-id></el-txt></el-field>)</el-top></el-statement>
<el-kw>end if</el-kw>
</el-statement>
<el-kw>end procedure</el-kw>
</el-proc>
<el-const class="ok multiline" id="const61" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>constant </el-kw><el-field id="ident62" class="ok" tabindex="0"><el-txt><el-id>side</el-id></el-txt></el-field></el-top><el-kw> set to </el-kw><el-field id="text63" class="ok" tabindex="0"><el-txt><el-lit>100</el-lit></el-txt></el-field></el-const>
</el-code-block>
<p><img src="images/turtleSnowflake.png" width="270" height="295" ></p>
<hr>
</div></div>

<h2 id="VectorGraphics">Vector graphics</h2>
<p>Vector graphics are implemented using the SVG (Scalable Vector Graphics) Html tag &lt;svg&gt;, and are output to the display pane in the user interface.</p>
<p>The area is 100 units wide by 75 units high, and both integer and floating point values of the units can be used.</p>
<p>The origin of the units (0,0) is at the top left corner of the display: positive <i>x</i> rightwards, positive <i>y</i> downwards.
So for example the centre of the display is at (50, 37.5).</p>
<p>The names of the shapes broadly correspond to the names of SVG tags:</p>
<ul>
 <li id="CircleVG"> <el-code>CircleVG</el-code> for &lt;<el-code>circle../&gt;</el-code></li>
 <li id="ImageVG"><el-code>ImageVG</el-code> for <el-code>&lt;image../&gt;</el-code></li>
 <li id="LineVG"><el-code>LineVG</el-code> for <el-code>&lt;line../&gt;</el-code></li>
 <li id="RectangleVG"><el-code>RectangleVG</el-code> for <el-code>&lt;rect../&gt;</el-code></li>
</ul>
<p>The properties of these shapes reflect the names of the attributes used in the SVG tags but some names differ. For example, SVG's <el-id>stroke-width</el-id>
 is set with property <el-id>strokeWidth</el-id>, to make it a valid <a href="LangRef.html#Identifier">identifier</a>.
Also <el-code>stroke</el-code> and <el-code>fill</el-code> are set by the properties <el-id>strokeColour</el-id> and <el-id>fillColour</el-id>.</p>

<p>In addition, graphics may be displayed from any valid string of SVG tags, as described in <a href="#RawVG"><el-type>RawVG</el-type></a>.</p> 

<h3 class="no-TOC" id="VectorGraphic">Defining Vector graphic shapes</h3>
<p>A set of SVG shapes is defined in either a <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt; or a <el-type>List</el-type> of any specific Type of <el-type>VectorGraphic</el-type> (e.g. <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>CircleVG</el-type>&gt;) by using the <el-type>List</el-type> <el-method>append</el-method> method.</p>
<p><el-type>VectorGraphic</el-type> is the abstract superclass of all <el-code>..VG</el-code> shapes. You would use it if you wanted to define a <el-type>List</el-type> holding different types of shape.</p>
<p>Adding a shape returns a new instance of the list which must be assigned either to an existing variable, or to a new <el-kw>let</el-kw>.</p>
<p>The constructors for the VG Types require arguments defining the attributes of the relevant SVG tags, so defaults are supplied from the class properties,
as shown in the table below.</p>
<p>To supply your own values for the properties:
<ul>
 <li>for a <a href="LangRef.html#new"><el-kw>new</el-kw> instance</a>, to set the value of property 'P..', use the <el-kw>with</el-kw> clause .</li>
 <li>for an existing instance, to change the value of property 'P..', call the <el-method>setP..</el-method> procedure method on the <el-type>VectorGraphic</el-type> or<br>
 (in a function) use the <el-method>withP..</el-method> dot method on the <el-type>VectorGraphic</el-type>, in either case specifying new values in the arguments.</li>
</ul>
<p>The <el-id>fillColour</el-id> and <el-id>strokeColour</el-id> properties may be specified as described under <a href="#Colours">Colours</a>.
Only <el-id>fillColour</el-id> can be specified as <el-id>transparent</el-id>.</p>
<p>Note that the <el-id>height</el-id> and <el-id>width</el-id> properties of an image are also dependent on the dimensions of the original graphic file.</p>

<h3 class="no-TOC" id="displayVectorGraphics">Displaying Vector graphic shapes</h3>
<p>As with <a href="#BlockGraphics">Block</a> graphics, the assembled list of shapes is not displayed until you make a call to procedure <el-method>displayVectorGraphics</el-method> with the list as its argument, thus allowing  you to make multiple changes before display.</p>
<p>And as with using SVG in Html, the shapes are drawn in the order in which they are added to the <el-type>VectorGraphic</el-type> instance.
Later shapes are positioned over earlier ones.</p>

<h3 class="no-TOC">Function dot methods on Vector graphic shapes</h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="asHtml">
  <td><el-method>asHtml</el-method></td>
  <td><el-type>ImageVG</el-type></td>
  <td>none</td>
  <td><el-type>String<el-type></td>
  <td>string containing the Html <el-lit>&lt;img&gt;</el-lit> tag filled with the image's URL and attribute values</td>
 </tr><tr id="asSVG_Circle"><div  id="asSVG"></div>
  <td><el-method>asSVG</el-method></td>
  <td><el-type>CircleVG</el-type></td>
  <td>none</td>
  <td><el-type>String<el-type></td>
  <td>string containing the SVG <el-lit>&lt;circle&gt;</el-lit> tag filled with the circle's attribute values</td>
 </tr><tr id="asSVG_Image">
  <td><el-method>asSVG</el-method></td>
  <td><el-type>ImageVG</el-type></td>
  <td>none</td>
  <td><el-type>String<el-type></td>
  <td>string containing the SVG <el-lit>&lt;image&gt;</el-lit> tag filled with the image's URL and attribute values</td>
 </tr><tr id="asSVG_Line">
  <td><el-method>asSVG</el-method></td>
  <td><el-type>LineVG</el-type></td>
  <td>none</td>
  <td><el-type>String<el-type></td>
  <td>string containing the SVG <el-lit>&lt;line&gt;</el-lit> tag filled with the line's attribute values</td>
 </tr><tr id="asSVG_Ractangle">
  <td><el-method>asSVG</el-method></td>
  <td><el-type>RectangleVG</el-type></td>
  <td>none</td>
  <td><el-type>String<el-type></td>
  <td>string containing the SVG <el-lit>&lt;rectangle&gt;</el-lit> tag filled with the rectangle's attribute values</td>
 </tr>
</table>

<h3 class="no-TOC" id="VG_properties">Properties of Vector graphic shapes</h3>
<p>This table lists the properties of each Vector graphic shape and their default values,
together with the procedure and function methods provided to alter their values in a given instance.</p>
<table class="tableProperty">
 <tr>
  <th colspan="2">Property</th>
  <th colspan="4">Vector graphic shape</th>
  <th colspan="2">Property</th>
  <th colspan="2">Method
 </tr><tr>
  <th>name</th>
  <th>Type</th>
  <th>CircleVG</th>
  <th>ImageVG</th>
  <th>LineVG</th>
  <th>RectangleVG</th>
  <th>description</th>
  <th>default</th>
  <th>procedure</th>
  <th>function</th>
 </tr><tr>
  <td id="alt"><el-id>alt</el-id></td>
  <td><el-type>String</el-type></td>
  <td></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td>alternate textual description (for accessibility)</td>
  <td>empty string</td>
  <td><el-method>setAlt</el-method></td>
  <td><el-method>withAlt</el-method></td>
 </tr><tr>
  <td id="centreX"><el-id>centreX</el-id></td>
  <td><el-type>Float</el-type></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td></td>
  <td>horizontal position of circle centre</td>
  <td>50</td>
  <td><el-method>setCentreX</el-method></td>
  <td><el-method>withCentreX</el-method></td>
 </tr><tr>
  <td id="centreY"><el-id>centreY</el-id></td>
  <td><el-type>Float</el-type></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td></td>
  <td>vertical position of circle centre</td>
  <td>37.5</td>
  <td><el-method>setCentreY</el-method></td>
  <td><el-method>withCentreY</el-method></td>
 </tr><tr>
  <td id="fillColour"><el-id>fillColour</el-id></td>
  <td><el-type>Int</el-type></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td>&#x2714;</td>
  <td>colour to fill the shape</td>
  <td><el-id>yellow</el-id></td>
  <td><el-method>setFillColour</el-method></td>
  <td><el-method>withFillColour</el-method></td>
 </tr><tr>
  <td id="height"><el-id>height</el-id></td>
  <td><el-type>Float</el-type></td>
  <td></td>
  <td>&#x2714;</td>
  <td></td>
  <td>&#x2714;</td>
  <td>height to render the shape or the image</td>
  <td>Image: 13.2<br>Rectangle: 20</td>
  <td><el-method>setHeight</el-method></td>
  <td><el-method>withHeight</el-method></td>
 </tr><tr>
  <td id="radius"><el-id>radius</el-id></td>
  <td><el-type>Float</el-type></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td></td>
  <td>radius of circle</td>
  <td>10</td>
  <td id-"setRadius"><el-method>setRadius</el-method></td>
  <td id="withRadius"><el-method>withRadius</el-method></td>
 </tr><tr>
  <td id="strokeColour"><el-id>strokeColour</el-id></td>
  <td><el-type>Int</el-type></td>
  <td>&#x2714;</td>
  <td></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td>colour of the strokes in the shape</td>
  <td><el-id>black</el-id></td>
  <td><el-method>setStrokeColour</el-method></td>
  <td><el-method>withStrokeColour</el-method></td>
 </tr><tr>
  <td id="strokeWidth"><el-id>strokeWidth</el-id></td>
  <td><el-type>Int</el-type></td>
  <td>&#x2714;</td>
  <td></td>
  <td>&#x2714;</td>
  <td>&#x2714;</td>
  <td>width of the strokes in the shape</td>
  <td>1</td>
  <td><el-method>setStrokeWidth</el-method></td>
  <td><el-method>withStrokeWidth</el-method></td>
 </tr><tr>
  <td id="title"><el-id>title</el-id></td>
  <td><el-type>Float</el-type></td>
  <td></td>
  <td>&#x2714;</td>
  <td></td>
  <td></td>
  <td>title text</td>
  <td>empty string</td>
  <td><el-method>setTitle</el-method></td>
  <td><el-method>withTitle</el-method></td>
 </tr><tr>
  <td id="width"><el-id>width</el-id></td>
  <td><el-type>Float</el-type></td>
  <td></td>
  <td>&#x2714;</td>
  <td></td>
  <td>&#x2714;</td>
  <td>width to render the shape or the image</td>
  <td>Image: 13.2<br>Rectangle: 40</td>
  <td><el-method>setWidth</el-method></td>
  <td><el-method>withWidth</el-method></td>
 </tr><tr>
  <td id="xy_VG"><el-id>x, y</el-id></td>
  <td><el-type>Float</el-type>, <el-type>Float</el-type></td>
  <td></td>
  <td>&#x2714; &#x2714;</td>
  <td></td>
  <td>&#x2714; &#x2714;</td>
  <td>image's <i>x,y</i> position from top left</td>
  <td>Image: 0, 0<br>Rectangle: 10, 10</td>
  <td><el-method>setX</el-method>, <el-method>setY</el-method></td>
  <td><el-method>withX</el-method>, <el-method>withY</el-method></td>
 </tr><tr>
  <td id="x1y1_VG"><el-id>x1, y1</el-id></td>
  <td><el-type>Float</el-type>, <el-type>Float</el-type></td>
  <td></td>
  <td></td>
  <td>&#x2714; &#x2714;</td>
  <td></td>
  <td>line's starting <i>x,y</i> position from top left</td>
  <td>10, 10</td>
  <td><el-method>setX1</el-method>, <el-method>setY1</el-method></td>
  <td><el-method>withX1</el-method>, <el-method>withY1</el-method></td>
 </tr><tr>
  <td id="x2y2_VG"><el-id>x2, y2</el-id></td>
  <td><el-type>Float</el-type>, <el-type>Float</el-type></td>
  <td></td>
  <td></td>
  <td>&#x2714; &#x2714;</td>
  <td></td>
  <td>line's ending <i>x,y</i> position from top left</td>
  <td>70, 40</td>
  <td><el-method>setX2</el-method>, <el-method>setY2</el-method></td>
  <td><el-method>withX2</el-method>, <el-method>withY2</el-method></td>
 </tr>
</table>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using simple SVG graphics</h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To draw a circle with a coloured circumference:</p>
<el-code-block source="VG_circle.elan">
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>vg</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt;()</el-txt></el-field></el-statement>
<el-statement class="ok" id="var6" tabindex="-1"><el-kw>variable </el-kw><el-field id="var7" class="ok" tabindex="-1"><el-txt><el-id>circ</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr8" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>CircleVG</el-type>()<el-kw> with </el-kw><el-id>centreX</el-id><el-kw> set to </el-kw><el-lit>20</el-lit>, <el-id>centreY</el-id><el-kw> set to </el-kw><el-lit>20</el-lit>, <el-id>radius</el-id><el-kw> set to </el-kw><el-lit>5</el-lit>, <el-id>fillColour</el-id><el-kw> set to </el-kw><el-id>green</el-id>, <el-id>strokeColour</el-id><el-kw> set to </el-kw><el-id>red</el-id>, <el-id>strokeWidth</el-id><el-kw> set to </el-kw><el-lit>2</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="call9" tabindex="-1"><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="-1"><el-txt><el-id>vg</el-id>.<el-method><el-method>append</el-method></el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args11" class="optional ok" tabindex="-1"><el-txt><el-id>circ</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-statement class="ok" id="call12" tabindex="-1"><el-kw>call </el-kw><el-field id="ident13" class="ok" tabindex="-1"><el-txt><el-method>displayVectorGraphics</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args14" class="optional ok" tabindex="-1"><el-txt><el-id>vg</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
</el-code-block>
<p><img src="images/VG_circle.png" width="200" height="200" ></p>
<hr>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To draw a circle that changes between red and green every second:</p>
<el-code-block source="VG_2circles.elan">
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>vg</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt;()</el-txt></el-field></el-statement>
<el-statement class="ok" id="var6" tabindex="-1"><el-kw>variable </el-kw><el-field id="var7" class="ok" tabindex="-1"><el-txt><el-id>circ</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr8" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>CircleVG</el-type>()<el-kw> with </el-kw><el-id>centreX</el-id><el-kw> set to </el-kw><el-lit>50</el-lit>, <el-id>centreY</el-id><el-kw> set to </el-kw><el-lit><el-lit>37</el-lit>.5</el-lit>, <el-id>radius</el-id><el-kw> set to </el-kw><el-lit>30</el-lit>, <el-id>fillColour</el-id><el-kw> set to </el-kw><el-id>green</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="call9" tabindex="-1"><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="-1"><el-txt><el-id>vg</el-id>.<el-method><el-method>append</el-method></el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args11" class="optional ok" tabindex="-1"><el-txt><el-id>circ</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-statement class="ok multiline" id="while12" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr14" class="ok" tabindex="-1"><el-txt><el-id>true</el-id></el-txt></el-field>
</el-top>
<el-statement class="ok" id="call15" tabindex="-1"><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="-1"><el-txt><el-method>displayVectorGraphics</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args17" class="optional ok" tabindex="-1"><el-txt><el-id>vg</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-statement class="ok" id="call18" tabindex="-1"><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="-1"><el-txt><el-method>pause</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args20" class="optional ok" tabindex="-1"><el-txt><el-lit>700</el-lit></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-statement class="ok" id="call21" tabindex="-1"><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="-1"><el-txt><el-id>circ</el-id>.<el-method><el-method>setFillColour</el-method></el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args23" class="optional ok" tabindex="-1"><el-txt><el-id>red</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-statement class="ok" id="call24" tabindex="-1"><el-kw>call </el-kw><el-field id="ident25" class="ok" tabindex="-1"><el-txt><el-method>displayVectorGraphics</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args26" class="optional ok" tabindex="-1"><el-txt><el-id>vg</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-statement class="ok" id="call27" tabindex="-1"><el-kw>call </el-kw><el-field id="ident28" class="ok" tabindex="-1"><el-txt><el-method>pause</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args29" class="optional ok" tabindex="-1"><el-txt><el-lit>700</el-lit></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-statement class="ok" id="call30" tabindex="-1"><el-kw>call </el-kw><el-field id="ident31" class="ok" tabindex="-1"><el-txt><el-id>circ</el-id>.<el-method><el-method>setFillColour</el-method></el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args32" class="optional ok" tabindex="-1"><el-txt><el-id>green</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
<el-kw>end while</el-kw>
</el-statement>
</el-code-block>
<hr>
</div></div>

<h3 class="no-TOC" id="RawVG"><el-type>RawVG</el-type></h3>
<p>Strings containing raw SVG tags may be assembled and plotted directly using class <el-type>RawVG</el-type>.
By this means features such as simple SVG animation can be defined.</p>
<ul>
 <li>The raw SVG content should be enclosed in single quotes, since it will usually contain double quote &quot; characters around the SVG attribute values.</li>
 <li>If you want to include <a href="#InterpolatedString">interpolated</a> values, you will have to reverse this convention, enclosing the SVG attribute values
 in single quotes and the whole SVG content string in double quotes, so that the references to named values can be enclosed in curly braces.</li>
 <li>The raw SVG may define multiple shapes.</li>
 <li>Multiple instances of <el-type>RawVG</el-type> may be added to the collection to be displayed, along with instances of other SVG Types;
 hence the need for list-defining square brackets in the parameter of method <el-method>displayVectorGraphics</el-method>.</li>
 <li><el-id>rawSVGcontent</el-id> is the property of class <el-type>RawVG</el-type> that must contain the SVG string.</li> 
 <li>The example is of a simple animation in which the repetition defined in the SVG continues after the program has stopped,
  so you would then use the Clear button to blank the display.</li> 
</ul>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example using <el-type>RawVG</el-type></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To display a repeating movement of a circle:</p>
<el-code-block source="VG_circle.elan">
<el-statement class="ok" id="let19" tabindex="-1"><el-kw>let </el-kw><el-field id="var20" class="ok" tabindex="-1"><el-txt><el-id>movingCircle</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr21" class="ok" tabindex="-1"><el-txt>'<el-lit>&lt;circle cx="50" cy="50" r="50" style="fill:red;"&gt;<br>&lt;animate attributeName="cx" begin="0s" dur="2s" from="50" to="90%" repeatCount="indefinite" /&gt;&lt;/circle&gt;</el-lit>'</el-txt></el-field></el-statement>
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>raw</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>RawVG</el-type>()<el-kw> with </el-kw><br><el-id>rawSVGcontent</el-id><el-kw> set to </el-kw><el-id>movingCircle</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="call12" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident13" class="ok" tabindex="-1"><el-txt><el-method>displayVectorGraphics</el-method></el-txt></el-field><span>(</span><el-field id="args14" class="optional ok" tabindex="-1"><el-txt>[<el-id>raw</el-id>]</el-txt></el-field><span>)</span></el-top></el-statement>
</el-code-block>
<hr>
</div></div>

<h2 id="CombiningGraphics">Combining graphic outputs</h2>
<p>Program outputs, whether text or graphical, can be combined in the display. In particular, Block graphics and text or Html printing can share the display
 along with <i>either</i> Vector graphics <i>or</i> Turtle graphics (but not both).</p>
<p>If you want to share the display in this way, remember that both text and Html print outputs appear sequentially down the display (which can be scrolled), whereas the graphic outputs are positioned in the display using their own absolute coordinate systems.</p>
<p>The order in which the outputs are displayed (and therefore overwrite) is:</p>
<ol>
 <li>Block graphics</li>
 <li>Vector <i>or</i> Turtle graphics</li>
 <li>Printed text <i>or</i> Html</li>
</ol>
<p>So some care is needed to manage the layout in the display.</p>
<p>Note that, while vector graphics are being drawn, printed text that exceeds the height of the display does not scroll until the graphic completes.</p>

<h1 id="InputOutput">Input/output</h1>

<h2 id="KeyboardInput">Keyboard input</h2>
<p>The following system methods are provided for soliciting and retrieving keyboard input. </p>
<table class="tableMethod">
 <tr>
  <th>system<br>method</th>
  <th>argument<br>Types</th>
  <th>return<br>Types</th>
  <th>action</th>
 </tr><tr id="getKey">
  <td><el-method>getKey</el-method></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>returns the last character last pressed on the keyboard during program execution</td>
 </tr><tr id="getKeyWithModifier">
  <td><el-method>getKeyWithModifier</el-method></td>
  <td>(none)</td>
  <td>2-Tuple:<br>(<el-type>String</el-type>, <el-type>String</el-type>)</td>
  <td>returns the last key combination pressed on the keyboard:<br>
      the key pressed and the modifier key's name (if also pressed)</td>
 </tr><tr id="getNumericKey">
  <td><el-method>getNumericKey</el-method></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>returns either the numeric key last pressed or, if the last pressed key was not numeric, then <el-code>"-1"</el-code></td>
 </tr><tr id="inputString">
  <td><el-method>inputString</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>String</el-type></td>
  <td>prints the string as a prompt, and returns the typed input when Enter is pressed</td>
 </tr><tr id="inputStringWithLimits">
  <td><el-method>inputStringWithLimits</el-method></td>
  <td><el-type>String</el-type>, <el-type>Int</el-type>, <el-type>Int</el-type></td>
  <td><el-type>String</el-type></td>
  <td>prints the string as a prompt and returns the typed input when Enter is pressed<br>
  provided the length of the response is within the minimum and maximum limits specified.<br>
  If it is not, the prompt is repeated with the relevant limit displayed</td>
 </tr><tr id="inputStringFromOptions">
  <td><el-method>inputStringFromOptions</el-method></td>
  <td><el-type>String</el-type>, <el-type>List&lt;of String&gt;</el-type></td>
  <td><el-type>String</el-type></td>
  <td>prints the string as a prompt and returns the typed input when Enter is pressed<br>
  provided it is one of the options in the list.<br>
  If it is not, the prompt is repeated with the options displayed</td>
 </tr><tr id="inputInt">
  <td><el-method>inputInt</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is an integer.<br> If it is not, the prompt is repeated with an error message</td>
 </tr><tr id="inputIntBetween">
  <td><el-method>inputIntBetween</el-method></td>
  <td><el-type>String</el-type>, <el-type>Int</el-type>, <el-type>Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is an integer with a value in the (inclusive) range.<br> The first range value must be less than or equal to the second</td>
 </tr><tr id="inputFloat">
  <td><el-method>inputFloat</el-method></td>
  <td><el-type>String</el-type></td>
  <td><el-type>Float</el-type></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is a number.<br> If it is not, the prompt is repeated with an error message</td>
 </tr><tr id="inputFloatBetween">
  <td><el-method>inputFloatBetween</el-method></td>
  <td><el-type>String</el-type>, <el-type>Int</el-type>, <el-type>Int</el-type></td>
  <td><el-type>Float</el-type></td>
  <td>prints the string as a prompt and returns the value of the typed input when Enter is pressed
  provided that it is a number with a value in the (inclusive) range.<br> The first range value must be less than or equal to the second</td>
 </tr><tr id="waitForKey">
  <td><el-method>waitForKey</el-method></td>
  <td>(none)</td>
  <td><el-type>String</el-type></td>
  <td>pauses execution of the program until a key is pressed on the keyboard,<br>
  and returns either a character or the name of a non-character key</td>
 </tr>
</table>

<h3 class="no-TOC"> Reading keys 'on the fly'</h3>
<p>In some applications &ndash; especially in games, for example &ndash; you want the program to react to a key pressed by the user, but without holding up the program to wait for value to be input. </p>
<p>Whether your application makes use of graphics, or uses the display  just for text, reading keystrokes 'on the fly' is done via one of three methods:</p>
<el-code-block>
<el-statement class="ok"><el-kw>let </el-kw><el-field class="ok"><el-txt><el-id>key1</el-id></el-txt></el-field><el-kw> be </el-kw><el-field class="ok"><el-txt><el-method>getKey</el-method>()</el-txt></el-field></el-statement>
<el-statement class="ok"><el-kw>let </el-kw><el-field class="ok"><el-txt><el-id>key2</el-id></el-txt></el-field><el-kw> be </el-kw><el-field class="ok"><el-txt><el-method>getNumericKey</el-method>()</el-txt></el-field></el-statement>
<el-statement class="ok"><el-kw>let </el-kw><el-field class="ok"><el-txt><el-id>key3</el-id>, <el-id>modifier</el-id></el-txt></el-field><el-kw> be </el-kw><el-field class="ok"><el-txt><el-method>getKeyWithModifier</el-method>()</el-txt></el-field></el-statement>
</el-code-block>
<ul>
 <li>When any of these functions is called, the system <i>does not wait for a response</i>, but immediately returns a <el-type>String</el-type>.</li>
 <li><el-method>getKey</el-method> returns a string containing the keyboard character last pressed, possibly shifted, e.g. <el-code>"z"</el-code> or <el-code>"@"</el-code></li> 
 <li><el-method>getNumericKey</el-method> returns a string containing either a digit (<el-code>"0".."9"</el-code>) or, if the last key pressed was not numeric, then <el-code>"-1"</el-code>.
 A digit will be returned if the key pressed was either from the main keyboard, or from the numeric keypad when <b>NumLock</b> is on.</li>
 <li><el-method>getKeyWithModifier</el-method> returns a Tuple of two strings: the key last pressed and the name of <i>one</i> modifier key <el-code>"Shift"</el-code>,
  <el-code>"Ctrl"</el-code> or <el-code>"Alt"</el-code> if simultaneously pressed.
  If no modifier had been pressed, the Tuple's second item will be the empty string.  A few such modified keys will be acted on by the browser and may not then be passed to your program.</li>
 <li>Non-printable keys will also be returned as strings, e.g. <el-code>"Home"</el-code>, <el-code>"End"</el-code>, <el-code>"Delete"</el-code>, <el-code>"Tab"</el-code>,
 <el-code>"Backspace"</el-code>, <el-code>"Enter"</el-code>, <el-code>"Escape"</el-code>,
 <el-code>"ArrowUp"</el-code> etc., function key <el-code>"Fn"</el-code>, <el-code>"AltGraph"</el-code>, <el-code>"Meta"</el-code>, <el-code>"ContextMenu"</el-code>, as well as most others.</li>
 <li>Pressing <i>just</i> control keys <b>Shift</b>, <b>Ctrl</b> (<b>&#x2318; Command</b> under macOS) or <b>Alt</b> keys will not be detected by <el-method>getKey</el-method>.</li>
 <li>If no key has been pressed (since the last time the method was called), it will return the empty string.</li>
 <li>All these  methods are System methods because they have a dependency on the system and so may only be used within a <el-kw>procedure</el-kw> or in <el-kw>main</el-kw>.</li>
 <li>Use the procedure method <el-method>clearKeyBuffer</el-method> if you want to enforce that the user cannot get too far ahead of the program by hitting keys in rapid succession.</li>
 <li>Method <el-method>waitForKey</el-method> waits for a key to be pressed, and returns it.</li>
 <li>Method<el-method>pressAnyKeyToContinue</el-method> gives an optional prompt and is used when you don't need to know which key was pressed.</li>
</ul>
<el-code-block>
<el-statement class="ok"><el-top><el-kw>call </el-kw><el-field class="ok"><el-txt><el-method>pressAnyKeyToContinue</el-method></el-txt></el-field>(<el-field class="optional ok"><el-txt><el-id>true</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok"><el-kw>print </el-kw><el-field class="optional ok"><el-txt>"<el-lit>OK, press A or B</el-lit>"</el-txt></el-field></el-statement>
<el-statement class="ok"><el-kw>let </el-kw><el-field class="ok"><el-txt><el-id>mykey</el-id></el-txt></el-field><el-kw> be </el-kw><el-field class="ok"><el-txt><el-method>waitForKey</el-method>()</el-txt></el-field></el-statement>
<el-statement class="ok"><el-kw>print </el-kw><el-field class="optional ok"><el-txt>"<el-lit>That was </el-lit>{<el-id>mykey</el-id>}"</el-txt></el-field></el-statement>
</el-code-block>

<h2 id="FileInputOutput">Text file input/output</h2>
<p>Reading or writing a text file requires that you <b>open</b> (for reading) or <b>create</b> (for writing) a file using these system methods:</p> 
<table class="tableMethod">
 <tr>
  <th>system<br>method</th>
  <th>argument<br>Types</th>
  <th>return<br>Class</th>
  <th>action</th>
 </tr><tr id="openFileForReading">
  <td><el-method>openFileForReading</el-method></td>
  <td>(none)</td>
  <td><el-type>TextFileReader</el-type></td>
  <td>opens a file system dialog to choose the filename of filetype <el-code>.txt</el-code>  to be read,
  and returns a file handle<br>
  see <a href="#TextFileReader">Reading text files</a></td>
 </tr><tr id="createFileForWriting">
  <td><el-method>createFileForWriting</el-method></td>
  <td>(none)</td>
  <td><el-type>TextFileWriter</el-type></td>
  <td>sets up a buffer for the data to be output, and specifies a filename (or the empty string)
  with or without the default filetype of <el-code>.txt</el-code>, and returns a file handle<br>
  see <a href="#TextFileWriter">Writing text files</a></td>
 </tr>
</table>

<h3 class="no-TOC" id="TextFileReader">Reading text files</h3>
<p>The <el-type>TextFileReader</el-type> class is used to read text data from a file with type extension <el-code>.txt</el-code>.</p>
<p>An instance is created by the system method <el-method>openFileForReading</el-method>.</p>
<p>The available procedure methods are:</p>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>argument<br>Type</th>
  <th>action</th>
 </tr><tr id="readLine">
  <td><el-method>readLine</el-method></td>
  <td>(none)</td>
  <td>reads the next substring from the file that is terminated with a newline</td>
 </tr><tr id="readWholeFile">
  <td><el-method>readWholeFile</el-method></td>
  <td>(none)</td>
  <td>reads the whole file and closes the file</td>
 </tr><tr id="endOfFile">
  <td><el-method>endOfFile</el-method></td>
  <td>(none)</td>
  <td>returns <el-id>true</el-id> after the last line has been read<br>
  &ndash; otherwise <el-id>false</el-id></td>
 </tr><tr id="close">
  <td><el-method>close</el-method></td>
  <td>(none)</td>
  <td>closes the file</td>
 </tr>
</table>
<p>These methods may be used to read a whole file in one go:</p>
<el-code-block source="TextFileReader_1.elan">
  <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>file</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>openFileForReading</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="let6" tabindex="0"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>text</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>readWholeFile</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="print12" tabindex="0"><el-kw>print </el-kw><el-field id="expr13" class="optional ok" tabindex="0"><el-txt><el-id>text</el-id></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-code-block>
<p>or to read a file line by line:</p>
<el-code-block source="TextFileReader_2.elan">
  <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>file</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>openFileForReading</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="var6" tabindex="0"><el-kw>variable </el-kw><el-field id="var7" class="ok" tabindex="0"><el-txt><el-id>lines</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr8" class="ok" tabindex="0"><el-txt><el-kw>empty</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>&gt;</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok multiline" id="while9" tabindex="0">
  <el-top><el-expand>+</el-expand><el-kw>while </el-kw><el-field id="expr11" class="ok" tabindex="0"><el-txt><el-kw>not</el-kw> <el-id>file</el-id>.<el-method>endOfFile</el-method>()</el-txt><el-place><i>condition</i></el-place></el-field></el-top>
  <el-statement class="ok" id="let12" tabindex="0"><el-kw>let </el-kw><el-field id="var13" class="ok" tabindex="0"><el-txt><el-id>line</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>readLine</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
  <el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>lines</el-id>.<el-method>append</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args17" class="optional ok" tabindex="0"><el-txt><el-id>line</el-id></el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
  <el-kw>end while</el-kw>
  </el-statement>
  <el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>close</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args20" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
<li><el-code>openFileForReading</el-code> will present the user with a dialog to select the file.</li>
<li><el-code>readWholeFile</el-code> returns a <el-type>String</el-type> containing every character in the file, without any trimming. It automatically closes the file after the read.</li>
<li><el-code>readLine</el-code> reads as far as the next newline character (<el-lit>\n</el-lit>) and then automatically trims the line to remove any spaces and/or carriage-returns (which some file systems insert after the newline automatically) from the resulting line returned as a <el-type>String</el-type>. If this behaviour is not desired, you can use <el-code>readWholeFile</el-code>, which does no trimming, and then parse the resulting <el-type>String</el-type> into separate lines.</li>
<li>Calling <el-code>file.close</el-code> after reading line by line is strongly recommended to avoid any risk of leaving the file locked. It is not necessary to call it after using <el-code>readWholeFile</el-code> because that method automatically closes the file.</li>
<li>Calling any method on a file that is already closed will result in a runtime error.</li>
</ul>

<h3 class="no-TOC" id="TextFileWriter">Writing text files</h3>
<p>The <el-type>TextFileWriter</el-type> class is used to write textual data to a file.</p>
<p>An instance is created by the system method <el-method>createFileForWriting</el-method>.</p>
<p>The available procedure methods are:</p>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>argument<br>Type</th>
  <th>action</th>
 </tr><tr id="writeLine">
  <td><el-method>writeLine</el-method></td>
  <td><el-type>String</el-type></td>
  <td>writes the string to the buffer</td>
 </tr><tr id="writeWholeFile">
  <td><el-method>writeWholeFile</el-method></td>
  <td><el-type>String</el-type></td>
  <td>writes the string to the buffer and then outputs the buffer to the file system</td>
 </tr><tr id="saveAndClose">
  <td><el-method>saveAndClose</el-method></td>
  <td><el-type>String</el-type></td>
  <td>writes the buffer to the file system</td>
 </tr>
</table>

<p>These methods may be used to write a whole file in one go:</p>
<el-code-block source="TextFileWriter_1.elan">
    <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>f</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>createFileForWriting</el-method>("<el-lit>myFile.txt</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok" id="call6" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="0"><el-txt><el-id>f</el-id>.<el-method>writeWholeFile</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args8" class="optional ok" tabindex="0"><el-txt>"<el-lit>this is\nmyText</el-lit>"</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
</el-code-block>
<p>or to write a file line by line:</p>
<el-code-block source="TextFileWriter_2.elan">
    <el-statement class="ok" id="let3" tabindex="0"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="0"><el-txt><el-id>file</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="0"><el-txt><el-method>createFileForWriting</el-method>("<el-lit>squares.txt</el-lit>")</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
    <el-statement class="ok multiline" id="for6" tabindex="0">
    <el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident8" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr10" class="ok" tabindex="0"><el-txt><el-lit>100</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr11" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
    <el-statement class="ok" id="call12" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident13" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>writeLine</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args14" class="optional ok" tabindex="0"><el-txt>"{<el-id>i</el-id>}<el-lit> </el-lit>{<el-id>i</el-id>*<el-id>i</el-id>}"</el-txt><el-place><i>arguments</i></el-place></el-field>)</el-top></el-statement>
    <el-kw>end for</el-kw>
    </el-statement>
    <el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>saveAndClose</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args17" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
<li><el-code>writeLine</el-code> adds the string it is passed onto the end of any data previously written, with a newline character (<el-lit>\n</el-lit>) automatically appended.</li>
<li>When execution reaches <el-code>saveAndClose</el-code> you will be presented with a dialog to confirm (or edit) the given filename and location where it is to be saved. It is not therefore strictly necessary to specify a filename when creating the file, since it can be specified by the user in the dialog so, in that case, you might put the empty string <el-code>""</el-code> into the parameter of <el-code>createFileForWriting</el-code>.</li>
<li><el-code>writeWholeFile</el-code> puts the string it is given into the file and then automatically saves the file, so the user will be presented with the same dialog as if <el-code>saveAndClose</el-code> had been called.</li>
<li>Calling any method on a file that has already been closed (by calling either <el-code>saveAndClose</el-code> or by <el-code>writeWholeFile</el-code>) will result in a runtime error.</li>
<li>If the user were to hit Cancel on the save dialog, then the program will exit with an error. If you want to guard against this possibility (if, for example, it might mean the loss of important data) then you should perform the save and close within a <el-code>try..catch</el-code> like this:</li>

<el-code-block source="TextFileWriter_3.elan">
<el-statement class="ok multiline" id="try35" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>try </el-kw></el-top>
<el-statement class="ok" id="call15" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="0"><el-txt><el-id>file</el-id>.<el-method>saveAndClose</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args17" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i><i>arguments</i></i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok multiline outdent" id="catch37" tabindex="0"><el-top><el-expand>+</el-expand><el-kw>catch exception in </el-kw><el-field id="ident39" class="ok" tabindex="0"><el-txt><el-id>e</el-id></el-txt><el-place><i>variableName</i></el-place></el-field></el-top>
<el-statement class="ok" id="print47" tabindex="0"><el-kw>print </el-kw><el-field id="expr48" class="optional ok" tabindex="0"><el-txt>"<el-lit>File save cancelled</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
</el-statement>
<el-kw>end try</el-kw>
</el-statement>
</el-code-block>
<p>or you could make the code offer the user options: to save again, or to continue without saving.</p>
</ul>

<h2 id="RenderHtml">Rendering Html in the display</h2>
<p>If you embed Html code in a string and then attempt to print it, you will see the string displayed literally: the Html tags
    will not be recognised. This is for security reasons. However, it <i>is</i> possible to display formatted Html in the <b>display</b>.
    The following code:</p>

<el-code-block source="Html_1.elan">
    <el-statement class="ok" id="call5" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-method>displayHtml</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args7" class="optional ok" tabindex="0"><el-txt>"<el-lit>&lt;h1 style='color: blue;'&gt;A heading&lt;/h1&gt;&lt;p&gt;some text&lt;/p&gt;</el-lit>"</el-txt><el-place><i>html</i></el-place></el-field>)</el-top></el-statement>
</el-code-block>

<p>will produce:</p>
<img src="images/Html_1.png" width="250" height="200">

<p>This Html forms another 'layer' in the IDE's display pane. Any plain text that you print
    (using <el-kw>print</el-kw> or any of the <el-method>print..</el-method> procedures)
    will be overlaid on top of this.</p>

<p>You can clear just the Html layer in the display using the procedure <a href="#clearHtml"><el-method>clearHtml</el-method></a>.</p>

<p>For specifying style or other attributes within Html tags, the attribute values should be enclosed in single quotation marks ' as shown above.
    Html will recognise single or double quotation marks, but entering double quotation marks would terminate the Elan string.
    Alternatively, you could use the constant <el-id>quotes</el-id> within curly braces as an interpolated field.</p>

<h3 class="no-TOC">Using an embedded CSS stylesheet</h3>
<p>You can also specify a &lt;style&gt; tag at the start of your Html string, to apply to the whole Html being displayed. In this case you would put
the style definition into a named value as a literal but enclosed in <i>single</i> quotes, for example:</p>
<el-code-block source="Html_2.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>style</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>'<el-lit>&lt;style&gt; h1 { color: Red; font-size: 24pt; } p { font-family: Serif; } &lt;/style&gt;</el-lit>'</el-txt></el-field></el-statement>
<el-statement class="ok" id="call6" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-method>displayHtml</el-method></el-txt></el-field>(<el-field id="args8" class="optional ok" tabindex="-1"><el-txt>"{<el-id>style</el-id>}<el-lit>&lt;h1&gt;New heading&lt;/h1&gt;&lt;p&gt;some new text&lt;/p&gt;</el-lit>"</el-txt></el-field>)</el-top></el-statement>
</el-code-block>

<p>will produce:</p>
<img src="images/Html_2.png" width="275" height="200">

<p>The &lt;style&gt; string is displayed for editing like this:</p>
<el-code-block source="Html_3.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>style</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="selected focused ok" tabindex="-1"><el-txt><input spellcheck="false" data-cursorstart="91" data-cursorend="91" size="90" style="width: 91ch" value="'&lt;style&gt; h1 { color: Red; font-size: 24pt; }  p { font-family: Serif; }  &lt;/style&gt;'" tabindex="-1"></el-txt></el-field></el-statement>
</el-code-block>

<p>But by inserting <el-lit>\n</el-lit> newlines thus:</p>
<el-code-block source="Html_3.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>style</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="selected focused ok" tabindex="-1"><el-txt><input spellcheck="false" data-cursorstart="98" data-cursorend="98" size="97" style="width: 98ch" value="'&lt;style&gt;\n h1 {\n  color: Red;\n  font-size: 24pt;\n }\n p {\n  font-family: Serif;\n }\n&lt;/style&gt;'" tabindex="-1"></el-txt></el-field></el-statement>
</el-code-block>

<p>the string can be shown folded and indented when not being edited: </p>
<el-code-block source="Html_4.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>style</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>'<el-lit>&lt;style&gt;<br>h1 {<br> color: Red;<br> font-size: 24pt;<br>}<br>p {<br> font-family: Serif;<br>}<br>&lt;/style&gt;</el-lit>'</el-txt></el-field></el-statement>
</el-code-block>

<h2 id="displayImageURL">Displaying images from URLs</h2>

<p>An image that can be retrieved with an http or https URL may be sent to the display, though note that other URI schemes, such as in <el-code>file://host/path</el-code> to access an image from your local file system, are not supported. Here are three techniques:

<ul>
 <li>put the Html <el-lit>&lt;img&gt;</el-lit> tag into a string and then call the <el-method>displayHtml</el-method> method on it, thus:
<el-code-block source="Html_4.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>pic</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>"<el-lit>&lt;img src='https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_%2828225976491%29.jpg'<br> width='400' height='200'<br> title='shark' alt='shark'&gt;</el-lit>"</el-txt></el-field></el-statement>
<el-statement class="ok" id="call6" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-method>displayHtml</el-method></el-txt></el-field>(<el-field id="args8" class="optional ok" tabindex="-1"><el-txt><el-id>pic</el-id></el-txt></el-field>)</el-top></el-statement>
</el-code-block>
 <h5 class="no-TOC">Notes</h5>
  <ul>
   <li>The usual <b>&lt;img&gt;</b> tag attributes are respected, though <el-id>alt</el-id> does not give the expected tooltip when hovering over the image,
   and <el-id>title</el-id> is only a descriptive comment.</li>
   <li>The attributes can be shown listed vertically by inserting <el-lit>\n</el-lit> to signify a newline, as is done here before <el-id>width</el-id> and before <el-id>title</el-id>.</li>
  </ul>

 <li>put the URL into a Vector Graphics <el-type>ImageVG</el-type> definition: and then call the <el-method>displayVectorGraphics</el-method> method on it, thus:
<el-code-block source="imageVG.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>pic</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>ImageVG</el-type>('<el-lit>https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_(28225976491).jpg</el-lit>')<el-kw> with </el-kw><br><el-id>width</el-id><el-kw> set to </el-kw><el-lit>400</el-lit>, <br><el-id>height</el-id><el-kw> set to </el-kw><el-lit>200</el-lit>, <br><el-id>alt</el-id><el-kw> set to </el-kw>"<el-lit>Shark</el-lit>"</el-txt></el-field></el-statement>
<el-statement class="ok" id="call11" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident12" class="ok" tabindex="-1"><el-txt><el-method>displayVectorGraphics</el-method></el-txt></el-field>(<el-field id="args13" class="optional ok" tabindex="-1"><el-txt>[<el-id>pic</el-id>]</el-txt></el-field>)</el-top></el-statement>
</el-code-block>
 <h5 class="no-TOC">Notes</h5>
  <ul>
   <li>Vector graphic image properties include <el-id>height</el-id>, <el-id>width</el-id> and <el-id>alt</el-id>.</li>
   <li>Other vector graphic image properties such as <i>x,y</i> position can be added into the <el-kw>with</el-kw> clause.</li>
  </ul>

 <li>put the URL into an <el-kw>image</el-kw> definition:

<el-code-block source="image_1.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>pic</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="selected focused ok" tabindex="-1"><el-txt><input spellcheck="false" data-cursorstart="108" data-cursorend="108" size="107" style="width: 108ch" value="image https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_(28225976491).jpg with alt set to &quot;Shark&quot;" tabindex="-1"></el-txt></el-field></el-statement>
</el-code-block>

<div id="image"></div><p>On moving the editing focus away from the <el-kw>image</el-kw> field, the instruction shows a thumbnail of the image in the code.</p>

<p>Then convert it with method <el-method>asHtml</el-method> so that you can display it with the <el-method>displayHtml</el-method> method thus:</p>

<el-code-block source="image_2.elan">
<el-statement class="ok" id="var9" tabindex="-1"><el-kw>variable </el-kw><el-field id="var10" class="ok" tabindex="-1"><el-txt><el-id>vg</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr11" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>VectorGraphic</el-type>&gt;()</el-txt></el-field></el-statement>
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>pic</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt><img src="https://upload.wikimedia.org/wikipedia/commons/0/08/Corl0207_(28225976491).jpg"><el-kw> with </el-kw><br><el-id>width</el-id><el-kw> set to </el-kw><el-lit>304</el-lit>, <br><el-id>height</el-id><el-kw> set to </el-kw><el-lit>139</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="call13" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident14" class="ok" tabindex="-1"><el-txt><el-id>vg</el-id>.<el-method><el-method>append</el-method></el-method></el-txt></el-field>(<el-field id="args15" class="optional ok" tabindex="-1"><el-txt><el-id>pic</el-id></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call16" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident17" class="ok" tabindex="-1"><el-txt><el-method>displayHtml</el-method></el-txt></el-field>(<el-field id="args18" class="optional ok" tabindex="-1"><el-txt><el-id>pic</el-id>.<el-method>asHtml</el-method>()</el-txt></el-field>)</el-top></el-statement>
</el-code-block>
 <h5 class="no-TOC">Notes</h5>
  <ul>
   <li>Vector graphic image properties include <el-id>height</el-id>, <el-id>width</el-id> and <el-id>alt</el-id> that match the similar Html attributes and and have the same effect.</li>
   <li>Other vector graphic image properties such as <i>x,y</i> position can be added into the <el-kw>with</el-kw> clause.</li>
   <li>In this example, <el-id>pic</el-id> will be of type <el-type>ImageVG</el-type> which means that instead of displaying
  it as Html it may be displayed as vector graphics (like in the earlier example).</li>
  </ul>
 </li>
</ul>

<div id="Sound"></div>
<h2 id="tone">Sound output</h2>

<p>The <el-method>tone</el-method> procedure allows the generation of a simple tone. It requires three arguments to be provided:</p>
<ul>
 <li>the duration of the generated tone specified in milliseconds (<el-type>Int</el-type>)</li>
 <li>the frequency of the generated tone in Hertz (<el-type>Int</el-type>)</li>
 <li>the volume of the tone (<el-type>Float</el-type>)</li>
</ul>
<p>Note that the volume parameter is only relative in that the actual volume will be modified by the various sound settings on the output device, and may even be muted.</p>
<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example using <el-method>tone</el-method></h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; An example that plays a C major scale first ascending then descending:</p>
<el-code-block source="sound.elan">
</el-code-block>
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>scale</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>[<el-lit>262</el-lit>, <el-lit>294</el-lit>, <el-lit>330</el-lit>, <el-lit>349</el-lit>, <el-lit>392</el-lit>, <el-lit>440</el-lit>, <el-lit>494</el-lit>, <el-lit>523</el-lit>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="let6" tabindex="-1"><el-kw>let </el-kw><el-field id="var7" class="ok" tabindex="-1"><el-txt><el-id>scaleL</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr8" class="ok" tabindex="-1"><el-txt><el-id>scale</el-id>.<el-method>length</el-method>()</el-txt></el-field></el-statement>
<el-statement class="ok" id="let9" tabindex="-1"><el-kw>let </el-kw><el-field id="var10" class="ok" tabindex="-1"><el-txt><el-id>quaver</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr11" class="ok" tabindex="-1"><el-txt><el-lit>250</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="let12" tabindex="-1"><el-kw>let </el-kw><el-field id="var13" class="ok" tabindex="-1"><el-txt><el-id>volume</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr14" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>1</el-lit>.5</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok multiline" id="for15" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident17" class="ok" tabindex="-1"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> from </el-kw><el-field id="expr18" class="ok" tabindex="-1"><el-txt><el-lit>0</el-lit></el-txt></el-field><el-kw> to </el-kw><el-field id="expr19" class="ok" tabindex="-1"><el-txt><el-id>scaleL</el-id> - <el-lit>1</el-lit></el-txt></el-field><el-kw> step </el-kw><el-field id="expr20" class="ok" tabindex="-1"><el-txt><el-lit>1</el-lit></el-txt></el-field></el-top>
<el-statement class="ok" id="call21" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="-1"><el-txt><el-method>tone</el-method></el-txt></el-field>(<el-field id="args23" class="optional ok" tabindex="-1"><el-txt><el-id>quaver</el-id>, <el-id>scale</el-id>[<el-id>i</el-id>], <el-id>volume</el-id></el-txt></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
<el-statement class="ok" id="call24" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident25" class="ok" tabindex="-1"><el-txt><el-method>pause</el-method></el-txt></el-field>(<el-field id="args26" class="optional ok" tabindex="-1"><el-txt><el-lit>1000</el-lit></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok multiline" id="for27" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="-1"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="-1"><el-txt><el-lit>0</el-lit></el-txt></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="-1"><el-txt><el-id>scaleL</el-id> - <el-lit>1</el-lit></el-txt></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="-1"><el-txt><el-lit>1</el-lit></el-txt></el-field></el-top>
<el-statement class="ok" id="call33" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident34" class="ok" tabindex="-1"><el-txt><el-method>tone</el-method></el-txt></el-field>(<el-field id="args35" class="optional ok" tabindex="-1"><el-txt><el-id>quaver</el-id>, <el-id>scale</el-id>[<el-id>scaleL</el-id> - <el-lit>1</el-lit> - <el-id>i</el-id>], <el-id>volume</el-id></el-txt></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
<hr>
</div></div>

<h1>Other Types</h1>

<h2 id="Random"><el-type>Random</el-type></h2>
<h3 class="no-TOC">Generating random numbers within a function</h3>
<p>It is <i>not</i> possible to use the system methods <el-method>random()</el-method> or <el-method>randomInt()</el-method> within a function because they create unseen side effects. You <i>may</i> use those system methods outside the function and pass the resulting random number (as an <el-type>Int</el-type> or a <el-type>Float</el-type>) as an argument <i>into </i>a function.</p>
<p>It is, however, possible to create and use random numbers within a function, but it requires a different approach and is a little more complex. You use the special Type <el-type>Random</el-type>. (Note the upper case <el-code>R</el-code> required for a Type name).</p>
<p>You start by getting a seed random number in your <el-method>main</el-method> or in a <el-method>procedure</el-method> using method <el-method>initialiseFromClock</el-method>:</p>

<el-code-block source="func_random.elan">
<el-statement class="ok"><el-kw>variable </el-kw><el-field class="ok"><el-txt><el-id>rnd</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field class="ok"><el-txt><el-kw>new</el-kw> <el-type>Random</el-type>()</el-txt></el-field></el-statement>
<el-statement class="ok"><el-top><el-kw>call </el-kw><el-field class="ok"><el-txt><el-id>rnd</el-id>.<el-method>initialiseFromClock</el-method></el-txt></el-field>(<el-field class="empty optional ok"><el-txt></el-txt></el-field>)</el-top></el-statement>
</el-code-block>

<p>Then, in a function, you apply the dot method <el-method>next</el-method> or <el-method>nextInt</el-method> to the <el-type>Random</el-type> passed in, which returns a 2-Tuple containing both a new random value and a new instance of Type <el-type>Random</el-type>.
If you need another random value, you use the returned <el-type>Random</el-type> on which to apply the dot method again.</p>
<p>Avoid applying <el-method>next</el-method> or <el-method>nextInt</el-method> more than once on the same <el-type>Random</el-type> because they will return the same values.</p>
<p>If the <el-method>initialiseFromClock</el-method> call is absent, the program will still generate a sequence of random values, <i>but the sequence will be exactly the same each time you run the program.</i> Initialising from the clock ensures that you get a different sequence each run. Using <el-type>Random</el-type> <i>without</i> so initialising, however, can be extremely useful for testing purposes since the results are repeatable.</p>

<h3 class="no-TOC" id="Random_procedures">Procedure method for random seed</h3>
<table class="tableMethod">
 <tr>
  <th>procedure<br>method</th>
  <th>argument<br>Type</th>
  <th>action</th>
 </tr><tr id="initialiseFromClock">
  <td><el-method>initialiseFromClock</el-method></td>
  <td>(none)</td>
  <td>uses the system clock to provide a seed<br>from which to generate fresh random values</td>
 </tr>
</table>

<h3 class="no-TOC" id="Random_functions">Function dot methods on a <el-type>Random</el-type></h3>
<table class="tableMethod">
 <tr>
  <th>function<br>dot method</th>
  <th>on<br>Type</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="next">
  <td><el-method>next</el-method></td>
  <td><el-type>Random</el-type></td>
  <td><el-type>Float, Float</el-type></td>
  <td><el-code>Tuple</el-code> (<el-type>Float, Random</el-type>)</td>
  <td>random <el-type>Float</el-type> value in the range of the arguments, and<br>new instance of <el-type>Random</el-type> for subsequent use</td>
 </tr><tr id="nextInt">
  <td><el-method>nextInt</el-method></td>
  <td><el-type>Random</el-type></td>
  <td><el-type>Int, Int</el-type></td>
  <td><el-code>tuple</el-code>(<el-type>Int, Random</el-type>)</td>
  <td>random <el-type>Int</el-type> value in the range of the arguments, and<br>new instance of <el-type>Random</el-type> for subsequent use</td>
 </tr>
</table>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example using <el-type>Random</el-type></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To roll a dice in a function:</p>

<el-code-block source="func_random.elan">
<main class="ok multiline">
<el-top><el-kw>main</el-kw></el-top>
<el-statement class="ok"><el-kw>variable </el-kw><el-field class="ok"><el-txt><el-id>rnd</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field class="ok"><el-txt><el-kw>new</el-kw> <el-type>Random</el-type>()</el-txt></el-field></el-statement>
<el-statement class="ok"><el-top><el-kw>call </el-kw><el-field class="ok"><el-txt><el-id>rnd</el-id>.<el-method>initialiseFromClock</el-method></el-txt></el-field>(<el-field class="empty optional ok"><el-txt></el-txt></el-field>)</el-top></el-statement>
<el-statement class="ok"><el-kw>variable </el-kw><el-field class="ok"><el-txt><el-id>dice</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field class="ok"><el-txt><el-lit>0</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok multiline">
<el-top><el-kw>for </el-kw><el-field class="ok"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> from </el-kw><el-field class="ok"><el-txt><el-lit>1</el-lit></el-txt></el-field><el-kw> to </el-kw><el-field class="ok"><el-txt><el-lit>10</el-lit></el-txt></el-field><el-kw> step </el-kw><el-field class="ok"><el-txt><el-lit>1</el-lit></el-txt></el-field></el-top>
<el-statement class="ok"><el-kw>set </el-kw><el-field class="ok"><el-txt><el-id>dice</el-id>, <el-id>rnd</el-id></el-txt></el-field><el-kw> to </el-kw><el-field class="ok"><el-txt><el-method>rollDice</el-method>(<el-id>rnd</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok"><el-kw>print </el-kw><el-field class="optional ok"><el-txt><el-id>dice</el-id></el-txt></el-field></el-statement>
<el-kw>end for</el-kw>
</el-statement>
<el-kw>end main</el-kw>
</main>
<el-func class="ok multiline">
<el-top><el-kw>function </el-kw><el-method><el-field class="ok"><el-txt>rollDice</el-txt></el-field></el-method>(<el-field class="optional ok"><el-txt><el-id>rnd</el-id> <el-kw>as</el-kw> <el-type>Random</el-type></el-txt></el-field>)<el-kw> returns </el-kw><el-field class="ok"><el-txt>(<el-type>Int</el-type>, <el-type>Random</el-type>)</el-txt></el-field></el-top>
<el-statement class="ok"><el-kw>return </el-kw><el-field class="ok"><el-txt><el-id>rnd</el-id>.<el-method>nextInt</el-method>(<el-lit>1</el-lit>, <el-lit>6</el-lit>)</el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>
<hr>
</div></div>

<h2 id="Func">Func</h2>
<p>A function may be passed as an argument into another function (or a procedure), or returned as the result of calling another function.
This pattern is known as <b>Higher-order Function (HoF)</b>, and is a key idea in Functional Programming.</p>
<p>To define a function that takes in another function as a parameter, or returns a function, you need to specify the Type of the function,
just as you would specify the Type of every parameter and the return Type for the function. </p>

<h3 class="no-TOC">Type name</h3>
<p>The Type of any function starts with the word <el-type>Func</el-type> followed by angle brackets defining the Type of each parameter,
    then a 'fat arrow' =&gt; and the return Type for that function. This <el-kw>property</el-kw> definition shows the syntax:</p>

<el-code-block source="functionChars.elan">
<el-prop class="ok" id="prop39" tabindex="-1"><el-kw>property </el-kw><el-field id="ident40" class="ok" tabindex="-1"><el-txt><el-id>matchAt</el-id></el-txt></el-field><el-kw> as </el-kw><el-field id="type41" class="ok" tabindex="-1"><el-txt><el-type>Func</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>String</el-type>, <el-type>Int</el-type> =&gt; <el-type>Boolean</el-type>&gt;</el-txt></el-field></el-prop>
</el-code-block>

<p>This example defines the Type for a function that defines three parameters of Type <el-type>String</el-type>, <el-type>String</el-type>, and <el-type>Int</el-type> respectively, and returns a <el-type>Boolean</el-type> value. This Type would match that of a function definition like this:</p>

<el-code-block source="functionChars.elan">
<el-func class="ok multiline" id="func1" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident3" class="ok" tabindex="-1"><el-txt><el-method>matchAt</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params4" class="optional ok" tabindex="-1"><el-txt><el-id>a</el-id> <el-kw>as</el-kw> <el-type>String</el-type>, <el-id>b</el-id> <el-kw>as</el-kw> <el-type>String</el-type>, <el-id>p</el-id> <el-kw>as</el-kw> <el-type>Int</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type5" class="ok" tabindex="-1"><el-txt><el-type>Boolean</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="return6" tabindex="-1"><el-kw>return </el-kw><el-field id="expr7" class="ok" tabindex="-1"><el-txt><el-kw>if </el-kw><el-id>a</el-id>[<el-id>p</el-id>]<el-kw> is </el-kw><el-id>b</el-id>[<el-id>p</el-id>]<el-kw><br>then </el-kw><el-id>true</el-id><el-kw><br>else </el-kw><el-id>false</el-id></el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h1 id="Constants">System constants</h1>

<p>System constants are unlike values that you define in your <a href="LangRef.html#constant">program <el-kw>constant</el-kw></a>s,
 in that they are mutable named values &mdash; though it would be poor practice to change them.</p>

<h2 id="StringConstants">String constants</h2>
<p>These constants are of use when the characters { } and " are required in a string delimited by <i>double quotes</i>.
Within a string delimited by <i>single quotes</i>, those literal characters can also be used.</p>
<table class="tableType">
 <tr>
  <th>name</th><th>Type</th><th >value</th>
 </tr><tr id="openBrace">
  <td><el-id>openBrace</el-id></td>
  <td><el-type>String</el-type></td>
  <td><el-code>&nbsp; { </el-code></td>
 </tr><tr id="closeBrace">
  <td><el-id>closeBrace</el-id></td>
  <td><el-type>String</el-type></td>
  <td><el-code>&nbsp; } </el-code></td>
 </tr><tr id="quotes">
  <td><el-id>quotes</el-id></td>
  <td><el-type>String</el-type></td>
  <td><el-code>&nbsp; &quot; </el-code></td>
 </tr>
</table>

<h2 id="BooleanConstants">Boolean constants</h2>
<table class="tableType">
 <tr>
  <th>name</th><th>Type</th><th >value</th>
 </tr><tr id="true">
  <td><el-id>true</el-id></td>
  <td><el-type>Boolean</el-type></td>
  <td><a href="#Boolean"><el-id>true</el-id></a></td>
 </tr><tr id="false">
  <td><el-id>false</el-id></td>
  <td><el-type>Boolean</el-type></td>
  <td><a href="#Boolean"><el-kw>false</el-kw></a></td>
 </tr>
</table>

<h2 id="MathsConstant">Maths constant</h2>
<table class="tableType">
 <tr><th>name</th><th>Type</th><th>value</th></tr>
<tr id="pi">
  <td><el-id>pi</el-id></td>
  <td><el-type>Float</el-type></td>
  <td>&#x1d70b = 3.141592653589793..</td>
 </tr>
</table>

<h2 id="Colours">Colour constants</h2>
<table class="tableColours">
<tr><th>colour</th><th></th><th>decimal</th><th>decimal<br></th><th>hexadecimal</th></tr>
<tr><th>name</th><th></th><th>integer</th><th style="font-family:monospace;">&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;&nbsp;&nbsp;&nbsp;B</th><th style="font-family:monospace;">&nbsp;0xrrggbb</th></tr>
    <tr><td><el-id>black</el-id> </td><td style="color:#000000">&#x25fc;</td><td>0</td><td>&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0x000000</el-code></td></tr>
    <tr><td><el-id>white</el-id> </td><td style="color:#ffffff">&#x25fc;</td><td>16777215</td><td>&nbsp;255&nbsp;&nbsp;255&nbsp;&nbsp;255</td><td><el-code>0xffffff</el-code></td></tr>
    <tr><td><el-id>red</el-id>   </td><td style="color:#ff0000">&#x25fc;</td><td>16711680</td><td>&nbsp;255&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0xff0000</el-code></td></tr>
    <tr><td><el-id>green</el-id> </td><td style="color:#008000">&#x25fc;</td><td>32768</td><td>&nbsp;&nbsp;0&nbsp;&nbsp;128&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0x008000</el-code></td></tr>
    <tr><td><el-id>blue</el-id>  </td><td style="color:#0000ff">&#x25fc;</td><td>255</td><td>&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;255</td><td><el-code>0x0000ff</el-code></td></tr>
    <tr><td><el-id>yellow</el-id></td><td style="color:#ffff00">&#x25fc;</td><td>16776960</td><td>&nbsp;255&nbsp;&nbsp;255&nbsp;&nbsp;&nbsp;&nbsp;0</td><td><el-code>0xffff00</el-code></td></tr>
    <tr><td><el-id>brown</el-id> </td><td style="color:#a52a2a">&#x25fc;</td><td>10824234</td><td>&nbsp;165&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;42</td><td><el-code>0xa52a2a</el-code></td></tr>
    <tr><td><el-id>grey</el-id>  </td><td style="color:#808080">&#x25fc;</td><td>8421504</td><td>&nbsp;128&nbsp;&nbsp;128&nbsp;&nbsp;128</td><td><el-code>0x808080</el-code></td></tr>
    <tr><td><el-id>transparent</el-id> </td><td style="color:#000000">&#x25fb;</td><td>-1</td><td>n/a</td><td>n/a</td></tr>
</table>
<p>A colour is specified as an <el-type>Int</el-type> value using one of these methods:</p>
<ul>
 <li>the limited colours defined as library constants as in the above table.</li>
 <li>an integer in the decimal range 0 (<el-id>black</el-id>) to 2<sup>24-1</sup> (<el-id>white</el-id>).</li>
 <li>a six digit hexadecimal value in the range <el-code>0x000000</el-code> &ndash; <el-code>0xffffff</el-code>
    using the same 'RGB' format as used in Html style, for example <el-code>0xff0000</el-code> for red.</li>
 <li id="transparent"><el-id>transparent</el-id> is only used for filling <a href="#VectorGraphics">vector graphics</a> shapes. 
</ul>

<div id="LibraryProcedures"></div>
<h1 id="StandaloneFunctions">Standalone functions</h1>
    <p>Standalone library functions always return a value and are therefore used in contexts that expect a value, such as in the right-hand side of a <el-kw>variable</el-kw> declaration or a <el-kw>set</el-kw> assignment, either on their own or within a more complex expression. All standalone library functions require at least one argument to be passed in round brackets, corresponding to the parameters defined for that function.</p>

<h2 id="unicode">unicode</h2>
<p>Function <el-method>unicode</el-method> converts a Unicode (codepoint) value expressed as an integer value in decimal or hexadecimal notation, or as any expression evaluating to an <el-type>Int</el-type>, into a string of a single character. For example:</p>
<el-code-block source="unicode_hearts.elan">
<el-func class="ok multiline" id="func3">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-method><el-field id="ident5" class="ok" tabindex="0"><el-txt>hearts</el-txt><el-place><i>name</i></el-place></el-field></el-method>(<el-field id="params6" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>parameter definitions</i></el-place></el-field>)<el-kw> returns </el-kw><el-field id="type7" class="ok" tabindex="0"><el-txt><el-type>String</el-type></el-txt><el-place><i>Type</i></el-place></el-field></el-top>
<el-statement class="ok" id="return8" tabindex="0"><el-kw>return </el-kw><el-field id="expr9" class="ok" tabindex="0"><el-txt><el-method>unicode</el-method>(<el-lit>0x2665</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h2 id="parseAs">parseAsInt and parseAsFloat</h2>

<p>Function <el-method>parseAsInt</el-method> attempts to parse the input <el-type>String</el-type> as an <el-type>Int</el-type>, and returns a <a href="#Tuple">2-Tuple</a>, the first value of which is <el-type>Boolean</el-type>, with <el-id>true</el-id> indicating whether or not the parse has succeeded, and the second value being the resulting <el-type>Int</el-type>.
        <el-method>parseAsFloat</el-method> does the equivalent for floating point. Operation is illustrated by these tests: </p>
<el-code-block source="test_parse.elan">
<el-test class="ok multiline" id="test88" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment90" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="assert91" tabindex="0"><el-kw>assert </el-kw><el-field id="text92" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>31</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr93" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>31</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert94" tabindex="0"><el-kw>assert </el-kw><el-field id="text95" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>0</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr96" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert97" tabindex="0"><el-kw>assert </el-kw><el-field id="text98" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>thirty one</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr99" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>false</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert100" tabindex="0"><el-kw>assert </el-kw><el-field id="text101" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>("<el-lit>3.1</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr102" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>false</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert103" tabindex="0"><el-kw>assert </el-kw><el-field id="text104" class="ok" tabindex="0"><el-txt><el-method>parseAsFloat</el-method>("<el-lit>31</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr105" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>31</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert106" tabindex="0"><el-kw>assert </el-kw><el-field id="text107" class="ok" tabindex="0"><el-txt><el-method>parseAsFloat</el-method>("<el-lit>0</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr108" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit>0</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert109" tabindex="0"><el-kw>assert </el-kw><el-field id="text110" class="ok" tabindex="0"><el-txt><el-method>parseAsFloat</el-method>("<el-lit>3.1</el-lit>")</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr111" class="ok" tabindex="0"><el-txt><el-kw>tuple</el-kw>(<el-id>true</el-id>, <el-lit><el-lit>3</el-lit>.1</el-lit>)</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h4 class="no-TOC">Notes</h4>
<ul>
    <li>Any string that parses as an <el-type>Int</el-type> will also parse as a <el-type>Float</el-type>.</li>
    <li>If the parse fails, the second value will become zero, so you should always check the first value to see if the second value is a correct parse or just the default.</li>
    <li> You can '<a href="#Tuple">deconstruct</a>' the Tuple into two variables:
<el-code-block source="parse_string.elan">
<el-statement class="ok" id="var5" tabindex="0"><el-kw>variable </el-kw><el-field id="var6" class="ok" tabindex="0"><el-txt><el-id>success</el-id>, <el-id>parsedValue</el-id></el-txt><el-place><i>name</i></el-place><el-compl></el-compl><el-msg></el-msg></el-field><el-kw> set to </el-kw><el-field id="expr7" class="ok" tabindex="0"><el-txt><el-method>parseAsInt</el-method>(<el-id>myString</el-id>)</el-txt></el-field></el-statement>
   </el-code-block></li>
    <li>One use of these parsing methods is for validating user input, but note that an easier way to do this is to use the various <a href="#SystemMethods">input methods</a>.</li>
</ul>
<div id="floor"></div>
<div id="ceiling"></div>
<div id="round"></div>
<div id="isNaN"></div>
<div id="isInfinite"></div>
<h2><el-method>floor</el-method>, <el-method>ceiling</el-method>, <el-method>round</el-method>, <el-method>isNaN</el-method>, <el-method>isInfinite</el-method></h2>
<p> All of these functions are called as 'dot methods' on a numeric value  of Type <el-type>Float</el-type> or <el-type>Int</el-type>.
<el-method>NaN</el-method> is short for 'Not A (Real) Number'. Their use is illustrated with the following tests:</p>

<el-code-block source="test_floor.elan">
<el-test class="ok multiline" id="test1" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="-1"><el-txt>&nbsp;</el-txt></el-field></el-top>
<el-statement class="ok" id="let19" tabindex="-1"><el-kw>let </el-kw><el-field id="var20" class="ok" tabindex="-1"><el-txt><el-id>p</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr21" class="ok" tabindex="-1"><el-txt><el-id>pi</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="let11" tabindex="-1"><el-kw>let </el-kw><el-field id="var12" class="ok" tabindex="-1"><el-txt><el-id>mp</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr13" class="ok" tabindex="-1"><el-txt>-<el-id>pi</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="assert4" tabindex="-1"><el-kw>assert </el-kw><el-field id="text5" class="ok" tabindex="-1"><el-txt><el-id>p</el-id>.<el-method>floor</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr6" class="ok" tabindex="-1"><el-txt><el-lit>3</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert50" tabindex="-1"><el-kw>assert </el-kw><el-field id="text51" class="ok" tabindex="-1"><el-txt><el-id>mp</el-id>.<el-method>floor</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr52" class="ok" tabindex="-1"><el-txt>-<el-lit>4</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert41" tabindex="-1"><el-kw>assert </el-kw><el-field id="text42" class="ok" tabindex="-1"><el-txt><el-id>p</el-id>.<el-method>ceiling</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr43" class="ok" tabindex="-1"><el-txt><el-lit>4</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert45" tabindex="-1"><el-kw>assert </el-kw><el-field id="text46" class="ok" tabindex="-1"><el-txt><el-id>mp</el-id>.<el-method>ceiling</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr47" class="ok" tabindex="-1"><el-txt>-<el-lit>3</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert23" tabindex="-1"><el-kw>assert </el-kw><el-field id="text24" class="ok" tabindex="-1"><el-txt><el-id>p</el-id>.<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr25" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>3</el-lit>.142</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert54" tabindex="-1"><el-kw>assert </el-kw><el-field id="text55" class="ok" tabindex="-1"><el-txt><el-id>mp</el-id>.<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr56" class="ok" tabindex="-1"><el-txt>-<el-lit><el-lit>3</el-lit>.14</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert36" tabindex="-1"><el-kw>assert </el-kw><el-field id="text37" class="ok" tabindex="-1"><el-txt><el-method>sqrt</el-method>(-<el-id>p</el-id>).<el-method>isNaN</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr38" class="ok" tabindex="-1"><el-txt><el-id>true</el-id></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="let26" tabindex="-1"><el-kw>let </el-kw><el-field id="var27" class="ok" tabindex="-1"><el-txt><el-id>q</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr28" class="ok" tabindex="-1"><el-txt><el-lit>1</el-lit>/<el-lit>0</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok" id="assert29" tabindex="-1"><el-kw>assert </el-kw><el-field id="text30" class="ok" tabindex="-1"><el-txt><el-id>q</el-id>.<el-method>isInfinite</el-method>()</el-txt></el-field><el-kw> is </el-kw><el-field id="expr31" class="ok" tabindex="-1"><el-txt><el-id>true</el-id></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h2 id="MathsFunctions">Maths functions</h2>
<p>All the maths functions expect <el-type>Float</el-type> arguments, but <el-type>Int</el-type> arguments are accepted.
They all return a value of Type <el-type>Float</el-type>, except for <el-method>divAsInt</el-method> which returns an <el-type>Int</el-type>.
<table class="tableMethod">
<tr><th>function</th><th>argument<br>Type</th><th>input<br>unit</th><th>returns</th><th>output<br>unit</th></tr>
<tr id="abs"><td><el-method>abs</el-method></td><td><el-type>Float</el-type></td><td></td><td>absolute value of the input</td><td></td></tr>
<tr id="acos"><td><el-method>acos</el-method></td><td><el-type>Float</el-type></td><td></td><td>arccosine of the input</td><td>radians</td></tr>
<tr id="asin"><td><el-method>asin</el-method></td><td><el-type>Float</el-type></td><td></td><td>arcsine of the input</td><td>radians</td></tr>
<tr id="atan"><td><el-method>atan</el-method></td><td><el-type>Float</el-type></td><td></td><td>arctangent of the input</td><td>radians</td></tr>
<tr id="acosDeg"><td><el-method>acosDeg</el-method></td><td><el-type>Float</el-type></td><td></td><td>arccosine of the input</td><td>degrees</td></tr>
<tr id="asinDeg"><td><el-method>asinDeg</el-method></td><td><el-type>Float</el-type></td><td></td><td>arcsine of the input</td><td>degrees</td></tr>
<tr id="atanDeg"><td><el-method>atanDeg</el-method></td><td><el-type>Float</el-type></td><td></td><td>arctangent of the input</td><td>degrees</td></tr>
<tr id="cos"><td><el-method>cos</el-method></td><td><el-type>Float</el-type></td><td>radians</td><td>cosine of the input</td><td></td></tr>
<tr id="cosDeg"><td><el-method>cosDeg</el-method></td><td><el-type>Float</el-type></td><td>degrees</td><td>cosine of the input</td><td></td></tr>
<tr id="divAsFloat"><td><el-method>divAsFloat</el-method></td><td><el-type>Float</el-type>, <el-type>Float</el-type></td><td></td><td>first input value divided by second input value</td><td></td></tr>
<tr id="divAsInt"><td><el-method>divAsInt</el-method></td><td><el-type>Float</el-type>, <el-type>Float</el-type></td><td></td><td>first input value divided by second input value<br>and result rounded down to integer</td><td></td></tr>
<tr>
  <td id="exp"><el-id><el-method>exp</el-method></el-id></td>
  <td><el-type>Float</el-type></td>
  <td></td>
  <td>&#x1d452<sup>&#x1d465</sup> where &#x1d465 is the argument and<br>&#x1d452 is Euler's number 2.718281828459045..<br>the base of natural logarithms</td>
  <td></td>
</tr>
<tr id="logE"><td><el-method>logE</el-method></td><td><el-type>Float</el-type></td><td></td><td>natural logarithm of the input</td><td></td></tr>
<tr id="log10"><td><el-method>log10</el-method></td><td><el-type>Float</el-type></td><td></td><td>base-10 logarithm of the input</td><td></td></tr>
<tr id="log2"><td><el-method>log2</el-method></td><td><el-type>Float</el-type></td><td></td><td>base-2 logarithm of the input</td><td></td></tr>
<tr id="power"><td><el-method>power</el-method></td><td><el-type>Float</el-type>, <el-type>Float</el-type></td><td></td><td>first input value raised to the power<br>of the second input value</td><td></td></tr>
<tr id="sin"><td><el-method>sin</el-method></td><td><el-type>Float</el-type></td><td>radians</td><td>sine of the input</td><td></td></tr>
<tr id="sinDeg"><td><el-method>sinDeg</el-method></td><td><el-type>Float</el-type></td><td>degrees</td><td>sine of the input</td><td></td></tr>
<tr id="sqrt"><td><el-method>sqrt</el-method></td><td><el-type>Float</el-type></td><td></td><td>positive square root of the input</td><td></td></tr>
<tr id="tan"><td><el-method>tan</el-method></td><td><el-type>Float</el-type></td><td>radians</td><td>tangent of the input</td><td></td></tr>
<tr id="tanDeg"><td><el-method>tanDeg</el-method></td><td><el-type>Float</el-type></td><td>degrees</td><td>tangent of the input</td><td></td></tr>
<tr id="degToRad"><td><el-method>degToRad</el-method></td><td><el-type>Float</el-type></td><td>degrees</td><td>converts input from degrees to radians</td><td>radians</td></tr>
<tr id="radToDeg"><td><el-method>radToDeg</el-method></td><td><el-type>Float</el-type></td><td>radians</td><td>converts input from radians to degrees</td><td>degrees</td></tr>
</table>

<p>Examples of some maths functions and constants being tested:</p>
<el-code-block source="test_maths.elan">
<el-test class="ok multiline" id="test1" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="ident3" class="ok" tabindex="-1"><el-txt><el-id>test_maths</el-id></el-txt></el-field>
</el-top>
<el-statement class="ok" id="assert4" tabindex="-1"><el-kw>assert </el-kw><el-field id="text5" class="ok" tabindex="-1"><el-txt><el-id>pi</el-id></el-txt></el-field><el-kw> is </el-kw><el-field id="expr6" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>3</el-lit>.141592653589793</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert7" tabindex="-1"><el-kw>assert </el-kw><el-field id="text8" class="ok" tabindex="-1"><el-txt><el-method>abs</el-method>(-<el-lit><el-lit>3</el-lit>.7</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr9" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>3</el-lit>.7</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert10" tabindex="-1"><el-kw>assert </el-kw><el-field id="text11" class="ok" tabindex="-1"><el-txt><el-method>power</el-method>(<el-lit>2</el-lit>, <el-lit>10</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr12" class="ok" tabindex="-1"><el-txt><el-lit>1024</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert51" tabindex="-1"><el-kw>assert </el-kw><el-field id="text52" class="ok" tabindex="-1"><el-txt><el-method>sqrt</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr53" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>1</el-lit>.414</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert13" tabindex="-1"><el-kw>assert </el-kw><el-field id="text14" class="ok" tabindex="-1"><el-txt><el-method>asin</el-method>(<el-lit><el-lit>0</el-lit>.5</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr15" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>0</el-lit>.524</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert16" tabindex="-1"><el-kw>assert </el-kw><el-field id="text17" class="ok" tabindex="-1"><el-txt><el-method>acos</el-method>(<el-lit><el-lit>0</el-lit>.5</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr18" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>1</el-lit>.047</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert19" tabindex="-1"><el-kw>assert </el-kw><el-field id="text20" class="ok" tabindex="-1"><el-txt><el-method>atan</el-method>(<el-lit>1</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr21" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>0</el-lit>.79</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert22" tabindex="-1"><el-kw>assert </el-kw><el-field id="text23" class="ok" tabindex="-1"><el-txt><el-method>sin</el-method>(<el-id>pi</el-id>/<el-lit>6</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr24" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>0</el-lit>.5</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert25" tabindex="-1"><el-kw>assert </el-kw><el-field id="text26" class="ok" tabindex="-1"><el-txt><el-method>cos</el-method>(<el-id>pi</el-id>/<el-lit>4</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr27" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>0</el-lit>.707</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert28" tabindex="-1"><el-kw>assert </el-kw><el-field id="text29" class="ok" tabindex="-1"><el-txt><el-method>tan</el-method>(<el-id>pi</el-id>/<el-lit>4</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr30" class="ok" tabindex="-1"><el-txt><el-lit>1</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert31" tabindex="-1"><el-kw>assert </el-kw><el-field id="text32" class="ok" tabindex="-1"><el-txt><el-method>exp</el-method>(<el-lit>2</el-lit>).<el-method>round</el-method>(<el-lit>3</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr33" class="ok" tabindex="-1"><el-txt><el-lit><el-lit>7</el-lit>.389</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert34" tabindex="-1"><el-kw>assert </el-kw><el-field id="text35" class="ok" tabindex="-1"><el-txt><el-method>logE</el-method>(<el-lit><el-lit>7</el-lit>.389</el-lit>).<el-method>round</el-method>(<el-lit>2</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr36" class="ok" tabindex="-1"><el-txt><el-lit>2</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert37" tabindex="-1"><el-kw>assert </el-kw><el-field id="text38" class="ok" tabindex="-1"><el-txt><el-method>log10</el-method>(<el-lit>1000</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr39" class="ok" tabindex="-1"><el-txt><el-lit>3</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert40" tabindex="-1"><el-kw>assert </el-kw><el-field id="text41" class="ok" tabindex="-1"><el-txt><el-method>log2</el-method>(<el-lit>65536</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr42" class="ok" tabindex="-1"><el-txt><el-lit>16</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert43" tabindex="-1"><el-kw>assert </el-kw><el-field id="text44" class="ok" tabindex="-1"><el-txt><el-method>log2</el-method>(<el-lit>0x10000</el-lit>)</el-txt></el-field><el-kw> is </el-kw><el-field id="expr45" class="ok" tabindex="-1"><el-txt><el-lit>16</el-lit></el-txt></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>

<h2 id="RegExp">Regular expressions</h2>
    <p>Elan's regular expressions are modelled on those of JavaScript, including the syntax for literal regular expressions. See, for example this <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions">Guide to Regular Expressions</a>.</p>
    <p>More functions for using regular expressions will be added in a future release of Elan. For now:</p>
    <p>The method <el-method>matchesRegExp</el-method> is applied to a <el-type>String</el-type> using <a href="LangRef.html#dotSyntax">dot syntax</a> and requires a <el-type>RegExp</el-type> parameter specified as a literal or as variable. It returns a <el-type>Boolean</el-type>. For example:</p>

<el-code-block source="test_regexp_1.elan">
<el-test class="ok multiline" id="test1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>s1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>"<el-lit>hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let80" tabindex="0"><el-kw>let </el-kw><el-field id="var81" class="ok" tabindex="0"><el-txt><el-id>s2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt>"<el-lit>World</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let83" tabindex="0"><el-kw>let </el-kw><el-field id="var84" class="ok" tabindex="0"><el-txt><el-id>r</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt>/<el-regex>^[a-z]*$</el-regex>/</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-id>s1</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-id>s2</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<p>You can convert a valid string without <el-code>/../</el-code> delimiters to a <el-type>RegExp</el-type> using function <el-method>asRegExp</el-method>:</p>
<el-code-block source="test_regexp_2.elan">
<el-test class="ok multiline" id="test1" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment3" class="empty optional ok" tabindex="0"><el-txt></el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="let77" tabindex="0"><el-kw>let </el-kw><el-field id="var78" class="ok" tabindex="0"><el-txt><el-id>s1</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr79" class="ok" tabindex="0"><el-txt>"<el-lit>hello</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let80" tabindex="0"><el-kw>let </el-kw><el-field id="var81" class="ok" tabindex="0"><el-txt><el-id>s2</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr82" class="ok" tabindex="0"><el-txt>"<el-lit>World</el-lit>"</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="let83" tabindex="0"><el-kw>let </el-kw><el-field id="var84" class="ok" tabindex="0"><el-txt><el-id>r</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> be </el-kw><el-field id="expr85" class="ok" tabindex="0"><el-txt>"<el-lit>^[a-z]*$</el-lit>".<el-method>asRegExp</el-method>()</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert86" tabindex="0"><el-kw>assert </el-kw><el-field id="text87" class="ok" tabindex="0"><el-txt><el-id>s1</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr88" class="ok" tabindex="0"><el-txt><el-id>true</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert89" tabindex="0"><el-kw>assert </el-kw><el-field id="text90" class="ok" tabindex="0"><el-txt><el-id>s2</el-id>.<el-method>matchesRegExp</el-method>(<el-id>r</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr91" class="ok" tabindex="0"><el-txt><el-id>false</el-id></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
    <p>Although it is recommended that literal regular expressions are written with <el-code>/../</el-code> delimiters, the ability to convert a <el-code>string</el-code> allows you to input a regular expression into a running program.</p>

<h2 id="BitwiseFunctions">Bitwise functions</h2>
    <p>These functions take in an integer value, and manipulate the bit representation of that value.</p>

<table class="tableMethod">
 <tr>
  <th>function</th>
  <th>argument<br>Types</th>
  <th>return<br>Type</th>
  <th>returns</th>
 </tr><tr id="bitAnd">
  <td><el-method>bitAnd</el-method></td>
  <td><el-type>Int, Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>integer whose binary representation is the bitwise AND of the inputs</td>
 </tr><tr id="bitOr">
  <td><el-method>bitOr</el-method></td>
  <td><el-type>Int, Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>integer whose binary representation is the bitwise OR of the inputs</td>
 </tr><tr id="bitNot">
  <td><el-method>bitNot</el-method></td>
  <td><el-type>Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>integer whose binary representation is the bitwise complement of the input</td>
 </tr><tr id="bitXor">
  <td><el-method>bitXor</el-method></td>
  <td><el-type>Int, Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>integer whose binary representation is the bitwise XOR of the inputs</td>
 </tr><tr id="bitShiftL">
  <td><el-method>bitShiftL</el-method></td>
  <td><el-type>Int, Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>integer bit shifted to the left by the value of the second argument,<br>i.e. multiplied by 2 to the power of the second argument</td>
 </tr><tr id="bitShiftR">
  <td><el-method>bitShiftR</el-method></td>
  <td><el-type>Int, Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>integer bit shifted to the right by the value of the second argument,<br>i.e.  divided by 2 to the power of the second argument</td>
 </tr>
</table>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples of the bitwise functions being tested</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; Examples of the bitwise functions being tested</p>

<el-code-block source="test_bitwise.elan">
<el-test class="ok multiline" id="test3" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>test </el-kw><el-field id="comment5" class="optional ok" tabindex="0"><el-txt>bitwise</el-txt><el-place><i>optional description</i></el-place></el-field></el-top>
<el-statement class="ok" id="var12" tabindex="0"><el-kw>variable </el-kw><el-field id="var13" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr14" class="ok" tabindex="0"><el-txt><el-lit>13</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert15" tabindex="0"><el-kw>assert </el-kw><el-field id="text16" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr17" class="ok" tabindex="0"><el-txt><el-lit>0xd</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert18" tabindex="0"><el-kw>assert </el-kw><el-field id="text19" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr20" class="ok" tabindex="0"><el-txt><el-lit>0b1101</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert21" tabindex="0"><el-kw>assert </el-kw><el-field id="text22" class="ok" tabindex="0"><el-txt><el-id>a</el-id>.<el-method>asBinary</el-method>()</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr23" class="ok" tabindex="0"><el-txt>"<el-lit>1101</el-lit>"</el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var24" tabindex="0"><el-kw>variable </el-kw><el-field id="var25" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr26" class="ok" tabindex="0"><el-txt><el-lit>30</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert27" tabindex="0"><el-kw>assert </el-kw><el-field id="text28" class="ok" tabindex="0"><el-txt><el-id>b</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr29" class="ok" tabindex="0"><el-txt><el-lit>0b11110</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert30" tabindex="0"><el-kw>assert </el-kw><el-field id="text31" class="ok" tabindex="0"><el-txt><el-method>bitAnd</el-method>(<el-id>a</el-id>, <el-id>b</el-id>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>0b1100</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var36" tabindex="0"><el-kw>variable </el-kw><el-field id="var37" class="ok" tabindex="0"><el-txt><el-id>aob</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr38" class="ok" tabindex="0"><el-txt><el-method>bitOr</el-method>(<el-id>a</el-id>, <el-id>b</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert33" tabindex="0"><el-kw>assert </el-kw><el-field id="text34" class="ok" tabindex="0"><el-txt><el-id>aob</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr35" class="ok" tabindex="0"><el-txt><el-lit>0b11111</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var41" tabindex="0"><el-kw>variable </el-kw><el-field id="var42" class="ok" tabindex="0"><el-txt><el-id>axb</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr43" class="ok" tabindex="0"><el-txt><el-method>bitXor</el-method>(<el-id>a</el-id>, <el-id>b</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert44" tabindex="0"><el-kw>assert </el-kw><el-field id="text45" class="ok" tabindex="0"><el-txt><el-id>axb</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr46" class="ok" tabindex="0"><el-txt><el-lit>0b10011</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var47" tabindex="0"><el-kw>variable </el-kw><el-field id="var48" class="ok" tabindex="0"><el-txt><el-id>nota</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr49" class="ok" tabindex="0"><el-txt><el-method>bitNot</el-method>(<el-id>a</el-id>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert50" tabindex="0"><el-kw>assert </el-kw><el-field id="text51" class="ok" tabindex="0"><el-txt><el-id>nota</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr52" class="ok" tabindex="0"><el-txt>-<el-lit>14</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="var53" tabindex="0"><el-kw>variable </el-kw><el-field id="var54" class="ok" tabindex="0"><el-txt><el-id>aL</el-id></el-txt><el-place><i>name</i></el-place></el-field><el-kw> set to </el-kw><el-field id="expr55" class="ok" tabindex="0"><el-txt><el-method>bitShiftL</el-method>(<el-id>a</el-id>, <el-lit>2</el-lit>)</el-txt><el-place><i>expression</i></el-place></el-field></el-statement>
<el-statement class="ok" id="assert56" tabindex="0"><el-kw>assert </el-kw><el-field id="text57" class="ok" tabindex="0"><el-txt><el-id>aL</el-id></el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr58" class="ok" tabindex="0"><el-txt><el-lit>0b110100</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-statement class="ok" id="assert59" tabindex="0"><el-kw>assert </el-kw><el-field id="text60" class="ok" tabindex="0"><el-txt><el-method>bitShiftR</el-method>(<el-id>a</el-id>, <el-lit>2</el-lit>)</el-txt><el-place><i>computed value</i></el-place></el-field><el-kw> is </el-kw><el-field id="expr61" class="ok" tabindex="0"><el-txt><el-lit>0b11</el-lit></el-txt><el-place><i>expected value</i></el-place></el-field> <el-msg class="ok">pass</el-msg></el-statement>
<el-kw>end test</el-kw>
</el-test>
</el-code-block>
<p>The result of <el-method>bitNot</el-method>(<el-id>a</el-id>) being <el-code>-14</el-code> , when <el-id>a</el-id> is <el-code>13</el-code>, might be a surprise. But this is because the bitwise functions assume that the arguments are represented as 32-bit signed binary integers. So 13 is represented as<br><el-code>00000000000000000000000000001101</el-code>, and applying <el-method>bitNot</el-method> gives<br><el-code>11111111111111111111111111110010 </el-code>which is the value <el-code>-14 </el-code>in signed two's complement format,<br> the left-most bit being the sign (<el-code>0</el-code> positive, <el-code>1</el-code> negative).</p>
<hr>
</div></div>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Single bit operations
</h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; A reminder of single bit operations.<br>As noted in the example tests above, these methods act on 32-bit signed integers rather than on values of only one or a few bits,
so the effect of <el-method>bitNot</el-method> is not just the simple bit reversal shown here:</p>
<table>
 <tr><th rowspan="2"></th><th colspan="4">p,q</th></tr>
 <tr><th</th><th>0,0</th><th>0,1</th><th>1,0</th><th>1,1</th></tr>
 <tr><td><el-code>bitAnd(p,q)</el-code></td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
 <tr><td><el-code>bitOr(p,q)</el-code></td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
 <tr><td><el-code>bitNot(p)</el-code></td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
 <tr><td><el-code>bitXor(p,q)</el-code></td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
</table>
<hr>
</div></div>

<h2 id="sequence"><el-method>sequence</el-method></h2>

<p>The <el-method>sequence</el-method> function is used to create a <el-type>List</el-type> containing a sequence
of integer values as defined by its three parameters of Type <el-type>Int</el-type>: <el-id>start</el-id>, <el-id>end</el-id> and <el-id>step</el-id>.
Parameters <el-id>start</el-id> and <el-id>end</el-id> are <i>inclusive</i> values, and <el-id>step</el-id> may be positive or negative.</p>
<p>Here is an example which uses <a href="#HoFs">Higher-order Functions</a> to print the prime numbers between 2 and 30:</p>
<el-code-block source="sequence.elan">
<el-statement class="ok" id="call5" tabindex="-1"><el-kw>call </el-kw><el-field id="ident6" class="ok" tabindex="-1"><el-txt><el-method>print</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args7" class="optional ok" tabindex="-1"><el-txt><el-method>sequence</el-method>(<el-lit>2</el-lit>, <el-lit>30</el-lit>, <el-lit>1</el-lit>).<el-method>filter</el-method>(<el-kw>lambda</el-kw> <el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-method>sequence</el-method>(<el-lit>2</el-lit>, <el-method>sqrt</el-method>(<el-id>n</el-id>).<el-method>floor</el-method>(), <el-lit>1</el-lit>).<el-method>reduce</el-method>(<el-id>true</el-id>, <el-kw>lambda</el-kw> <el-id>c</el-id> <el-kw>as</el-kw> <el-type>Bool</el-type>, <el-id>m</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>c</el-id><el-kw> and </el-kw>((<el-id>n</el-id><el-kw> mod </el-kw><el-id>m</el-id>)<el-kw> isnt </el-kw><el-lit>0</el-lit>)))</el-txt></el-field><el-punc>)</el-punc></el-statement>
</el-code-block>

<h1 id="StandaloneProcedures">Standalone procedures</h1>
<h2></h2>

<p>All <el-code>procedure</el-code>s are accessed via a <a href="LangRef.html#call"><el-code>call</el-code></a> statement.</p>
<table class="tableMethod">
 <tr><th>procedure</th><th>input<br>argument<br>Types</th><th>output<br>argument<br>Types</th><th>action</th>
 </tr><tr id="pause">
  <td><el-method>pause</el-method></td>
  <td><el-type>Int</el-type></td>
  <td>(none)</td>
  <td>pauses the execution of a program for the specified number of milliseconds,<br> e.g. for a game <el-code>pause(1000)</el-code> delays execution for one second</td>
 </tr><tr id="clearPrintedText">
  <td><el-method>clearPrintedText</el-method></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears the IDE's display pane</td>
 </tr><tr id="clearBlocks">
  <td><el-method>clearBlocks</el-method></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears the block graphics layer of the IDE's display pane</td>
 </tr><tr id="clearVG">
  <td><el-method>clearVectorGraphics</el-method></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears the vector graphics layer of the IDE's display pane</td>
 </tr><tr id="clearHtml">
  <td><el-method>clearHtml</el-method></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears the Html layer of the IDE's display pane</td>
 </tr><tr id="clearAllDisplays">
  <td><el-method>clearAllDisplays</el-method></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears display pane as well as the blocks, vector graphics and Html layers</td>
 </tr><tr id="clearKeyBuffer">
  <td><el-method>clearKeyBuffer</el-method></td>
  <td>(none)</td>
  <td>(none)</td>
  <td>clears the IDE's keyboard input</td>
 </tr><tr id="pressAnyKeyToContinue">
  <td><el-method>pressAnyKeyToContinue</el-method></td>
  <td><el-type>Boolean</el-type></td>
  <td>(none)</td>
  <td>pauses execution of the program until a keyboard key is pressed<br>
  if the argument is <el-id>true</el-id> 'Press any key to continue' is first displayed,<br>
   if <el-id>false</el-id> nothing is displayed </td>
 </tr><tr id="print">
  <td><el-method>print</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td>prints the string to the display followed by a newline.<br>
  This method offers the means to do all printing via methods<br>
  rather than coding a mixture of <el-code>call</el-code> and <el-code>print</el-code> instructions</td>
 </tr><tr id="printNoLine">
  <td><el-method>printNoLine</el-method></td>
  <td><el-type>String</el-type></td>
  <td>(none)</td>
  <td>prints the string to the display without appending a newline so<br>
  a following call will output on the same line.<br>
  You can put your own <el-lit>\n</el-lit> newlines in the argument string</td>
 </tr><tr id="printTab">
  <td><el-method>printTab</el-method></td>
  <td><el-type>Int, String</el-type></td>
  <td>(none)</td>
  <td>prints the string to the display starting at the tab position given (from 0)</td>
 </tr>
</table>

<p>Method <el-method>printTab</el-method> helps in the layout of information printed to the display, in particular, when printing columns of data.
 For example:</p>
<el-code-block source="printTab.elan">
<el-statement class="ok" id="call5" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident6" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args7" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit>, "<el-lit>Number</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call11" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident12" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args13" class="optional ok" tabindex="0"><el-txt><el-lit>10</el-lit>, "<el-lit>Square</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call18" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident19" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args20" class="optional ok" tabindex="0"><el-txt><el-lit>20</el-lit>, "<el-lit>Cube\n</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok multiline" id="for27" tabindex="0">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident29" class="ok" tabindex="0"><el-txt><el-id>i</el-id></el-txt><el-place><i>variableName</i></el-place></el-field><el-kw> from </el-kw><el-field id="expr30" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> to </el-kw><el-field id="expr31" class="ok" tabindex="0"><el-txt><el-lit>10</el-lit></el-txt><el-place><i>expression</i></el-place></el-field><el-kw> step </el-kw><el-field id="expr32" class="ok" tabindex="0"><el-txt><el-lit>1</el-lit></el-txt><el-place><i>expression</i></el-place></el-field></el-top>
<el-statement class="ok" id="call36" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident37" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args38" class="optional ok" tabindex="0"><el-txt><el-lit>0</el-lit>, <el-id>i</el-id>.<el-method>asString</el-method>()</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call47" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident48" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args49" class="optional ok" tabindex="0"><el-txt><el-lit>10</el-lit>, "{<el-id>i</el-id>^<el-lit>2</el-lit>}"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-statement class="ok" id="call60" tabindex="0"><el-top><el-kw>call </el-kw><el-field id="ident61" class="ok" tabindex="0"><el-txt><el-method>printTab</el-method></el-txt><el-place><i>procedureName</i></el-place></el-field>(<el-field id="args62" class="optional ok" tabindex="0"><el-txt><el-lit>20</el-lit>, "{<el-id>i</el-id>^<el-lit>3</el-lit>}<el-lit>\n</el-lit>"</el-txt><el-place><i>position, text</i></el-place></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<p>Right-align numeric output (powers of 9) using a lambda:</p>

<el-code-block source="printTab_R.elan">
<el-statement class="ok" id="let25" tabindex="-1"><el-kw>let </el-kw><el-field id="var26" class="ok" tabindex="-1"><el-txt><el-id>tab</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr27" class="ok" tabindex="-1"><el-txt><el-lit>10</el-lit></el-txt></el-field></el-statement>
<el-statement class="ok multiline" id="for9" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>for </el-kw><el-field id="ident11" class="ok" tabindex="-1"><el-txt><el-id>i</el-id></el-txt></el-field><el-kw> from </el-kw><el-field id="expr12" class="ok" tabindex="-1"><el-txt><el-lit>1</el-lit></el-txt></el-field><el-kw> to </el-kw><el-field id="expr13" class="ok" tabindex="-1"><el-txt>(<el-id>tab</el-id> - <el-lit>1</el-lit>)</el-txt></el-field><el-kw> step </el-kw><el-field id="expr14" class="ok" tabindex="-1"><el-txt><el-lit>1</el-lit></el-txt></el-field></el-top>
<el-statement class="ok" id="let30" tabindex="-1"><el-kw>let </el-kw><el-field id="var31" class="ok" tabindex="-1"><el-txt><el-id>j</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr32" class="ok" tabindex="-1"><el-txt><el-lit>9</el-lit>^<el-id>i</el-id></el-txt></el-field></el-statement>
<el-statement class="ok" id="let33" tabindex="-1"><el-kw>let </el-kw><el-field id="var34" class="ok" tabindex="-1"><el-txt><el-id>f</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr35" class="ok" tabindex="-1"><el-txt><el-kw>lambda</el-kw> <el-id>j</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>j</el-id>.<el-method>asString</el-method>().<el-method>length</el-method>()</el-txt></el-field></el-statement>
<el-statement class="ok" id="call21" tabindex="-1"><el-top><el-kw>call </el-kw><el-field id="ident22" class="ok" tabindex="-1"><el-txt><el-method>printTab</el-method></el-txt></el-field>(<el-field id="args23" class="optional ok" tabindex="-1"><el-txt><el-id>tab</el-id> - <el-method>f</el-method>(<el-id>j</el-id>), "{<el-id>j</el-id>}<el-lit>\n</el-lit>"</el-txt></el-field>)</el-top></el-statement>
<el-kw>end for</el-kw>
</el-statement>
</el-code-block>

<h1 id="SystemMethods">System methods</h1>

<p>System methods appear to work like functions, because:</p>
<ul>
 <li>they may require one or more arguments to be provided.</li>
 <li>they always return a value.</li>
 <li>they are used in expressions.</li>
</ul>
<p>They are not, however, pure functions because:</p>
<ul>
 <li>They may have a dependency on data that is not provided as an argument.</li>
 <li>They may generate side effects, such as changing the screen display or writing to a file.</li>
</ul>
<p>Because of these properties, system methods may be used only within <el-kw>main</el-kw> or within a <el-kw>procedure</el-kw>.
 They may not be used inside a <el-kw>function</el-kw> that you have defined, because to do so would mean that your function would not be pure.</p>
<p>System methods are defined only within Elan's standard library: you cannot write a system method yourself.</p>

<h2 id="IOMethods">Input/output</h2>
<ul>
 <li>Keyboard input: see <a href="#KeyboardInput">Keyboard input</a>.</li>
 <li>File input/output: see <a href="#FileInputOutput">Text file input/output</a>.</li>
</ul>
 
<h2 id="MiscMethods">Miscellaneous</h2> 
<table class="tableMethod">
 <tr>
  <th>system<br>method</th>
  <th>argument<br>Types</th>
  <th>return<br>Types</th>
  <th>action</th>
 </tr><tr id="clock">
  <td><el-method>clock</el-method></td>
  <td>(none)</td>
  <td><el-type>Int</el-type></td>
  <td>returns the current value (in  milliseconds) of a system clock.<br>Useful for measuring elapsed time by comparing the values returned by two calls</td>
 </tr><tr id="random">
  <td><el-method>random</el-method></td>
  <td>(none)</td>
  <td><el-type>Float</el-type></td>
  <td>returns a random number in the range [0..1]<br>Not usable from a function: see note</td>
 </tr><tr id="randomInt">
  <td><el-method>randomInt</el-method></td>
  <td><el-type>Int</el-type>, <el-type>Int</el-type></td>
  <td><el-type>Int</el-type></td>
  <td>returns a random number in the (inclusive) range between the two arguments<br>Not usable from a function: see note</td>
 </tr>
</table>

<h4 class="no-TOC">Note</h4><ul>
 <li>Methods <el-method>random</el-method> and <el-method>randomInt</el-method> cannot be used in a function because
 of their dependence on external factors, i.e. they are subject to side effects.
 To obtain random numbers within a function, use Type <a href="#Random"><el-type>Random</el-type></a>.</li></ul>

<h1 id="HoFs">Higher-order Functions (HoFs)</h1>
<p>A <b>higher-order function</b> (HoF) is one that takes in a reference to another function as a parameter, or (less commonly) that returns a reference to another function as its result. </p>

<h2>Standard HoFs</h2>
<p>The standard library contains several HoFs that are widely recognised and used within functional programming, namely
<a href="#filter"><el-method>filter</el-method></a>,
<a href="#map"><el-method>map</el-method></a> and
<a href="#reduce"><el-method>reduce</el-method></a>, and also provides
<a href="#maxBy"><el-method>maxBy</el-method></a>,
<a href="#minBy"><el-method>minBy</el-method></a> and
<a href="#orderBy"><el-method>orderBy</el-method></a>.</p>

<h2 id="ref">Passing a function as a reference</h2>
<p>To use a higher-order function (HoF), you have to pass in a reference to a function.
 This can be either a <a href="LangRef.html#lambda"><el-kw>lambda</el-kw></a> or the name of a function.
 It is also possible to use references to functions not in the context of HoFs.</p>

<p>On most occasions when you write the name of an existing function elsewhere in code your intent is to <i>evaluate</i> the function and, to do so, you write the name of the function followed by round brackets containing such arguments as are required by the function. When passing a function, its name is not followed by round brackets (or arguments), as in this example:

<el-code-block source="passFuncAsRef.elan">
<el-class class="ok multiline" id="class1" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>class </el-kw><el-field id="type2" class="ok" tabindex="-1"><el-txt><el-type>Pupil</el-type></el-txt><el-place>Name</el-place></el-field> <el-field id="text3" class="empty optional ok" tabindex="-1"></el-field></el-top>
<el-prop class="ok" id="prop5" tabindex="-1"><el-kw>property </el-kw><el-field id="ident6" class="ok" tabindex="-1"><el-txt><el-id>mathsPercent</el-id></el-txt></el-field><el-kw> as </el-kw><el-field id="type7" class="ok" tabindex="-1"><el-txt><el-type>Int</el-type></el-txt></el-field></el-prop>
<el-kw>end class</el-kw>
</el-class>
<main class="ok multiline" id="main8" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>main</el-kw></el-top>
<el-statement class="ok" id="let10" tabindex="-1"><el-kw>let </el-kw><el-field id="var11" class="ok" tabindex="-1"><el-txt><el-id>allPupils</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr12" class="ok" tabindex="-1"><el-txt><el-kw>new</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Pupil</el-type>&gt;()</el-txt></el-field></el-statement>
<el-statement class="ok" id="var13" tabindex="-1"><el-kw>variable </el-kw><el-field id="var14" class="ok" tabindex="-1"><el-txt><el-id>passes</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr15" class="ok" tabindex="-1"><el-txt><el-id>allPupils</el-id>.<el-method>filter</el-method>(<el-id>passedMathsTest</el-id>)</el-txt></el-field></el-statement>
<el-kw>end main</el-kw>
</main>
<el-func class="ok multiline" id="func16" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident18" class="ok" tabindex="-1"><el-txt><el-method>passedMathsTest</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params19" class="optional ok" tabindex="-1"><el-txt><el-id>p</el-id> <el-kw>as</el-kw> <el-type>Pupil</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type20" class="ok" tabindex="-1"><el-txt><el-type>Boolean</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="return21" tabindex="-1"><el-kw>return </el-kw><el-field id="expr22" class="ok" tabindex="-1"><el-txt><el-id>p</el-id>.<el-id>mathsPercent</el-id> &gt; <el-lit>35</el-lit></el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>

<h2>Defining your own HoFs</h2>

<h2>Library functions that process Lists</h2>
<p>These dot methods are called on any <el-type>List</el-type>, or <el-type>String</el-type>. As Higher-order Functions they take either a <el-kw>lambda</el-kw> or a function reference as one of their arguments: see above.</p>
<p>These are not yet fully documented but, for readers familiar with HoFs from another programming language, some examples are shown below.</p>

<h3 class="no-TOC" id="filter">filter </h3>

<p>You give a <el-type>List</el-type> to the higher-order function <el-method>filter</el-method> in order to return a new <el-type>List</el-type> containing a subset of items.
The subset is chosen by a lambda function that tests list item values and returns a Boolean to specify filtering in or out.</p>  

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Example using <el-method>filter</el-method></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; Example from demo program <el-code>pathfinder.elan</el-code> in which <el-method>filter</el-method> applies the <el-kw>lambda</el-kw> to the <el-id>nodes</el-id> (of class <el-type>Node</el-type>) to find one that contains <el-id>p</el-id> (of record <el-type>Point</el-type>):</p>
<el-code-block source="pathfinder.elan">
<el-func class="ok multiline" id="func333" tabindex="-1">
<el-top><el-expand>+</el-expand><el-kw>function </el-kw><el-field id="ident335" class="ok" tabindex="-1"><el-txt><el-method>getNodeFor</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="params336" class="optional ok" tabindex="-1"><el-txt><el-id>p</el-id> <el-kw>as</el-kw> <el-type>Point</el-type></el-txt></el-field><el-punc>)</el-punc><el-kw> returns </el-kw><el-field id="type337" class="ok" tabindex="-1"><el-txt><el-type>Node</el-type></el-txt></el-field></el-top>
<el-statement class="ok" id="let340" tabindex="-1"><el-kw>let </el-kw><el-field id="var341" class="ok" tabindex="-1"><el-txt><el-id>matches</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr342" class="ok" tabindex="-1"><el-txt><el-kw>property</el-kw>.<el-id>nodes</el-id>.<el-method>filter</el-method>(<el-kw>lambda</el-kw> <el-id>n</el-id> <el-kw>as</el-kw> <el-type>Node</el-type> =&gt; <el-id>n</el-id>.<el-id>point</el-id><el-kw> is </el-kw><el-id>p</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="return338" tabindex="-1"><el-kw>return </el-kw><el-field id="expr339" class="ok" tabindex="-1"><el-txt><el-kw>if </el-kw><el-id>matches</el-id>.<el-method>length</el-method>()<el-kw> is </el-kw><el-lit>1</el-lit><el-kw><br>then </el-kw><el-id>matches</el-id>.<el-method>head</el-method>()<el-kw><br>else </el-kw><el-kw>empty</el-kw> <el-type>Node</el-type></el-txt></el-field></el-statement>
<el-kw>end function</el-kw>
</el-func>
</el-code-block>
<hr>
</div></div>

<h3 class="no-TOC" id="map">map</h3>
<p>The function <el-method>map</el-method> is used to apply a function to every item in a <el-type>List</el-type>, and return a new List.
The function to be applied is usually specified as a <el-kw>lambda</el-kw> having a single argument of the Type of the list's items, as in these examples:</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-method>map</el-method></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To cube each integer value in a list:</p>
<el-code-block source="map.elan">
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>li</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>[<el-lit>1</el-lit>, <el-lit>2</el-lit>, <el-lit>3</el-lit>, <el-lit>4</el-lit>, <el-lit>5</el-lit>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="call6" tabindex="-1"><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-method>print</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args8" class="optional ok" tabindex="-1"><el-txt><el-id>li</el-id>.<el-method>map</el-method>(<el-kw>lambda</el-kw> <el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-method>power</el-method>(<el-id>n</el-id>, <el-lit>3</el-lit>))</el-txt></el-field><el-punc>)</el-punc></el-statement>
&nbsp;&nbsp;&#x27f6; [1, 8, 27, 64, 125]
</el-code-block>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To change each string in a list to upper case:</p>
<el-code-block source="map.elan">
<el-statement class="ok" id="var9" tabindex="-1"><el-kw>variable </el-kw><el-field id="var10" class="ok" tabindex="-1"><el-txt><el-id>names</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr11" class="ok" tabindex="-1"><el-txt>["<el-lit>Tom</el-lit>", "<el-lit>Dick</el-lit>", "<el-lit>Harriet</el-lit>"]</el-txt></el-field></el-statement>
<el-statement class="ok" id="call12" tabindex="-1"><el-kw>call </el-kw><el-field id="ident13" class="ok" tabindex="-1"><el-txt><el-method>print</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args14" class="optional ok" tabindex="-1"><el-txt><el-id>names</el-id>.<el-method>map</el-method>(<el-kw>lambda</el-kw> <el-id>s</el-id> <el-kw>as</el-kw> <el-type>String</el-type> =&gt; <el-id>s</el-id>.<el-method>upperCase</el-method>())</el-txt></el-field><el-punc>)</el-punc></el-statement>
&nbsp;&nbsp;&#x27f6; ["TOM", "DICK", "HARRIET"]
</el-code-block>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To reverse each string in the list of names using the function <el-method>reverse</el-method>
 (from the example of the <a href="LangRef.html#each">each</a> loop):</p>
<el-code-block source="map.elan">
<el-statement class="ok" id="call15" tabindex="-1"><el-kw>call </el-kw><el-field id="ident16" class="ok" tabindex="-1"><el-txt><el-method>print</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args17" class="optional ok" tabindex="-1"><el-txt><el-id>names</el-id>.<el-method>map</el-method>(<el-kw>lambda</el-kw> <el-id>s</el-id> <el-kw>as</el-kw> <el-type>String</el-type> =&gt; <el-method>reverseString</el-method>(<el-id>s</el-id>))</el-txt></el-field><el-punc>)</el-punc></el-statement>
&nbsp;&nbsp;&#x27f6; ["moT", "kciD", "teirraH"]
</el-code-block>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; And this example from demo program <el-code>maze-generator.elan</el-code>:</p>
<el-code-block source="maze-generator.elan">
<el-statement class="ok" id="var156" tabindex="-1"><el-kw>variable </el-kw><el-field id="var157" class="ok" tabindex="-1"><el-txt><el-id>n</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr158" class="ok" tabindex="-1"><el-txt><el-id>p</el-id>.<el-method>neighbouringPoints</el-method>().<el-method>map</el-method>(<el-kw>lambda</el-kw> <el-id>p</el-id> <el-kw>as</el-kw> <el-type>Point</el-type> =&gt; <el-method>getValue</el-method>(<el-id>p</el-id>, <el-id>g</el-id>))</el-txt></el-field></el-statement>
</el-code-block>
<hr>
</div></div>

<h3 class="no-TOC" id="reduce">reduce</h3>
<p>The function <el-method>reduce</el-method> is used to combine the items in a list in some way to produce
  a single result. This result may be of the same Type as the items in the list, for example to:

  <ul>
    <li>Find the sum or sum-of-squares of a list of numeric values.</li>
    <li>Concatenate, or combine in some other way, the items from a List of Strings.</li>
  </ul>

  The result may, however, be of a different Type than the items in the list, and may even
  be a data structure, for example to:

  <ul>
    <li>Generate a <a href="#Tuple"><el-code>Tuple</el-code></a> of the sum, sum-of-squares, and count of numerical items.</li>
    <li>Generate a dictionary of all the unique words in a list, with the number of times each word appears in the input List</li>
  </ul>

  <el-method>reduce</el-method> requires two arguments:

  <ol>
    <li>The initial, or 'seed', value, of the Type that you wish to be returned by the function specified in the second argument..
      For example, if you were finding the sum of a list of Type <el-type>Float</el-type>, the initial seed value
      would typically be <el-lit>0.0</el-lit>. If you were creating a dictionary of words, the initial seed
      value would be an empty Dictionary of the correct Types.</li>
    <li>The function (or lambda) to be applied, which itself requires two arguments:
      <ol>
          <li>The accumulating value, which is therefore of the same Type as the initial seed value.
          (This will be the return value of the function or lambda).</li>
          <li>The item to which the function is applied, which is therefore of the same Type
            as the items in the input list.</li>
      </ol>
    </li>
  </ol>

  In other words, the specified function or lambda is applied to each itme of the input List in turn, in each case passing in the current value
  of the result. The function makes use of both to generate a <i>new</i> value for the result, replacing the current one
  for application to the next item. This is best understood by looking at the examples.

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-method>reduce</el-method></h4>
<div class="acc-body">

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To reduce the integer values in a list to their sum:</p>
<el-code-block source source="reduce.elan">
<el-statement class="ok" id="let3" tabindex="-1"><el-kw>let </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>li</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>[<el-lit>2</el-lit>, <el-lit>3</el-lit>, <el-lit>4</el-lit>, <el-lit>7</el-lit>, <el-lit>11</el-lit>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="print6" tabindex="-1"><el-kw>print </el-kw><el-field id="expr7" class="optional ok" tabindex="-1"><el-txt><el-id>li</el-id>.<el-method>reduce</el-method>(<el-lit>0</el-lit>, <el-kw>lambda</el-kw> <el-id>m</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>n</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>m</el-id> + <el-id>n</el-id>)</el-txt></el-field></el-statement>
&nbsp;&nbsp;&#x27f6; 15
</el-code-block>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To reduce the floating point values in a list to their sum:</p>
<el-code-block source source="reduce.elan">
<el-statement class="ok" id="let12" tabindex="-1"><el-kw>let </el-kw><el-field id="var13" class="ok" tabindex="-1"><el-txt><el-id>lj</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr14" class="ok" tabindex="-1"><el-txt>[<el-lit><el-lit>0</el-lit>.1</el-lit>, <el-lit><el-lit>2</el-lit>.5</el-lit>, <el-lit>2</el-lit>, <el-lit><el-lit>0</el-lit>.3</el-lit>, <el-lit><el-lit>5</el-lit>.7</el-lit>, <el-lit><el-lit>0</el-lit>.2</el-lit>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="print15" tabindex="-1"><el-kw>print </el-kw><el-field id="expr16" class="optional ok" tabindex="-1"><el-txt><el-id>lj</el-id>.<el-method>reduce</el-method>(<el-lit><el-lit>0</el-lit>.0</el-lit>, <el-kw>lambda</el-kw> <el-id>fsum</el-id> <el-kw>as</el-kw> <el-type>Float</el-type>, <el-id>item</el-id> <el-kw>as</el-kw> <el-type>Float</el-type> =&gt; <el-id>fsum</el-id> + <el-id>item</el-id>).<el-method>round</el-method>(<el-lit>1</el-lit>)</el-txt></el-field></el-statement>
&nbsp;&nbsp;&#x27f6; 10.8
</el-code-block>

<h5 class="no-TOC">&nbsp;&nbsp;&nbsp;Notes</h5>
<ul>
 <li>You usually need to round floating point values when outputting them.</li>
 <li>The inclusion of an integer in a <el-type>List</el-type> of floats is valid provided it is not the first value.</li>
</ul>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To reverse the order of items in a <el-type>List</el-type>:</p>
<el-code-block>
<el-statement class="ok" id="print30" tabindex="-1"><el-kw>print </el-kw><el-field id="expr31" class="optional ok" tabindex="-1"><el-txt><el-id>li</el-id>.<el-method>reduce</el-method>(<el-kw>empty</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;, <el-kw>lambda</el-kw> <el-id>liR</el-id> <el-kw>as</el-kw> <el-type>List</el-type>&lt;<el-kw>of</el-kw> <el-type>Int</el-type>&gt;, <el-id>item</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>liR</el-id>.<el-method>withPrepend</el-method>(<el-id>item</el-id>))</el-txt></el-field></el-statement>
&nbsp;&nbsp;&#x27f6; [11, 7, 4, 3, 2]
</el-code-block>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; And this example on a <el-type>DictionaryImmutable</el-type> from demo program <el-code>wordle-solver.elan</el-code>:</p>
<el-code-block source source="Wordle.elan">
<el-statement class="ok" id="let350" tabindex="0"><el-kw>let </el-kw><el-field id="var351" class="ok" tabindex="0"><el-txt><el-id>d2</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr352" class="ok" tabindex="0"><el-txt><el-id>possAnswers</el-id>.<el-method>reduce</el-method>(<el-id>d</el-id>, <el-kw>lambda</el-kw> <el-id>dd</el-id> <el-kw>as</el-kw> <el-type>DictionaryImmutable</el-type>&lt;<el-kw>of</el-kw> <el-type>String</el-type>, <el-type>Int</el-type>&gt;, <el-id>answer</el-id> <el-kw>as</el-kw> <el-type>String</el-type> =&gt; <el-method>incrementCount</el-method>(<el-id>dd</el-id>, <el-id>answer</el-id>, <el-id>attempt</el-id>))</el-txt></el-field></el-statement>
</el-code-block>
<hr>
</div></div>

<div id="maxBy"></div>
<div id="minBy"></div>
<h3 class="no-TOC">maxBy and minBy</h3>
<p><el-method>maxBy</el-method> and <el-method>minBy</el-method> are dot functions of a <el-type>List</el-type>.
They take a function as an argument, and return the list item corresponding to the maximum or minimum of the values returned by the function.</p>
<p>For simply finding the maximum or minimum value in a <el-type>List</el-type>, you can use
<a href="#maxFloat"><el-method>maxFloat</el-method></a>,
<a href="#minFloat"><el-method>minFloat</el-method></a>,
<a href="#maxInt"><el-method>maxInt</el-method></a> or
<a href="#minInt"><el-method>minInt</el-method></a>.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-method>maxBy</el-method> and <el-method>minBy</el-method></h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; To find in a list the integer that has the highest last digit:</p>
<el-code-block>
<el-statement class="ok" id="let11" tabindex="0"><el-kw>let </el-kw><el-field id="var12" class="ok" tabindex="0"><el-txt><el-id>a</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr13" class="ok" tabindex="0"><el-txt>{<el-lit>33</el-lit>, <el-lit>4</el-lit>, <el-lit>0</el-lit>, <el-lit>92</el-lit>, <el-lit>89</el-lit>, <el-lit>55</el-lit>, <el-lit>102</el-lit>}</el-txt></el-field></el-statement>
<el-statement class="ok" id="print8" tabindex="0"><el-kw>print </el-kw><el-field id="expr9" class="optional ok" tabindex="0"><el-txt><el-id>a</el-id>.<el-method>maxBy</el-method>(<el-kw>lambda</el-kw> <el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>x</el-id><el-kw> mod </el-kw><el-lit>10</el-lit>)</el-txt></el-field></el-statement>
&nbsp;&nbsp;&#x27f6; 89
</el-code-block>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To find in a list the the shortest string:</p>
<el-code-block>
<el-statement class="ok" id="let14" tabindex="0"><el-kw>let </el-kw><el-field id="var15" class="ok" tabindex="0"><el-txt><el-id>fruit</el-id></el-txt></el-field><el-kw> be </el-kw><el-field id="expr16" class="ok" tabindex="0"><el-txt>{"<el-lit>apple</el-lit>", "<el-lit>orange</el-lit>", "<el-lit>pear</el-lit>"}</el-txt></el-field></el-statement>
<el-statement class="ok" id="print17" tabindex="0"><el-kw>print </el-kw><el-field id="expr18" class="optional ok" tabindex="0"><el-txt><el-id>fruit</el-id>.<el-method>minBy</el-method>(<el-kw>lambda</el-kw> <el-id>x</el-id> <el-kw>as</el-kw> <el-type>String</el-type> =&gt; <el-id>x</el-id>.<el-method>length</el-method>())</el-txt></el-field></el-statement>
&nbsp;&nbsp;&#x27f6; pear
</el-code-block>
<hr>
</div></div>

<h3 class="no-TOC" id="orderBy">orderBy</h3>
<p><el-method>orderBy</el-method> takes a <el-kw>lambda</el-kw> that has two arguments of the same Type as that of the <el-type>List</el-type> items to be re-ordered
 and compares them, returning a Boolean value that distinguishes between <i>less than</i> (or <i>greater than</i>) for numerics and <i>before</i> (or <i>after</i>) for strings.</p>

<div class="accordion">
<h4 class="no-TOC acc-title" tabindex="0">Examples using <el-method>orderBy</el-method></h4>
<div class="acc-body">
<p>&nbsp;&nbsp;&nbsp;&#x25b6; To  reorder integers in a <el-type>List</el-type>, using > for ascending (you would use < for descending):</p>
<el-code-block source="orderBy_Int.elan">
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>numbers</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>[<el-lit>27</el-lit>, <el-lit>2</el-lit>, <el-lit>3</el-lit>, <el-lit>5</el-lit>, <el-lit>7</el-lit>, <el-lit>31</el-lit>, <el-lit>37</el-lit>, <el-lit>11</el-lit>, <el-lit>23</el-lit>, <el-lit>13</el-lit>, <el-lit>19</el-lit>, <el-lit>23</el-lit>]</el-txt></el-field></el-statement>
<el-statement class="ok" id="var6" tabindex="-1"><el-kw>variable </el-kw><el-field id="var7" class="ok" tabindex="-1"><el-txt><el-id>ordered</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr8" class="ok" tabindex="-1"><el-txt><el-id>numbers</el-id>.<el-method>orderBy</el-method>(<el-kw>lambda</el-kw> <el-id>x</el-id> <el-kw>as</el-kw> <el-type>Int</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>Int</el-type> =&gt; <el-id>x</el-id> &gt; <el-id>y</el-id>)</el-txt></el-field></el-statement>
<el-statement class="ok" id="call9" tabindex="-1"><el-kw>call </el-kw><el-field id="ident10" class="ok" tabindex="-1"><el-txt><el-method>print</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args11" class="optional ok" tabindex="-1"><el-txt><el-id>ordered</el-id></el-txt></el-field><el-punc>)</el-punc></el-statement>
&nbsp;&nbsp;&#x27f6; [2, 3, 5, 7, 11, 13, 19, 23, 23, 27, 31, 37]
</el-code-block>

<p>&nbsp;&nbsp;&nbsp;&#x25b6; To reorder strings in a <el-type>List</el-type>, using method <el-method>iBefore</el-method> for descending (you would use <el-method>isAfter</el-method> for ascending):</p>
<el-code-block source="orderBy_String.elan">
<el-statement class="ok" id="var3" tabindex="-1"><el-kw>variable </el-kw><el-field id="var4" class="ok" tabindex="-1"><el-txt><el-id>names</el-id></el-txt></el-field><el-kw> set to </el-kw><el-field id="expr5" class="ok" tabindex="-1"><el-txt>["<el-lit>Simon</el-lit>", "<el-lit>Pauline</el-lit>", "<el-lit>Jason</el-lit>", "<el-lit>Zelda</el-lit>", "<el-lit>Edith</el-lit>", "<el-lit>Lance</el-lit>", "<el-lit>Alice</el-lit>", "<el-lit>Paul</el-lit>"]</el-txt></el-field></el-statement>
<el-statement class="ok" id="call6" tabindex="-1"><el-kw>call </el-kw><el-field id="ident7" class="ok" tabindex="-1"><el-txt><el-method>print</el-method></el-txt></el-field><el-punc>(</el-punc><el-field id="args8" class="optional ok" tabindex="-1"><el-txt><el-id>names</el-id>.<el-method>orderBy</el-method>(<el-kw>lambda</el-kw> <el-id>x</el-id> <el-kw>as</el-kw> <el-type>String</el-type>, <el-id>y</el-id> <el-kw>as</el-kw> <el-type>String</el-type> =&gt; <el-id>x</el-id>.<el-method>isBefore</el-method>(<el-id>y</el-id>))</el-txt></el-field><el-punc>)</el-punc></el-statement>
&nbsp;&nbsp;&#x27f6; [Zelda, Simon, Pauline, Paul, Lance, Jason, Edith, Alice]
</el-code-block>
<hr>
</div></div>

<p><b>Elan Library Reference</b> go to the <a href="#top">top</a></p>
<script>
  var accordions = document.getElementsByClassName("acc-title");
  for (const item of accordions) {
    item.addEventListener("click", function() {
      item.parentElement.classList.toggle("active");
    });
    item.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        item.parentElement.classList.toggle("active");
      }
    });
  }
</script>
</body>
</html>