# 6908db3d4fa6dc535f7d0677a9ef304eccdb51583d96c09ac9db2329cc628e26 Elan 2.0.0-alpha guest default_profile valid

main
  variable reply set to ""
  while not reply.upperCase().isSameValueAs("Q")
    set reply to inputString('RETURN for time now or\nUnix time (positive integer) or\nQ to quit')
    if reply.isSameValueAs("") then
      call printDate(divAsInteger(clock(), 1000))
    else
      variable t, d set to parseAsInt(reply)
      if t and (d >= 0) then
        call printDate(d)
      end if
    end if
  end while
end main

procedure printDate(unixSecs as Int)
  constant hour, minute, second, days, year, weekday set to dateTime(unixSecs)
  constant h set to pad("L", z2, hour.asString())
  constant m set to pad("L", z2, minute.asString())
  constant s set to pad("L", z2, second.asString())
  constant startDaysL set to startDaysList(year, startDays)
  constant month, day set to monthDay(startDaysL, (days mod startDays[12]))
  call print(weekdayNames[weekday] + cs + pad("L", z2, day.asString()) + s1 + monthNames[month - 1] + s1 + "{year}" + s1 + h + co + m + co + s + " UTC\n")
end procedure

function dateTime(unixSecs as Int) returns (Int, Int, Int, Int, Int, Int)
  # get separate values from Unix time
  constant hour set to (divAsInteger(divAsInteger(unixSecs, 60), 60) mod 24)
  constant minute set to divAsInteger(unixSecs, 60) mod 60
  constant second set to (unixSecs mod 60)
  # days and years from Unix epoch
  constant unixDay set to divAsInteger(unixSecs, daySecs)
  constant years set to ((unixDay + 1)/365.24).floor()
  # this year and weekday
  constant year set to unixYear + years
  constant weekday set to (unixDay + unixWeekday) mod 7
  # day number (1-365 or 1-366) in this year
  constant day set to dayInYear(year, unixDay)
  return tuple(hour, minute, second, day, year, weekday)
end function

function dayInYear(year as Int, unixDays as Int) returns Int
  # unixDays start at 0, months' day numbers start at 1
  variable dayNumber set to unixDays + 1
  if year > unixYear then
    # discount previous nominal years
    set dayNumber to dayNumber - 365*(year - unixYear)
    # discount previous leap days
    for y from unixYear to (year - 1) step 1
      if leap(y) then
        set dayNumber to dayNumber - 1
      end if
    end for
  end if
  return dayNumber
end function

function leap(year as Int) returns Boolean
  variable leapYear set to false
  if (year mod 4) is 0 then
    set leapYear to true
    if ((year mod 100) is 0) and ((divAsInteger(year, 100) mod 4) isnt 0) then
      set leapYear to false
    end if
  end if
  return leapYear
end function

function monthDay(startDays as List<of Int>, dayNumber as Int) returns (Int, Int)
  # get month (1-12) & day (1-31) from dayNumber (1-365 or 1-366)
  variable month set to 1
  variable day set to 0
  variable monthFound set to false
  while monthFound is false
    if (dayNumber < startDays[month]) then
      set monthFound to true
      set day to dayNumber - startDays[month - 1] + 1
    else
      set month to month + 1
    end if
  end while
  return tuple(month, day)
end function

function startDaysList(year as Int, startDays as ListImmutable<of Int>) returns List<of Int>
  # alter month start days if leap year
  variable startDaysL set to startDays.asList()
  if leap(year) then
    for m from 2 to 12 step 1
      set startDaysL to startDaysL.withPut(m, startDaysL[m] + 1)
    end for
  end if
  return startDaysL
end function

# Unix epoch is 1970.01.01 00:00:00 Thursday
constant unixYear set to 1970

constant unixWeekday set to 4

# day and month names, and day numbers
constant daySecs set to 86400

constant weekdayNames set to {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}

constant monthNames set to {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

constant startDays set to {1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}

# output edit strings
constant s1 set to " "

constant z2 set to "00"

constant cs set to ", "

constant co set to ":"

function pad(d as String, p as String, s as String) returns String
  # d: L or R for pad left or right
  # p: output string pattern of pad characters and of length
  # s: input string
  variable sR set to s
  if p.length() > s.length() then
    if d.upperCase().isSameValueAs("L") then
      set sR to (p + s)[(p + s).length() - p.length()..]
    elif d.upperCase().isSameValueAs("R") then
      set sR to (s + p)[..p.length()]
    end if
  end if
  return sR
end function
