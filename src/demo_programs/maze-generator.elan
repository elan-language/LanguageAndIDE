# be685d34986e704ee62e662581316d7b7355e49b1ebe02c5456d360a18669f84 Elan 2.0.0-alpha guest default_profile valid

main
  variable blocks set to createBlockGraphics(black)
  set blocks to createStart(blocks)
  for i from 0 to displayWidth step 1
    constant x set to randomInt(0, 39)
    constant y set to randomInt(0, 29)
    variable p set to new Point(x, y)
    constant existing set to getValue(p, blocks)
    constant setTo set to (random() + 0.7).floor()
    if okToSet(p, setTo, blocks) then
      constant colour set to if setTo is 1 then white else black
      set blocks[p.x][p.y] to colour
    end if
  end for
  call displayBlocks(blocks)
  constant name set to inputString("File name to save: ")
  if not name.isSameValueAs("x") then
    call saveAsFile(name, blocks)
  end if
end main

constant displayWidth set to 150

procedure saveAsFile(name as String, b as List<of List<of Int>>)
  variable file set to createFileForWriting(name)
  for row from 0 to 29 step 1
    variable line set to ""
    for col from 0 to 39 step 1
      constant colour set to b[col][row]
      constant symbol set to if colour is white then " " else "X"
      set line to line + symbol
    end for
    call file.writeLine(line)
  end for
  call file.saveAndClose()
end procedure

function createStart(b as List<of List<of Int>>) returns List<of List<of Int>>
  variable b2 set to b
  for i from 0 to 15 step 2
    set b2 to addRectangle(b2, i, i, 39 - 2*i, 29 - 2*i)
  end for
  return b2
end function

function addRectangle(b as List<of List<of Int>>, startX as Int, startY as Int, width as Int, depth as Int) returns List<of List<of Int>>
  constant paint set to white
  variable b2 set to b
  for x from startX to startX + width step 1
    set b2 to withPut(b2, x, startY, paint)
    set b2 to withPut(b2, x, startY + depth, paint)
  end for
  for y from startY to startY + depth step 1
    set b2 to withPut(b2, startX, y, paint)
    set b2 to withPut(b2, startX + width, y, paint)
  end for
  return b2
end function

function withPut(graphics as List<of List<of Int>>, x as Int, y as Int, colour as Int) returns List<of List<of Int>>
  return graphics.withPut(x, graphics[x].withPut(y, colour))
end function

# colour: 0 for black, 1 for white
function okToSet(p as Point, colour as Int, g as List<of List<of Int>>) returns Boolean
  variable n set to p.neighbouringPoints().map(lambda p as Point => getValue(p, g))
  constant q1 set to isValidQuadrant(n[0] + n[1]*2 + colour*4 + n[3]*8)
  constant q2 set to isValidQuadrant(n[1] + n[2]*2 + n[4]*4 + colour*8)
  constant q3 set to isValidQuadrant(colour + n[4]*2 + n[7]*4 + n[6]*8)
  constant q4 set to isValidQuadrant(n[3] + colour*2 + n[6]*4 + n[5]*8)
  return q1 and q2 and q3 and q4
end function

function getValue(p as Point, b as List<of List<of Int>>) returns Int
  variable result set to 0
  if (p.x > -1) and (p.x < 40) and (p.y > -1) and (p.y < 30) then
    constant colour set to b[p.x][p.y]
    set result to if colour is black then 0 else 1
  end if
  return result
end function

function flip01(v as Int) returns Int
  return if v is 0 then 1 else 0
end function

test test_flip01
  assert flip01(0) is 1
  assert flip01(1) is 0
end test

function isValidQuadrant(q as Int) returns Boolean
  return (q mod 5) isnt 0
end function

test test_isValidQuadrant
  assert isValidQuadrant(0) is false
  assert isValidQuadrant(1) is true
  assert isValidQuadrant(2) is true
  assert isValidQuadrant(3) is true
  assert isValidQuadrant(4) is true
  assert isValidQuadrant(5) is false
  assert isValidQuadrant(6) is true
  assert isValidQuadrant(7) is true
  assert isValidQuadrant(8) is true
  assert isValidQuadrant(9) is true
  assert isValidQuadrant(10) is false
  assert isValidQuadrant(11) is true
  assert isValidQuadrant(12) is true
  assert isValidQuadrant(13) is true
  assert isValidQuadrant(14) is true
  assert isValidQuadrant(15) is false
end test

class Point
  property x as Int

  property y as Int

  constructor(x as Int, y as Int)
    set property.x to x
    set property.y to y
  end constructor

  # Returns the 8 theoretically-neighbouring points, whether or not within bounds
  function neighbouringPoints() returns List<of Point>
    constant x set to property.x
    constant y set to property.y
    return [new Point(x - 1, y - 1), new Point(x, y - 1), new Point(x + 1, y - 1), new Point(x - 1, y), new Point(x + 1, y), new Point(x - 1, y + 1), new Point(x, y + 1), new Point(x + 1, y + 1)]
  end function

end class

test test_neighbouringPoints
  variable p set to new Point(0, 0)
  variable n set to p.neighbouringPoints()
  variable expected set to [new Point(-1, -1), new Point(0, -1), new Point(1, -1), new Point(-1, 0), new Point(1, 0), new Point(-1, 1), new Point(0, 1), new Point(1, 1)]
  assert n is expected
end test
