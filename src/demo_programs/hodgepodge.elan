# 727704f5e98de05d8b09be4bbfbcd5abc1a464f896b70fee811526c2d1ca38c5 Elan 2.0.0-alpha guest default_profile valid

# Hodgepodge, after M.Gerhardt, H.Schuster, J.Tyson (1990) 
# A Cellular Automaton Model of Excitable Media
# 
# gW, gH : grid width, height
constant gW set to 40

constant gH set to 30

# iR : infection rate (1..20)
constant iR set to 1

# w1, w2 : weighting factors (low integers)
constant w1 set to 4

constant w2 set to 1

# colours : cellColour.s in descending order of RGB value
# state : of a cell is colours.indexOf(cellColour) in [0..colours.length() - 1]
# colours[0] = healthy; colours[colours.length() - 1] = ill, otherwise infected
constant healthy set to white

constant ill set to black

constant colours set to {healthy, 0xffe6ff, 0xffccff, 0xffb3ff, 0xff99ff, 0xff80ff, 0xff66ff, 0xff4dff, 0xff33ff, 0xff1aff, 0xff00ff, 0xe600e6, 0xcc00cc, 0xb300b3, 0x990099, 0x800080, 0x660066, 0x4d004d, 0x330033, 0x1a001a, ill}

# vN : neighbourhood: von Neumann (4) true, Moore (8) false
constant vN set to false

main
  # colour grids: hodge for display, podge for working
  variable podge set to new Array2D<of Int>(gW, gH, healthy)
  variable hodge set to new Array2D<of Int>(gW, gH, healthy)
  constant blank set to new Array2D<of Int>(gW, gH, healthy)
  # initial colours of grid
  call updateGrid(hodge, podge, true)
  while not uniform(hodge)
    # successive updates to grid in blank podge
    set podge to blank
    call updateGrid(hodge, podge, false)
  end while
end main

procedure updateGrid(out hodge as Array2D<of Int>, podge as Array2D<of Int>, initial as Boolean)
  for j from 0 to gH - 1 step 1
    for i from 0 to gW - 1 step 1
      if initial then
        call podge.put(i, j, colours[randomInt(0, (colours.length() - 1))])
        [ghosted] call podge.put(1, 1, 0x1a001a)
      else
        call podge.put(i, j, newColour(getNeighbourColours(hodge, i, j), hodge[i, j]))
      end if
    end for
  end for
  constant a set to 0
  set hodge to podge
  call displayBlocks(hodge)
  call pause(50)
end procedure

function uniform(grid as Array2D<of Int>) returns Boolean
  constant uniformGrid set to new Array2D<of Int>(gW, gH, grid[0, 0])
  return if grid.isSameValueAs(uniformGrid) then true else false
end function

function getNeighbourColours(grid as Array2D<of Int>, i as Int, j as Int) returns List<of Int>
  # grid wraps around: all cells have the same number of neighbours
  # H and V neighbours(von Neumann)
  constant sL set to grid[(i - 1 + gW) mod gW, j]
  constant sR set to grid[(i + 1 + gW) mod gW, j]
  constant sA set to grid[i, (j - 1 + gH) mod gH]
  constant sB set to grid[i, (j + 1 + gH) mod gH]
  variable neighbourColours set to [sL, sR, sA, sB]
  if vN is false then
    # add diagonal neighbours (Moore)
    constant sLA set to grid[(i - 1 + gW) mod gW, (j - 1 + gH) mod gH]
    constant sRA set to grid[(i + 1 + gW) mod gW, (j - 1 + gH) mod gH]
    constant sLB set to grid[(i - 1 + gW) mod gW, (j + 1 + gH) mod gH]
    constant sRB set to grid[(i + 1 + gW) mod gW, (j + 1 + gH) mod gH]
    set neighbourColours to [sL, sR, sA, sB, sLA, sRA, sLB, sRB]
  end if
  return neighbourColours
end function

function newColour(neighbourColours as List<of Int>, nowColour as Int) returns Int
  variable nInfected set to 0
  variable nIll set to 0
  variable sumStates set to colours.indexOf(nowColour)
  each colour in neighbourColours
    set sumStates to sumStates + colours.indexOf(colour)
    if colour < healthy then
      set nInfected to nInfected + 1
      if colour is ill then
        set nIll to nIll + 1
      end if
    end if
  end each
  return updateColour(nowColour, sumStates, nInfected, nIll)
end function

function updateColour(nowColour as Int, sumStates as Int, nInfected as Int, nIll as Int) returns Int
  variable state set to 0
  if nowColour is healthy then
    set state to divAsInteger(nInfected, w1) + divAsInteger(nIll, w2)
  elif nowColour isnt ill then
    set state to divAsInteger(sumStates, (nInfected + 1)) + iR
  end if
  return if state > (colours.length() - 1) then ill else colours[state]
end function
