# acdfc88a4175adf89b588d5210489fbaef633f8be01b93b31d172fc371708e6c Elan 2.0.0-alpha guest default_profile valid

main
  variable start set to newPoint(5, 5)
  variable destination set to newPoint(34, 24)
  variable percentRocks set to inputIntBetween("Enter % rocks (0-100): ", 0, 100)
  call clearPrintedText()
  variable rocks set to empty List<of Point>
  variable nodes set to empty List<of Node>
  call createRocksAndNodes(percentRocks, rocks, nodes, start, destination)
  variable gr set to initialiseGraphics(start, destination, rocks)
  call displayBlocks(gr)
  variable solver set to new Solver(nodes, start, destination)
  while true
    constant option set to inputStringFromOptions(algPrompt, ["a", "d", "h"])
    call clearPrintedText()
    constant alg set to getAlgFromLetter(option)
    call runSolver(gr, start, destination, rocks, solver, alg)
  end while
end main

procedure runSolver(gr as Array2D<of Int>, start as Point, destination as Point, rocks as List<of Point>, out solver as Solver, alg as Algorithm)
  call solver.initialise(alg)
  variable gr2 set to initialiseGraphics(start, destination, rocks)
  while solver.running
    call solver.visitNextPoint()
    set gr2 to addVisited(gr2, solver.getLastVisited())
    call displayBlocks(gr2)
    call pause(0)
  end while
  if solver.getLastVisited().isSameValueAs(destination) then
    variable route, length set to solver.getRouteAndLength()
    set gr2 to addRoute(gr2, route)
    call displayBlocks(gr2)
    call printNoLine("Length of route: {length.round(2)} ")
  else
    call printNoLine("No path found. ")
  end if
end procedure

procedure createRocksAndNodes(percentRocks as Int, out rocks as List<of Point>, out nodes as List<of Node>, start as Point, dest as Point)
  for x from 0 to 39 step 1
    for y from 1 to 29 step 1
      variable p set to newPoint(x, y)
      if p.isSameValueAs(start) then
        call nodes.append(new Node(p, 0, p.minDistTo(dest)))
      elif p.isSameValueAs(dest) then
        call nodes.append(new Node(p, infinity, 0))
      elif random() < divAsFloat(percentRocks, 100) then
        call rocks.append(p)
      else
        call nodes.append(new Node(p, infinity, p.minDistTo(dest)))
      end if
    end for
  end for
end procedure

function initialiseGraphics(start as Point, dest as Point, rocks as List<of Point>) returns Array2D<of Int>
  variable gr set to new Array2D<of Int>(40, 30, white)
  each rock in rocks
    set gr to gr.withPut(rock.x, rock.y, black)
  end each
  set gr to gr.withPut(start.x, start.y, green)
  set gr to gr.withPut(dest.x, dest.y, red)
  return gr
end function

function addVisited(gr as Array2D<of Int>, visited as Point) returns Array2D<of Int>
  return gr.withPut(visited.x, visited.y, lightBlue)
end function

function addRoute(gr as Array2D<of Int>, route as ListImmutable<of Point>) returns Array2D<of Int>
  variable gr2 set to gr
  each p in route
    set gr2 to gr2.withPut(p.x, p.y, orange)
  end each
  constant start set to route[0]
  constant dest set to route[route.length() - 1]
  set gr2 to gr2.withPut(start.x, start.y, green)
  set gr2 to gr2.withPut(dest.x, dest.y, red)
  return gr2
end function

class Solver
  constructor(nodes as List<of Node>, start as Point, destination as Point)
    set property.nodes to nodes
    set property.start to start
    set property.destination to destination
  end constructor

  property nodes as List<of Node>

  property start as Point

  property destination as Point

  property current as Node

  property alg as Algorithm

  property running as Boolean

  procedure initialise(alg as Algorithm)
    set property.alg to alg
    set property.current to new Node(property.start, 0, infinity)
    set property.running to true
    each node in property.nodes
      call node.setDistanceFromStart(infinity)
      call node.setVia(empty Point)
      call node.setVisited(false)
    end each
  end procedure

  procedure visitNextPoint()
    call updateNeighbours()
    set property.current to nextNodeToVisit()
    if (property.current.isSameValueAs(empty Node)) or (property.current.point.isSameValueAs(property.destination)) then
      set property.running to false
    else
      call property.current.setVisited(true)
    end if
  end procedure

  procedure updateNeighbours()
    constant distToCurrent set to property.current.distFromStart
    each neighbour in currentNeighbours()
      variable currentPoint set to property.current.point
      variable distViaCurrent set to distToCurrent + currentPoint.minDistTo(neighbour.point)
      if distViaCurrent < neighbour.distFromStart then
        call neighbour.setVia(property.current.point)
        call neighbour.setDistanceFromStart(distViaCurrent)
      end if
    end each
  end procedure

  function currentNeighbours() returns List<of Node>
    variable neighbours set to new List<of Node>()
    variable currentPoint set to property.current.point
    each p in currentPoint.neighbouringPoints()
      variable node set to getNodeFor(p)
      variable point set to node.point
      if point.isNotEmpty then
        set neighbours to neighbours.withAppend(node)
      end if
    end each
    return neighbours
  end function

  function getNodeFor(p as Point) returns Node
    constant matches set to property.nodes.filter(lambda n as Node => n.point.isSameValueAs(p))
    return if matches.length() is 1 then matches.head() else empty Node
  end function

  function getLastVisited() returns Point
    return property.current.point
  end function

  function nextNodeToVisit() returns Node
    variable lowestCostSoFar set to infinity
    variable lowestCostNode set to empty Node
    constant possibilities set to property.nodes.filter(lambda nd as Node => (not nd.visited) and (nd.distFromStart < infinity))
    each nd in possibilities
      variable cost set to calculateCost(nd)
      if cost < lowestCostSoFar then
        set lowestCostSoFar to cost
        set lowestCostNode to nd
      end if
    end each
    return lowestCostNode
  end function

  function calculateCost(node as Node) returns Float
    variable cost set to 0.0
    constant fromStart set to node.distFromStart
    constant estToDest set to node.estDistToDest
    if property.alg is Algorithm.dijkstra then
      set cost to fromStart
    elif property.alg is Algorithm.aStar then
      set cost to fromStart + estToDest
    elif property.alg is Algorithm.heuristic then
      set cost to estToDest
    end if
    return cost
  end function

  function getRouteAndLength() returns (ListImmutable<of Point>, Float)
    variable route set to {property.destination}
    variable length set to 0.0
    variable node set to getNodeFor(property.destination)
    while not node.point.isSameValueAs(property.start)
      variable previous set to node.via
      variable p set to node.point
      set length to length + p.minDistTo(previous)
      set route to route.withInsert(0, previous)
      set node to getNodeFor(previous)
    end while
    return tuple(route, length)
  end function

end class

class Node
  constructor(p as Point, distFromStart as Float, estDistToDest as Float)
    set property.point to p
    set property.visited to false
    set property.distFromStart to distFromStart
    set property.via to empty Point
    set property.estDistToDest to estDistToDest
  end constructor

  property point as Point

  property visited as Boolean

  property distFromStart as Float

  property via as Point

  property estDistToDest as Float

  procedure setVisited(value as Boolean)
    set property.visited to value
  end procedure

  procedure setDistanceFromStart(d as Float)
    set property.distFromStart to d
  end procedure

  procedure setVia(p as Point)
    set property.via to p
  end procedure

  function asString() returns String
    return "[{property.point.asString()} {property.visited} {property.distFromStart}]"
  end function

end class

record Point
  property x as Int

  property y as Int

  property isNotEmpty as Boolean

  function minDistTo(p as Point) returns Float
    return sqrt(power((p.x - property.x), 2) + power((p.y - property.y), 2))
  end function

  function isAdjacentTo(p as Point) returns Boolean
    return (minDistTo(p) is 1) or (minDistTo(p).round(4) is sqrt(2).round(4))
  end function

  # Returns the 8 theoretically-neighbouring points, whether or not within bounds
  function neighbouringPoints() returns ListImmutable<of Point>
    return {newPoint(property.x - 1, property.y - 1), newPoint(property.x, property.y - 1), newPoint(property.x + 1, property.y - 1), newPoint(property.x - 1, property.y), newPoint(property.x + 1, property.y), newPoint(property.x - 1, property.y + 1), newPoint(property.x, property.y + 1), newPoint(property.x + 1, property.y + 1)}
  end function

  function asString() returns String
    return "{property.x},{property.y}"
  end function

end record

function newPoint(x as Int, y as Int) returns Point
  return new Point() with x set to x, y set to y, isNotEmpty set to true
end function

enum Algorithm dijkstra, aStar, heuristic

# 'infinity' need only be larger than longest possible route
constant infinity set to 2000.0

constant algPrompt set to "Enter 'a' for A-star, 'd' for Dijkstra, 'h' for Heuristic"

constant lightBlue set to 0x80abff

constant orange set to 0xe97132

function getAlgFromLetter(letter as String) returns Algorithm
  variable dict set to ["a":Algorithm.aStar, "d":Algorithm.dijkstra, "h":Algorithm.heuristic]
  return dict[letter]
end function

test test_getAlgFromLetter
  assert getAlgFromLetter("a") is Algorithm.aStar
  assert getAlgFromLetter("h") is Algorithm.heuristic
  assert getAlgFromLetter("d") is Algorithm.dijkstra
  assert getAlgFromLetter("x") is "No such key: x"
end test

test test_point
  constant p set to newPoint(0, 0)
  constant n set to p.neighbouringPoints()
  constant expected set to {newPoint(-1, -1), newPoint(0, -1), newPoint(1, -1), newPoint(-1, 0), newPoint(1, 0), newPoint(-1, 1), newPoint(0, 1), newPoint(1, 1)}
  assert n is expected
end test
